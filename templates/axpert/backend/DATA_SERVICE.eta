<%~ include("views/func.eta", { SCHEMA }) %>

<%
const FIELDS = SCHEMA.dcs
  .flatMap(dc => dc.fields)
  .filter(f => f.fldsql);
%>

"""
<%= toClassName(PAGE_TITLE) %> Data Service - Execute SQL queries for dynamic data loading
<%= PAGE_TITLE %>
This service provides individual functions for each field with a factory function dispatcher.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from typing import List, Any, Optional, Union
from app.utils.sql import sql_template_replace

class <%= toClassName(PAGE_TITLE) %>DataService:
    """Service for fetching data via fldsql expressions"""

    def __init__(self):
        """Initialize field handlers mapping"""
        self.field_handlers = {
<% for (const field of FIELDS.filter(f => f.fldsql?.trim())) { %>
            "<%= field.fname %>": self.get_<%= field.fname.toLowerCase() %>_data,
<% } %>
<% for ( const fillgrid of SCHEMA.fillGrids || [] ) { %>
            "fill_<%= fillgrid.name.toLowerCase() %>": self.fill_<%= fillgrid.name.toLowerCase() %>_data,   
<% } %>
<% for ( const subgrid of (SCHEMA.subGrids || []).filter(sg => sg.autoFill ) ) { %>
            "subgrid_<%= subgrid.name.toLowerCase() %>": self.subgrid_<%= subgrid.name.toLowerCase() %>_data,
<% } %>
        }

<% for (const field of FIELDS.filter(f => f.fldsql?.trim())) { %>
    async def get_<%= field.fname.toLowerCase() %>_data( self,db: AsyncSession,params: Optional[dict] = None) -> Union[List[Any], Any]:
        """Fetch data for field '<%= field.fname %>' using its fldsql expression"""
        sql = """<%~ convertSqlToLowercase(field.fldsql?.trim()) %>"""
        if params:
            templated_sql = sql_template_replace(sql, **params)
            result = await db.execute(text(templated_sql), params)
        else:
            result = await db.execute(text(sql))
       
<% if (field.modeofentry === 'select') { %>
        rows = result.fetchall()
        return [row._asdict() for row in rows]
<% } else { %>
        return result.scalar()
<% } %>
<% } %>
    # Dispatcher method to get field data
    async def get_field_data(self, field_name: str, db: AsyncSession, params: Optional[dict] = None) -> Union[List[Any], Any]:
        """Dispatcher to get data for a specific field by name"""
        handler = self.field_handlers.get(field_name)
        if not handler:
            raise ValueError(f"No data handler found for field: {field_name}")
        return await handler(db, params)
    
    # fill grid data method
<% for ( const fillgrid of SCHEMA.fillGrids || [] ) { %>
    async def fill_<%= fillgrid.name.toLowerCase() %>_data(self, db: AsyncSession, params: Optional[dict] = None) -> List[Any]:
        """Fetch data for fill grid '<%= fillgrid.fgname %>' using its SQL expression"""
        sql = """<%~ convertSqlToLowercase(fillgrid.sql?.trim()) %>"""
        if params:
            templated_sql = sql_template_replace(sql, **params)
            result = await db.execute(text(templated_sql), params)
        else:
            result = await db.execute(text(sql))
        rows = result.fetchall()
        return [row._asdict() for row in rows]
<% } %>

    # subgrid data method
<% for ( const subgrid of (SCHEMA.subGrids || []).filter(sg => sg.autoFill ) ) { %>
    async def subgrid_<%= subgrid.name.toLowerCase() %>_data(self, db: AsyncSession, params: Optional[dict] = None) -> List[Any]:
        """Fetch data for subgrid '<%= subgrid.sgname %>' using its SQL expression"""
        sql = """<%~ convertSqlToLowercase(subgrid.fillScript.trim()) %>"""
        if params:
            templated_sql = sql_template_replace(sql, **params)
            result = await db.execute(text(templated_sql), params)
        else:
            result = await db.execute(text(sql))
        rows = result.fetchall()
        return [row._asdict() for row in rows]
<% } %>