<%

    const MODEL_SERVICE_NAME = toClassName(PAGE_TITLE) + "Service";
    const DATA_SERVICE_NAME = toClassName(PAGE_TITLE) + "DataService";
    const SCHEMA_NAME = toClassName(PAGE_TITLE) + "Schema";
    const PARAMETER_SCHEMA_NAME = toClassName(PAGE_TITLE) + "ParameterSchema";
    
%>


from fastapi import APIRouter,Body, Depends, HTTPException, status, Query, Path
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
from typing import List, Optional, Any
from app.db.session import get_db_async
from .schemas import <%= SCHEMA_NAME %>

from .services import <%= MODEL_SERVICE_NAME %>, <%= DATA_SERVICE_NAME %>

from .schemas import <%= PARAMETER_SCHEMA_NAME %>


# Import Parameter schema and data service

try:
    from .services import <%= DATA_SERVICE_NAME %>

    data_service = <%= DATA_SERVICE_NAME %>()
except ImportError:
    data_service = None

router = APIRouter(
    prefix="/<%= __module__ %>",
    tags=["<%= __module__ %>"],
)

service = <%= MODEL_SERVICE_NAME %>()

# ============= MASTER TABLE ENDPOINTS (<% %>>) =============

@router.get("/", response_model=List[<%= SCHEMA_NAME %>])
async def get_<%= __module__ %>_list(
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db_async)
):
    """Get list of ordmas records"""
    items = await service.get_all(db, skip=skip, limit=limit)
    return items


@router.get("/count", response_model=dict)
async def get_<%= __module__ %>_count(db: AsyncSession = Depends(get_db_async)):
    """Get total count of <%= __module__ %> records"""
    count = await service.count(db)
    return {"count": count}


@router.get("/{id}", response_model=<%= SCHEMA_NAME %>)
async def get_<%= __module__ %>(id: int, db: AsyncSession = Depends(get_db_async)):
    """Get a single <%= __module__ %> record with all details"""
    item = await service.get_by_id(db, id)
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"<%= __Module__ %> with id {id} not found"
        )
    return item


@router.post("/", response_model=<%= SCHEMA_NAME %>, status_code=status.HTTP_201_CREATED)
async def create_<%= __module__ %>(data: dict, db: AsyncSession = Depends(get_db_async)):
    """Create a new <%= __module__ %> record"""
    try:
        new_item = await service.create(db, data)
        return new_item
    except IntegrityError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Integrity constraint violation: {str(e.orig)}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating ordmas: {str(e)}"
        )


@router.put("/{id}", response_model=<%= SCHEMA_NAME %>)
async def update_<%= __module__ %>(id: int, data: dict, db: AsyncSession = Depends(get_db_async)):
    """Update a <%= __module__ %> record"""
    try:
        item = await service.update(db, id, data)
        if not item:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"<%= __Module__ %> with id {id} not found"
            )
        return item
    except IntegrityError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Integrity constraint violation: {str(e.orig)}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating <%= __module__ %>: {str(e)}"
        )


@router.delete("/{id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_<%= __module__ %>(id: int, db: AsyncSession = Depends(get_db_async)):
    """Delete a <%= __module__ %> record"""
    try:
        success = await service.delete(db, id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"<%= __Module__ %> with id {id} not found"
            )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting <%= __module__ %>: {str(e)}"
        )


# ============= DATA ROUTES (Dynamic SQL Query Endpoints) =============

@router.post("/data/{field_name}", tags=["data"])
async def get_field_data(
    field_name: str = Path(..., description="Name of the field to fetch data for"),
    params: dict = Body(default={}, description="Query parameters as key-value pairs"),
    db: AsyncSession = Depends(get_db_async)
):
    '''
    Factory endpoint to get data for any field with fldsql defined.
    
    Args:
        field_name: Name of the field (from axflds.fname)
        params: Filter parameters to bind to the SQL query
        
    Returns:
        {
            "success": true,
            "data": [...],  // List if field is select mode, scalar otherwise
            "field": "field_name"
        }
        
    Raises:
        404: If field_name is not found
        500: If query execution fails
    '''
    if data_service is None:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Data service not available"
        )
    
    try:
        # Prepare parameters
        params_dict = None
        if params:
            if hasattr(params, 'model_dump'):
                params_dict = params.model_dump(exclude_none=True)
            elif isinstance(params, dict):
                params_dict = params
        
        # Call factory function
        result = await data_service.get_field_data(field_name,db, params_dict)
        
        return {
            "success": True,
            "field": field_name,
            "data": result
        }
    
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching data for field '{field_name}': {str(e)}"
        )
