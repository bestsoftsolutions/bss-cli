#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/oracledb/lib/version.js
var require_version = __commonJS({
  "node_modules/oracledb/lib/version.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      VERSION_MAJOR: 6,
      VERSION_MINOR: 10,
      VERSION_PATCH: 0,
      VERSION_SUFFIX: ""
    };
  }
});

// node_modules/oracledb/lib/constants.js
var require_constants = __commonJS({
  "node_modules/oracledb/lib/constants.js"(exports2, module2) {
    "use strict";
    var version = require_version();
    var VERSION_STRING = version.VERSION_MAJOR + "." + version.VERSION_MINOR + "." + version.VERSION_PATCH + version.VERSION_SUFFIX;
    module2.exports = {
      // version information
      VERSION_MAJOR: version.VERSION_MAJOR,
      VERSION_MINOR: version.VERSION_MINOR,
      VERSION_PATCH: version.VERSION_PATCH,
      VERSION_SUFFIX: version.VERSION_SUFFIX,
      VERSION_STRING,
      // defaults for initOracleClient()
      DEFAULT_DRIVER_NAME: "node-oracledb : " + VERSION_STRING,
      DEFAULT_ERROR_URL: "https://node-oracledb.readthedocs.io/en/latest/user_guide/installation.html",
      // default for maxSize for OUT and IN/OUT binds
      DEFAULT_MAX_SIZE_FOR_OUT_BINDS: 200,
      // character set forms (internal use)
      CSFRM_IMPLICIT: 1,
      CSFRM_NCHAR: 2,
      // CQN operation codes
      CQN_OPCODE_ALL_OPS: 0,
      CQN_OPCODE_ALL_ROWS: 1,
      CQN_OPCODE_ALTER: 16,
      CQN_OPCODE_DELETE: 8,
      CQN_OPCODE_DROP: 32,
      CQN_OPCODE_INSERT: 2,
      CQN_OPCODE_UPDATE: 4,
      // fetchInfo type defaulting
      DEFAULT: 0,
      // statement types
      STMT_TYPE_UNKNOWN: 0,
      STMT_TYPE_SELECT: 1,
      STMT_TYPE_UPDATE: 2,
      STMT_TYPE_DELETE: 3,
      STMT_TYPE_INSERT: 4,
      STMT_TYPE_CREATE: 5,
      STMT_TYPE_DROP: 6,
      STMT_TYPE_ALTER: 7,
      STMT_TYPE_BEGIN: 8,
      STMT_TYPE_DECLARE: 9,
      STMT_TYPE_CALL: 10,
      STMT_TYPE_EXPLAIN_PLAN: 15,
      STMT_TYPE_MERGE: 16,
      STMT_TYPE_ROLLBACK: 17,
      STMT_TYPE_COMMIT: 21,
      // shutdown modes
      SHUTDOWN_MODE_DEFAULT: 0,
      SHUTDOWN_MODE_TRANSACTIONAL: 1,
      SHUTDOWN_MODE_TRANSACTIONAL_LOCAL: 2,
      SHUTDOWN_MODE_IMMEDIATE: 3,
      SHUTDOWN_MODE_ABORT: 4,
      SHUTDOWN_MODE_FINAL: 5,
      // startup modes
      STARTUP_MODE_DEFAULT: 0,
      STARTUP_MODE_FORCE: 1,
      STARTUP_MODE_RESTRICT: 2,
      // subscription event types
      SUBSCR_EVENT_TYPE_SHUTDOWN: 2,
      SUBSCR_EVENT_TYPE_SHUTDOWN_ANY: 3,
      SUBSCR_EVENT_TYPE_STARTUP: 1,
      SUBSCR_EVENT_TYPE_DEREG: 5,
      SUBSCR_EVENT_TYPE_OBJ_CHANGE: 6,
      SUBSCR_EVENT_TYPE_QUERY_CHANGE: 7,
      SUBSCR_EVENT_TYPE_AQ: 100,
      // subscription grouping classes
      SUBSCR_GROUPING_CLASS_TIME: 1,
      // subscription grouping types
      SUBSCR_GROUPING_TYPE_SUMMARY: 1,
      SUBSCR_GROUPING_TYPE_LAST: 2,
      // subscription namespaces
      SUBSCR_NAMESPACE_AQ: 1,
      SUBSCR_NAMESPACE_DBCHANGE: 2,
      // subscription quality of service flags
      SUBSCR_QOS_BEST_EFFORT: 16,
      SUBSCR_QOS_DEREG_NFY: 2,
      SUBSCR_QOS_QUERY: 8,
      SUBSCR_QOS_RELIABLE: 1,
      SUBSCR_QOS_ROWIDS: 4,
      // privileges
      SYSASM: 32768,
      SYSBACKUP: 131072,
      SYSDBA: 2,
      SYSDG: 262144,
      SYSKM: 524288,
      SYSOPER: 4,
      SYSPRELIM: 8,
      SYSRAC: 1048576,
      // bind directions
      BIND_IN: 3001,
      BIND_INOUT: 3002,
      BIND_OUT: 3003,
      // outFormat values
      OUT_FORMAT_ARRAY: 4001,
      OUT_FORMAT_OBJECT: 4002,
      // SODA collection creation modes
      SODA_COLL_MAP_MODE: 5001,
      // pool statuses
      POOL_STATUS_OPEN: 6e3,
      POOL_STATUS_DRAINING: 6001,
      POOL_STATUS_CLOSED: 6002,
      POOL_STATUS_RECONFIGURING: 6003,
      // purity values
      PURITY_DEFAULT: 0,
      PURITY_NEW: 1,
      PURITY_SELF: 2,
      // AQ dequeue wait options
      AQ_DEQ_NO_WAIT: 0,
      AQ_DEQ_WAIT_FOREVER: 4294967295,
      // AQ dequeue modes
      AQ_DEQ_MODE_BROWSE: 1,
      AQ_DEQ_MODE_LOCKED: 2,
      AQ_DEQ_MODE_REMOVE: 3,
      AQ_DEQ_MODE_REMOVE_NO_DATA: 4,
      // AQ dequeue navigation flags
      AQ_DEQ_NAV_FIRST_MSG: 1,
      AQ_DEQ_NAV_NEXT_TRANSACTION: 2,
      AQ_DEQ_NAV_NEXT_MSG: 3,
      // AQ message delivery modes
      AQ_MSG_DELIV_MODE_PERSISTENT: 1,
      AQ_MSG_DELIV_MODE_BUFFERED: 2,
      AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED: 3,
      // AQ message states
      AQ_MSG_STATE_READY: 0,
      AQ_MSG_STATE_WAITING: 1,
      AQ_MSG_STATE_PROCESSED: 2,
      AQ_MSG_STATE_EXPIRED: 3,
      // AQ visibility flags
      AQ_VISIBILITY_IMMEDIATE: 1,
      AQ_VISIBILITY_ON_COMMIT: 2,
      // TPC/XA begin flags Constants
      TPC_BEGIN_JOIN: 2,
      TPC_BEGIN_NEW: 1,
      TPC_BEGIN_PROMOTE: 8,
      TPC_BEGIN_RESUME: 4,
      // TPC/XA two-phase commit flags
      TPC_END_NORMAL: 0,
      TPC_END_SUSPEND: 1048576,
      // vector types
      VECTOR_FORMAT_FLOAT32: 2,
      VECTOR_FORMAT_FLOAT64: 3,
      VECTOR_FORMAT_INT8: 4,
      VECTOR_FORMAT_BINARY: 5
    };
  }
});

// node_modules/oracledb/lib/types.js
var require_types = __commonJS({
  "node_modules/oracledb/lib/types.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var errors = require_errors();
    var util = require("util");
    var dbTypeByNum = /* @__PURE__ */ new Map();
    var dbTypeByOraTypeNum = /* @__PURE__ */ new Map();
    var dbTypeByColumnTypeName = /* @__PURE__ */ new Map();
    var MAX_UINT32 = Math.pow(2, 32) - 1;
    var DbType = class {
      constructor(num, name, columnTypeName, options) {
        this.num = num;
        this.name = name;
        this.columnTypeName = columnTypeName;
        this._bufferSizeFactor = options.bufferSizeFactor || 0;
        this._oraTypeNum = options.oraTypeNum || 0;
        this._csfrm = options.csfrm || 0;
        dbTypeByNum.set(num, this);
        const key = this._csfrm * 256 + this._oraTypeNum;
        dbTypeByOraTypeNum.set(key, this);
        dbTypeByColumnTypeName.set(columnTypeName, this);
      }
      [Symbol.toPrimitive](hint) {
        switch (hint) {
          case "number":
            return this.num;
          default:
            return this.toString();
        }
      }
      [util.inspect.custom]() {
        return this.toString();
      }
      toString() {
        return `[DbType ${this.name}]`;
      }
    };
    function getTypeByColumnTypeName(name) {
      const dbType = dbTypeByColumnTypeName.get(name);
      if (!dbType)
        errors.throwErr(errors.ERR_UNKNOWN_COLUMN_TYPE_NAME, name);
      return dbType;
    }
    function getTypeByNum(num) {
      const dbType = dbTypeByNum.get(num);
      if (!dbType)
        errors.throwErr(errors.ERR_INVALID_TYPE_NUM, num);
      return dbType;
    }
    function getTypeByOraTypeNum(oraTypeNum, csfrm) {
      const key = (csfrm || 0) * 256 + oraTypeNum;
      const dbType = dbTypeByOraTypeNum.get(key);
      if (!dbType)
        errors.throwErr(errors.ERR_INVALID_ORACLE_TYPE_NUM, oraTypeNum, csfrm);
      return dbType;
    }
    var DB_TYPE_BFILE = new DbType(
      2020,
      "DB_TYPE_BFILE",
      "BFILE",
      { oraTypeNum: 114, bufferSizeFactor: 4e3 }
    );
    var DB_TYPE_BINARY_DOUBLE = new DbType(
      2008,
      "DB_TYPE_BINARY_DOUBLE",
      "BINARY_DOUBLE",
      { oraTypeNum: 101, bufferSizeFactor: 8 }
    );
    var DB_TYPE_BINARY_FLOAT = new DbType(
      2007,
      "DB_TYPE_BINARY_FLOAT",
      "BINARY_FLOAT",
      { oraTypeNum: 100, bufferSizeFactor: 4 }
    );
    var DB_TYPE_BINARY_INTEGER = new DbType(
      2009,
      "DB_TYPE_BINARY_INTEGER",
      "BINARY_INTEGER",
      { oraTypeNum: 3, bufferSizeFactor: 22 }
    );
    var DB_TYPE_BLOB = new DbType(
      2019,
      "DB_TYPE_BLOB",
      "BLOB",
      { oraTypeNum: 113, bufferSizeFactor: 112 }
    );
    var DB_TYPE_BOOLEAN = new DbType(
      2022,
      "DB_TYPE_BOOLEAN",
      "BOOLEAN",
      { oraTypeNum: 252, bufferSizeFactor: 4 }
    );
    var DB_TYPE_CHAR = new DbType(
      2003,
      "DB_TYPE_CHAR",
      "CHAR",
      { oraTypeNum: 96, csfrm: constants.CSFRM_IMPLICIT, bufferSizeFactor: 4 }
    );
    var DB_TYPE_CLOB = new DbType(
      2017,
      "DB_TYPE_CLOB",
      "CLOB",
      { oraTypeNum: 112, csfrm: constants.CSFRM_IMPLICIT, bufferSizeFactor: 112 }
    );
    var DB_TYPE_CURSOR = new DbType(
      2021,
      "DB_TYPE_CURSOR",
      "CURSOR",
      { oraTypeNum: 102, bufferSizeFactor: 4 }
    );
    var DB_TYPE_DATE = new DbType(
      2011,
      "DB_TYPE_DATE",
      "DATE",
      { oraTypeNum: 12, bufferSizeFactor: 7 }
    );
    var DB_TYPE_INTERVAL_DS = new DbType(
      2015,
      "DB_TYPE_INTERVAL_DS",
      "INTERVAL DAY TO SECOND",
      { oraTypeNum: 183, bufferSizeFactor: 11 }
    );
    var DB_TYPE_INTERVAL_YM = new DbType(
      2016,
      "DB_TYPE_INTERVAL_YM",
      "INTERVAL YEAR TO MONTH",
      { oraTypeNum: 182, bufferSizeFactor: 5 }
    );
    var DB_TYPE_JSON = new DbType(
      2027,
      "DB_TYPE_JSON",
      "JSON",
      { oraTypeNum: 119 }
    );
    var DB_TYPE_LONG = new DbType(
      2024,
      "DB_TYPE_LONG",
      "LONG",
      {
        oraTypeNum: 8,
        csfrm: constants.CSFRM_IMPLICIT,
        bufferSizeFactor: 2 ** 31 - 1
      }
    );
    var DB_TYPE_LONG_NVARCHAR = new DbType(
      2031,
      "DB_TYPE_LONG_NVARCHAR",
      "LONG",
      {
        oraTypeNum: 8,
        csfrm: constants.CSFRM_NCHAR,
        bufferSizeFactor: 2 ** 31 - 1
      }
    );
    var DB_TYPE_LONG_RAW = new DbType(
      2025,
      "DB_TYPE_LONG_RAW",
      "LONG RAW",
      { oraTypeNum: 24, bufferSizeFactor: 2 ** 31 - 1 }
    );
    var DB_TYPE_NCHAR = new DbType(
      2004,
      "DB_TYPE_NCHAR",
      "NCHAR",
      { oraTypeNum: 96, csfrm: constants.CSFRM_NCHAR, bufferSizeFactor: 4 }
    );
    var DB_TYPE_NCLOB = new DbType(
      2018,
      "DB_TYPE_NCLOB",
      "NCLOB",
      { oraTypeNum: 112, csfrm: constants.CSFRM_NCHAR, bufferSizeFactor: 112 }
    );
    var DB_TYPE_NUMBER = new DbType(
      2010,
      "DB_TYPE_NUMBER",
      "NUMBER",
      { oraTypeNum: 2, bufferSizeFactor: 22 }
    );
    var DB_TYPE_NVARCHAR = new DbType(
      2002,
      "DB_TYPE_NVARCHAR",
      "NVARCHAR2",
      { oraTypeNum: 1, csfrm: constants.CSFRM_NCHAR, bufferSizeFactor: 4 }
    );
    var DB_TYPE_OBJECT = new DbType(
      2023,
      "DB_TYPE_OBJECT",
      "OBJECT",
      { oraTypeNum: 109 }
    );
    var DB_TYPE_RAW = new DbType(
      2006,
      "DB_TYPE_RAW",
      "RAW",
      { oraTypeNum: 23, bufferSizeFactor: 1 }
    );
    var DB_TYPE_ROWID = new DbType(
      2005,
      "DB_TYPE_ROWID",
      "ROWID",
      { oraTypeNum: 11, bufferSizeFactor: 18 }
    );
    var DB_TYPE_TIMESTAMP = new DbType(
      2012,
      "DB_TYPE_TIMESTAMP",
      "TIMESTAMP",
      { oraTypeNum: 180, bufferSizeFactor: 11 }
    );
    var DB_TYPE_TIMESTAMP_LTZ = new DbType(
      2014,
      "DB_TYPE_TIMESTAMP_LTZ",
      "TIMESTAMP WITH LOCAL TIME ZONE",
      { oraTypeNum: 231, bufferSizeFactor: 11 }
    );
    var DB_TYPE_TIMESTAMP_TZ = new DbType(
      2013,
      "DB_TYPE_TIMESTAMP_TZ",
      "TIMESTAMP WITH TIME ZONE",
      { oraTypeNum: 181, bufferSizeFactor: 13 }
    );
    var DB_TYPE_UROWID = new DbType(
      2030,
      "DB_TYPE_UROWID",
      "UROWID",
      { oraTypeNum: 208 }
    );
    var DB_TYPE_VARCHAR = new DbType(
      2001,
      "DB_TYPE_VARCHAR",
      "VARCHAR2",
      { oraTypeNum: 1, csfrm: constants.CSFRM_IMPLICIT, bufferSizeFactor: 4 }
    );
    var DB_TYPE_XMLTYPE = new DbType(
      2032,
      "DB_TYPE_XMLTYPE",
      "XMLTYPE",
      { oraTypeNum: 109, csfrm: constants.CSFRM_IMPLICIT, bufferSizeFactor: 2147483647 }
    );
    var DB_TYPE_VECTOR = new DbType(
      2033,
      "DB_TYPE_VECTOR",
      "VECTOR",
      { oraTypeNum: 127 }
    );
    var DB_TYPE_CONVERSION_MAP = /* @__PURE__ */ new Map([
      [DB_TYPE_BINARY_DOUBLE, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR]
      ])],
      [DB_TYPE_BINARY_FLOAT, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR]
      ])],
      [DB_TYPE_BLOB, /* @__PURE__ */ new Map([
        [DB_TYPE_RAW, DB_TYPE_LONG_RAW],
        [DB_TYPE_LONG_RAW, DB_TYPE_LONG_RAW]
      ])],
      [DB_TYPE_CHAR, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR]
      ])],
      [DB_TYPE_CLOB, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_LONG],
        [DB_TYPE_LONG, DB_TYPE_LONG]
      ])],
      [DB_TYPE_DATE, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR],
        [DB_TYPE_TIMESTAMP_LTZ, DB_TYPE_TIMESTAMP_LTZ]
      ])],
      [DB_TYPE_JSON, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR]
      ])],
      [DB_TYPE_LONG, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_LONG]
      ])],
      [DB_TYPE_LONG_RAW, /* @__PURE__ */ new Map([
        [DB_TYPE_RAW, DB_TYPE_LONG_RAW]
      ])],
      [DB_TYPE_NCHAR, /* @__PURE__ */ new Map([
        [DB_TYPE_CHAR, DB_TYPE_NCHAR],
        [DB_TYPE_VARCHAR, DB_TYPE_NVARCHAR],
        [DB_TYPE_NVARCHAR, DB_TYPE_NVARCHAR]
      ])],
      [DB_TYPE_NCLOB, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_LONG_NVARCHAR],
        [DB_TYPE_NVARCHAR, DB_TYPE_LONG_NVARCHAR],
        [DB_TYPE_LONG, DB_TYPE_LONG_NVARCHAR],
        [DB_TYPE_LONG_NVARCHAR, DB_TYPE_LONG_NVARCHAR]
      ])],
      [DB_TYPE_NUMBER, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR]
      ])],
      [DB_TYPE_NVARCHAR, /* @__PURE__ */ new Map([
        [DB_TYPE_CHAR, DB_TYPE_NCHAR],
        [DB_TYPE_NCHAR, DB_TYPE_NCHAR],
        [DB_TYPE_VARCHAR, DB_TYPE_NVARCHAR]
      ])],
      [DB_TYPE_RAW, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR]
      ])],
      [DB_TYPE_ROWID, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_ROWID]
      ])],
      [DB_TYPE_TIMESTAMP, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR],
        [DB_TYPE_TIMESTAMP_LTZ, DB_TYPE_TIMESTAMP_LTZ]
      ])],
      [DB_TYPE_TIMESTAMP_LTZ, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR],
        [DB_TYPE_TIMESTAMP_TZ, DB_TYPE_TIMESTAMP_TZ]
      ])],
      [DB_TYPE_TIMESTAMP_TZ, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR],
        [DB_TYPE_TIMESTAMP_LTZ, DB_TYPE_TIMESTAMP_LTZ]
      ])],
      [DB_TYPE_UROWID, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_ROWID]
      ])],
      [DB_TYPE_VECTOR, /* @__PURE__ */ new Map([
        [DB_TYPE_VARCHAR, DB_TYPE_LONG],
        [DB_TYPE_LONG, DB_TYPE_LONG],
        [DB_TYPE_CLOB, DB_TYPE_CLOB]
      ])]
    ]);
    var DB_TYPE_FETCH_TYPE_MAP = /* @__PURE__ */ new Map([
      [DB_TYPE_BFILE, DB_TYPE_BFILE],
      [DB_TYPE_BINARY_DOUBLE, DB_TYPE_BINARY_DOUBLE],
      [DB_TYPE_BINARY_FLOAT, DB_TYPE_BINARY_FLOAT],
      [DB_TYPE_BINARY_INTEGER, DB_TYPE_BINARY_INTEGER],
      [DB_TYPE_BLOB, DB_TYPE_BLOB],
      [DB_TYPE_BOOLEAN, DB_TYPE_BOOLEAN],
      [DB_TYPE_CHAR, DB_TYPE_CHAR],
      [DB_TYPE_CLOB, DB_TYPE_CLOB],
      [DB_TYPE_CURSOR, DB_TYPE_CURSOR],
      [DB_TYPE_DATE, DB_TYPE_DATE],
      [DB_TYPE_INTERVAL_DS, DB_TYPE_INTERVAL_DS],
      [DB_TYPE_INTERVAL_YM, DB_TYPE_INTERVAL_YM],
      [DB_TYPE_JSON, DB_TYPE_JSON],
      [DB_TYPE_LONG, DB_TYPE_LONG],
      [DB_TYPE_LONG_NVARCHAR, DB_TYPE_LONG_NVARCHAR],
      [DB_TYPE_LONG_RAW, DB_TYPE_LONG_RAW],
      [DB_TYPE_NCHAR, DB_TYPE_NCHAR],
      [DB_TYPE_NCLOB, DB_TYPE_NCLOB],
      [DB_TYPE_NUMBER, DB_TYPE_NUMBER],
      [DB_TYPE_NVARCHAR, DB_TYPE_NVARCHAR],
      [DB_TYPE_OBJECT, DB_TYPE_OBJECT],
      [DB_TYPE_RAW, DB_TYPE_RAW],
      [DB_TYPE_ROWID, DB_TYPE_ROWID],
      [DB_TYPE_TIMESTAMP, DB_TYPE_TIMESTAMP],
      [DB_TYPE_TIMESTAMP_LTZ, DB_TYPE_TIMESTAMP_TZ],
      [DB_TYPE_TIMESTAMP_TZ, DB_TYPE_TIMESTAMP_TZ],
      [DB_TYPE_UROWID, DB_TYPE_UROWID],
      [DB_TYPE_VARCHAR, DB_TYPE_VARCHAR],
      [DB_TYPE_XMLTYPE, DB_TYPE_XMLTYPE],
      [DB_TYPE_VECTOR, DB_TYPE_VECTOR]
    ]);
    dbTypeByColumnTypeName.set("PL/SQL BOOLEAN", DB_TYPE_BOOLEAN);
    dbTypeByColumnTypeName.set("PL/SQL BINARY INTEGER", DB_TYPE_BINARY_INTEGER);
    dbTypeByColumnTypeName.set("PL/SQL PLS INTEGER", DB_TYPE_BINARY_INTEGER);
    dbTypeByColumnTypeName.set("TIMESTAMP WITH LOCAL TZ", DB_TYPE_TIMESTAMP_LTZ);
    dbTypeByColumnTypeName.set("TIMESTAMP WITH TZ", DB_TYPE_TIMESTAMP_TZ);
    var JsonId = class extends Uint8Array {
      toJSON() {
        return Buffer.from(this.buffer).toString("hex");
      }
    };
    var SparseVector = class _SparseVector {
      constructor(input) {
        this._indices = new Uint32Array(0);
        this._values = new Float64Array(0);
        this._numDimensions = 0;
        if (!input) {
          return;
        }
        if (typeof input === "object" && "numDimensions" in input && "indices" in input && "values" in input) {
          this._fromObject(input);
        } else if (typeof input === "string") {
          this._fromString(input);
        } else if (this._validDenseArray(input)) {
          this._fromDense(input);
        } else {
          errors.throwErr(errors.ERR_VECTOR_SPARSE_INVALID_INPUT);
        }
      }
      _validDenseArray(value) {
        return value instanceof Float32Array || value instanceof Float64Array || value instanceof Int8Array || Object.getPrototypeOf(value) === Uint8Array.prototype || Array.isArray(value);
      }
      // Check if indexArray and valuesArray have the same length
      static _validateLengths(indices, values) {
        if (indices.length !== values.length) {
          if (!(values instanceof Uint8Array)) {
            errors.throwErr(errors.ERR_VECTOR_SPARSE_INDICES_VALUES_NOT_EQUAL);
          }
        }
      }
      _updateProperties(dims, indices, values) {
        if (!this._validDenseArray(values)) {
          errors.throwErr(errors.ERR_VECTOR_SPARSE_VALUES_IS_NOT_ARRAY);
        }
        if (!(indices instanceof Uint32Array) && !Array.isArray(indices)) {
          errors.throwErr(errors.ERR_VECTOR_SPARSE_INDICES_IS_NOT_ARRAY);
        }
        _SparseVector._validateLengths(indices, values);
        if (!(typeof dims === "number" && Number.isInteger(dims) && dims > 0)) {
          errors.throwErr(errors.ERR_VECTOR_SPARSE_DIMS_IS_NOT_INTEGER);
        }
        this._numDimensions = dims;
        this._indices = indices;
        this._values = values;
        this._convertToTypedArrays();
      }
      _fromObject(input) {
        this._updateProperties(input.numDimensions, input.indices, input.values);
      }
      _convertToTypedArrays() {
        if (!(this._indices instanceof Uint32Array)) {
          const indices = new Uint32Array(this._indices.map((x, index) => {
            if (typeof x !== "number" || !Number.isInteger(x)) {
              errors.throwErr(errors.ERR_VECTOR_SPARSE_INDICES_ELEM_IS_NOT_VALID, index);
            }
            if (x < 0 || x > MAX_UINT32 || x > this.numDimensions - 1) {
              errors.throwErr(
                errors.ERR_VECTOR_SPARSE_INDICES_ELEM_IS_NOT_VALID,
                index
              );
            }
            return x;
          }));
          this._indices = indices;
        }
        this._values = Array.isArray(this._values) ? new Float64Array(this._values) : this._values;
      }
      // Initialize the state using the dense array.
      // The length of input is assumed to be same as
      // dimensions of sparse Vector column.
      // values will be an array even if input is a typedArray.
      _fromDense(input) {
        this._indices = [];
        this._values = [];
        for (let i = 0; i < input.length; i++) {
          if (input[i] !== 0) {
            this._indices.push(i);
            this._values.push(input[i]);
          }
        }
        this._numDimensions = input.length;
        this._convertToTypedArrays();
      }
      // parse a string input into a sparse vector
      _fromString(str) {
        let data;
        try {
          data = JSON.parse(str);
        } catch (e) {
          errors.throwErr(errors.ERR_VECTOR_SPARSE_INVALID_JSON);
        }
        if (!Array.isArray(data) || data.length !== 3) {
          errors.throwErr(errors.ERR_VECTOR_SPARSE_INVALID_STRING);
        }
        const [dims, indices, values] = data;
        this._updateProperties(dims, indices, values);
      }
      // Internal method to create an instance
      static create(sparseValue) {
        _SparseVector._validateLengths(sparseValue.indices, sparseValue.values);
        const instance = Object.create(this.prototype);
        instance._numDimensions = sparseValue.numDimensions;
        instance._indices = sparseValue.indices;
        instance._values = sparseValue.values;
        return instance;
      }
      get indices() {
        return this._indices;
      }
      get values() {
        return this._values;
      }
      get numDimensions() {
        return this._numDimensions;
      }
      toJSON() {
        return {
          numDimensions: this._numDimensions,
          indices: this._indices,
          values: this._values
        };
      }
      // It always constructs a typedArray.
      _createEmptyArray(input, len) {
        if (Array.isArray(input)) {
          return new Float64Array(len);
        } else {
          return new input.constructor(len);
        }
      }
      // Convert sparse vector to a dense vector
      // It returns typed array.
      dense() {
        if (this._numDimensions === 0) {
          return null;
        }
        const dense = this._createEmptyArray(this._values, this._numDimensions);
        this._indices.forEach((index, i) => {
          dense[index] = this._values[i];
        });
        return dense;
      }
    };
    var IntervalYM = class {
      constructor(obj) {
        if (obj) {
          errors.assertParamPropInt(obj, 1, "years");
          errors.assertParamPropInt(obj, 1, "months");
        }
        this.months = obj?.months || 0;
        this.years = obj?.years || 0;
      }
    };
    var IntervalDS = class {
      constructor(obj) {
        if (obj) {
          errors.assertParamPropInt(obj, 1, "days");
          errors.assertParamPropInt(obj, 1, "hours");
          errors.assertParamPropInt(obj, 1, "minutes");
          errors.assertParamPropInt(obj, 1, "seconds");
          errors.assertParamPropInt(obj, 1, "fseconds");
        }
        this.fseconds = obj?.fseconds || 0;
        this.seconds = obj?.seconds || 0;
        this.minutes = obj?.minutes || 0;
        this.hours = obj?.hours || 0;
        this.days = obj?.days || 0;
      }
    };
    module2.exports = {
      DbType,
      DB_TYPE_BFILE,
      DB_TYPE_BINARY_DOUBLE,
      DB_TYPE_BINARY_FLOAT,
      DB_TYPE_BINARY_INTEGER,
      DB_TYPE_BLOB,
      DB_TYPE_BOOLEAN,
      DB_TYPE_CHAR,
      DB_TYPE_CLOB,
      DB_TYPE_CURSOR,
      DB_TYPE_DATE,
      DB_TYPE_INTERVAL_DS,
      DB_TYPE_INTERVAL_YM,
      DB_TYPE_JSON,
      DB_TYPE_LONG,
      DB_TYPE_LONG_NVARCHAR,
      DB_TYPE_LONG_RAW,
      DB_TYPE_NCHAR,
      DB_TYPE_NCLOB,
      DB_TYPE_NUMBER,
      DB_TYPE_NVARCHAR,
      DB_TYPE_OBJECT,
      DB_TYPE_RAW,
      DB_TYPE_ROWID,
      DB_TYPE_TIMESTAMP,
      DB_TYPE_TIMESTAMP_LTZ,
      DB_TYPE_TIMESTAMP_TZ,
      DB_TYPE_UROWID,
      DB_TYPE_VARCHAR,
      DB_TYPE_VECTOR,
      DB_TYPE_CONVERSION_MAP,
      DB_TYPE_FETCH_TYPE_MAP,
      DB_TYPE_XMLTYPE,
      getTypeByColumnTypeName,
      getTypeByNum,
      getTypeByOraTypeNum,
      JsonId,
      SparseVector,
      IntervalYM,
      IntervalDS
    };
  }
});

// node_modules/oracledb/lib/impl/datahandlers/constants.js
var require_constants2 = __commonJS({
  "node_modules/oracledb/lib/impl/datahandlers/constants.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    module2.exports = {
      // vector constants
      TNS_VECTOR_MAGIC_BYTE: 219,
      TNS_VECTOR_VERSION_BASE: 0,
      TNS_VECTOR_VERSION_WITH_BINARY: 1,
      TNS_VECTOR_VERSION_WITH_SPARSE: 2,
      // vector flags
      TNS_VECTOR_FLAG_NORMSRC: 16,
      TNS_VECTOR_FLAG_NORM: 2,
      TNS_VECTOR_FLAG_SPARSE: 32,
      // base JSON constants
      TNS_JSON_MAGIC_BYTE_1: 255,
      TNS_JSON_MAGIC_BYTE_2: 74,
      // 'J'
      TNS_JSON_MAGIC_BYTE_3: 90,
      // 'Z'
      TNS_JSON_VERSION_MAX_FNAME_255: 1,
      TNS_JSON_VERSION_MAX_FNAME_65535: 3,
      TNS_JSON_FLAG_HASH_ID_UINT8: 256,
      TNS_JSON_FLAG_HASH_ID_UINT16: 512,
      TNS_JSON_FLAG_NUM_FNAMES_UINT16: 1024,
      TNS_JSON_FLAG_FNAMES_SEG_UINT32: 2048,
      TNS_JSON_FLAG_TINY_NODES_STAT: 8192,
      TNS_JSON_FLAG_TREE_SEG_UINT32: 4096,
      TNS_JSON_FLAG_REL_OFFSET_MODE: 1,
      TNS_JSON_FLAG_INLINE_LEAF: 2,
      TNS_JSON_FLAG_LEN_IN_PCODE: 4,
      TNS_JSON_FLAG_NUM_FNAMES_UINT32: 8,
      TNS_JSON_FLAG_IS_SCALAR: 16,
      TNS_JSON_FLAG_SEC_FNAMES_SEG_UINT16: 256,
      // JSON data types
      TNS_JSON_TYPE_NULL: 48,
      TNS_JSON_TYPE_TRUE: 49,
      TNS_JSON_TYPE_FALSE: 50,
      TNS_JSON_TYPE_STRING_LENGTH_UINT8: 51,
      TNS_JSON_TYPE_NUMBER_LENGTH_UINT8: 52,
      TNS_JSON_TYPE_BINARY_DOUBLE: 54,
      TNS_JSON_TYPE_STRING_LENGTH_UINT16: 55,
      TNS_JSON_TYPE_STRING_LENGTH_UINT32: 56,
      TNS_JSON_TYPE_TIMESTAMP: 57,
      TNS_JSON_TYPE_BINARY_LENGTH_UINT16: 58,
      TNS_JSON_TYPE_BINARY_LENGTH_UINT32: 59,
      TNS_JSON_TYPE_DATE: 60,
      TNS_JSON_TYPE_INTERVAL_YM: 61,
      TNS_JSON_TYPE_INTERVAL_DS: 62,
      TNS_JSON_TYPE_TIMESTAMP_TZ: 124,
      TNS_JSON_TYPE_TIMESTAMP7: 125,
      TNS_JSON_TYPE_BINARY_FLOAT: 127,
      TNS_JSON_TYPE_OBJECT: 132,
      TNS_JSON_TYPE_ARRAY: 192,
      TNS_JSON_TYPE_EXTENDED: 123,
      TNS_JSON_TYPE_VECTOR: 1,
      TNS_JSON_TYPE_ID: 126,
      // timezone offsets
      TZ_HOUR_OFFSET: 20,
      TZ_MINUTE_OFFSET: 60,
      // general constants
      TNS_MAX_SHORT_LENGTH: 252,
      TNS_DURATION_MID: 2147483648,
      TNS_DURATION_OFFSET: 60,
      TNS_CHUNK_SIZE: 32767,
      TNS_HAS_REGION_ID: 128,
      NUMBER_MAX_DIGITS: 40,
      BUFFER_CHUNK_SIZE: 65536,
      CSFRM_IMPLICIT: constants.CSFRM_IMPLICIT,
      // vector generic constants
      VECTOR_FORMAT_FLOAT32: constants.VECTOR_FORMAT_FLOAT32,
      VECTOR_FORMAT_FLOAT64: constants.VECTOR_FORMAT_FLOAT64,
      VECTOR_FORMAT_INT8: constants.VECTOR_FORMAT_INT8,
      VECTOR_FORMAT_BINARY: constants.VECTOR_FORMAT_BINARY,
      TNS_NULL_LENGTH_INDICATOR: 255,
      TNS_LONG_LENGTH_INDICATOR: 254
    };
  }
});

// node_modules/oracledb/lib/impl/datahandlers/buffer.js
var require_buffer = __commonJS({
  "node_modules/oracledb/lib/impl/datahandlers/buffer.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants2();
    var errors = require_errors();
    var types = require_types();
    var nodbUtil = require_util();
    var BaseBuffer = class {
      //---------------------------------------------------------------------------
      // constructor()
      //
      // The initializer is either an integer specifying the size of the buffer, or
      // an existing Buffer, which is used directly.
      //---------------------------------------------------------------------------
      constructor(initializer) {
        if (typeof initializer === "number") {
          this.buf = Buffer2.alloc(initializer);
          this.size = 0;
          this.maxSize = initializer;
        } else if (initializer) {
          this.buf = initializer;
          this.size = this.maxSize = initializer.length;
        }
        this.pos = 0;
      }
      //---------------------------------------------------------------------------
      // _grow()
      //
      // Called when the buffer needs to grow. The base function simply raises an
      // error.
      //---------------------------------------------------------------------------
      _grow(numBytes) {
        errors.throwErr(
          errors.ERR_BUFFER_LENGTH_INSUFFICIENT,
          this.numBytesLeft(),
          numBytes
        );
      }
      //---------------------------------------------------------------------------
      // _readBytesWithLength()
      //
      // Helper function that processes the number of bytes (if needed) and then
      // acquires the specified number of bytes from the buffer. The base function
      // simply uses the length as given.
      //---------------------------------------------------------------------------
      _readBytesWithLength(numBytes) {
        return this.readBytes(numBytes);
      }
      //---------------------------------------------------------------------------
      // _readInteger()
      //
      // Read an integer from the buffer of the specified maximum size and returns
      // it. The signed flag indicates whether the value is allowed to be signed or
      // not and the skip flag indicates whether the data should simply be skipped.
      //---------------------------------------------------------------------------
      _readInteger(maxSize, signed, skip) {
        let isNegative = false;
        let size = this.readUInt8();
        if (size === 0) {
          return 0;
        } else if (size & 128) {
          if (!signed) {
            errors.throwErr(errors.ERR_UNEXPECTED_NEGATIVE_INTEGER, this.pos, this.packetNum);
          }
          isNegative = true;
          size = size & 127;
        }
        if (size > maxSize) {
          errors.throwErr(errors.ERR_INTEGER_TOO_LARGE, size, maxSize, this.pos, this.packetNum);
        }
        if (skip) {
          this.skipBytes(size);
        } else {
          const buf = this.readBytes(size);
          const value = buf.readUIntBE(0, size);
          return isNegative ? -value : value;
        }
      }
      //---------------------------------------------------------------------------
      // numBytesLeft()
      //
      // Returns the number of bytes that are remaining in the buffer.
      //---------------------------------------------------------------------------
      numBytesLeft() {
        return this.size - this.pos;
      }
      //---------------------------------------------------------------------------
      // parseBinaryDouble()
      //
      // Parses a binary double from the supplied buffer and returns a Number.
      // It is assumed at this point that the size of the buffer is 8 bytes. A copy
      // is made of the buffer in order to ensure that the original buffer is not
      // modified. If it is and data spans multiple packets, incorrect data may be
      // returned!
      //---------------------------------------------------------------------------
      parseBinaryDouble(buf) {
        buf = Buffer2.from(buf);
        if (buf[0] & 128) {
          buf[0] &= 127;
        } else {
          buf[0] ^= 255;
          buf[1] ^= 255;
          buf[2] ^= 255;
          buf[3] ^= 255;
          buf[4] ^= 255;
          buf[5] ^= 255;
          buf[6] ^= 255;
          buf[7] ^= 255;
        }
        return buf.readDoubleBE();
      }
      //---------------------------------------------------------------------------
      // parseBinaryFloat()
      //
      // Parses a binary float from the supplied buffer and returns a Number.  It
      // is assumed at this point that the size of the buffer is 4 bytes. A copy is
      // made of the buffer in order to ensure that the original buffer is not
      // modified. If it is and data spans multiple packets, incorrect data may be
      // returned!
      //---------------------------------------------------------------------------
      parseBinaryFloat(buf) {
        buf = Buffer2.from(buf);
        if (buf[0] & 128) {
          buf[0] &= 127;
        } else {
          buf[0] ^= 255;
          buf[1] ^= 255;
          buf[2] ^= 255;
          buf[3] ^= 255;
        }
        return buf.readFloatBE();
      }
      //---------------------------------------------------------------------------
      // parseOracleDate()
      //
      // Parses an Oracle date from the supplied buffer and returns a Date. It is
      // assumed at this point that the size of the buffer is either 7 bytes (date
      // or compressed timestamp), 11 bytes (timestamp) or 13 bytes (timestamp with
      // time zone). Time zone information is discarded because Node.js uses UTC
      // timestamps and the server returns the data in that format, too. The Date
      // type in Node.js doesn't support time zone information.
      //---------------------------------------------------------------------------
      parseOracleDate(buf, useLocalTime = true) {
        let fseconds = 0;
        if (buf.length >= 11) {
          fseconds = Math.floor(buf.readUInt32BE(7) / (1e3 * 1e3));
        }
        const year = (buf[0] - 100) * 100 + buf[1] - 100;
        return nodbUtil.makeDate(
          useLocalTime,
          year,
          buf[2],
          buf[3],
          buf[4] - 1,
          buf[5] - 1,
          buf[6] - 1,
          fseconds,
          0
        );
      }
      //---------------------------------------------------------------------------
      // parseOracleIntervalYM()
      //
      // Parses an Oracle interval year-to-month (YM) from the supplied buffer
      // and returns a corresponding IntervalYM object representing that value.
      // This object contains attributes for years and months.
      //---------------------------------------------------------------------------
      parseOracleIntervalYM(buf) {
        const years = buf.readUInt32BE() - constants.TNS_DURATION_MID;
        const months = buf[4] - constants.TNS_DURATION_OFFSET;
        return new types.IntervalYM({ years, months });
      }
      //---------------------------------------------------------------------------
      // parseOracleIntervalDS()
      //
      // Parses an Oracle interval day-to-second (DS) from the supplied buffer
      // and returns a corresponding IntervalDS object representing that value.
      // This object contains attributes for day and time units.
      //---------------------------------------------------------------------------
      parseOracleIntervalDS(buf) {
        const days = buf.readUInt32BE() - constants.TNS_DURATION_MID;
        const fseconds = buf.readUInt32BE(7) - constants.TNS_DURATION_MID;
        const hours = buf[4] - constants.TNS_DURATION_OFFSET;
        const minutes = buf[5] - constants.TNS_DURATION_OFFSET;
        const seconds = buf[6] - constants.TNS_DURATION_OFFSET;
        return new types.IntervalDS({
          days,
          hours,
          minutes,
          seconds,
          fseconds
        });
      }
      //---------------------------------------------------------------------------
      // parseOracleNumber()
      //
      // Parses an Oracle number from the supplied buffer and returns a Number. It
      // is assumed at this point that the buffer only contains the encoded numeric
      // data.
      //---------------------------------------------------------------------------
      parseOracleNumber(buf) {
        let exponent = buf[0];
        const isPositive = Boolean(exponent & 128);
        if (!isPositive) {
          exponent = exponent ^ 255;
        }
        exponent -= 193;
        let decimalPointIndex = exponent * 2 + 2;
        if (buf.length === 1) {
          if (isPositive) {
            return "0";
          }
          return "-1e126";
        }
        let numBytes = buf.length;
        if (!isPositive && buf[buf.length - 1] === 102) {
          numBytes -= 1;
        }
        let base100Digit;
        const digits = [];
        for (let i = 1; i < numBytes; i++) {
          if (isPositive) {
            base100Digit = buf[i] - 1;
          } else {
            base100Digit = 101 - buf[i];
          }
          let digit = Math.floor(base100Digit / 10);
          if (digit === 0 && i === 1) {
            decimalPointIndex -= 1;
          } else if (digit === 10) {
            digits.push("1");
            digits.push("0");
            decimalPointIndex += 1;
          } else if (digit !== 0 || i > 1) {
            digits.push(digit.toString());
          }
          digit = base100Digit % 10;
          if (digit !== 0 || i < numBytes - 1) {
            digits.push(digit.toString());
          }
        }
        const chars = [];
        if (!isPositive) {
          chars.push("-");
        }
        if (decimalPointIndex <= 0) {
          chars.push(".");
          if (decimalPointIndex < 0)
            chars.push("0".repeat(-decimalPointIndex));
        }
        for (let i = 0; i < digits.length; i++) {
          if (i > 0 && i === decimalPointIndex) {
            chars.push(".");
          }
          chars.push(digits[i]);
        }
        if (decimalPointIndex > digits.length) {
          for (let i = digits.length; i < decimalPointIndex; i++) {
            chars.push("0");
          }
        }
        return chars.join("");
      }
      //---------------------------------------------------------------------------
      // readBinaryDouble()
      //
      // Reads a binary double value from the buffer and returns a Number or a
      // String, depending on the desired type.
      //---------------------------------------------------------------------------
      readBinaryDouble() {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return null;
        }
        return this.parseBinaryDouble(buf);
      }
      //---------------------------------------------------------------------------
      // readBinaryFloat()
      //
      // Reads a binary float value from the buffer and returns a Number or a
      // String, depending on the desired type.
      //---------------------------------------------------------------------------
      readBinaryFloat() {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return null;
        }
        return this.parseBinaryFloat(buf);
      }
      //---------------------------------------------------------------------------
      // readBinaryInteger()
      //
      // Reads a binary integer value from the buffer and returns a Number
      //---------------------------------------------------------------------------
      readBinaryInteger() {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return 0;
        }
        if (buf.length > 4) {
          errors.throwErr(errors.ERR_INTEGER_TOO_LARGE, buf.length, 4, this.pos, this.packetNum);
        }
        return buf.readIntBE(0, buf.length);
      }
      //---------------------------------------------------------------------------
      // readBool()
      //
      // Reads a boolean value from the buffer and returns a Boolean.
      //---------------------------------------------------------------------------
      readBool() {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return null;
        }
        return buf[buf.length - 1] === 1;
      }
      //---------------------------------------------------------------------------
      // readBytes()
      //
      // Returns a Buffer containing the specified number of bytes. If an
      // insufficient number of bytes are available an error is thrown.
      //---------------------------------------------------------------------------
      readBytes(numBytes) {
        const numBytesLeft = this.numBytesLeft();
        if (numBytes > numBytesLeft) {
          errors.throwErr(
            errors.ERR_UNEXPECTED_END_OF_DATA,
            numBytes,
            numBytesLeft
          );
        }
        const buf = this.buf.subarray(this.pos, this.pos + numBytes);
        this.pos += numBytes;
        return buf;
      }
      //---------------------------------------------------------------------------
      // readBytesAndLength()
      //
      // Reads the UB4 length from the buffer and then returns a Buffer containing
      // the specified number of bytes.
      //---------------------------------------------------------------------------
      readBytesAndLength() {
        const numBytes = this.readUB4();
        if (numBytes > 0)
          return this.readBytesWithLength();
      }
      //---------------------------------------------------------------------------
      // readBytesWithLength()
      //
      // Reads the length from the buffer and then returns a Buffer containing the
      // specified number of bytes. If the length is 0 or the special null length
      // indicator value, null is returned instead.
      //---------------------------------------------------------------------------
      readBytesWithLength() {
        const numBytes = this.readUInt8();
        if (numBytes === 0 || numBytes === constants.TNS_NULL_LENGTH_INDICATOR)
          return null;
        return this._readBytesWithLength(numBytes);
      }
      //---------------------------------------------------------------------------
      // readDbObject()
      //
      // Reads a database object from the buffer and returns the implementation
      // object (or null, if the object is atomically null).
      //---------------------------------------------------------------------------
      readDbObject() {
        const obj = {};
        let numBytes = this.readUB4();
        if (numBytes > 0)
          obj.toid = Buffer2.from(this.readBytesWithLength());
        numBytes = this.readUB4();
        if (numBytes > 0)
          obj.oid = Buffer2.from(this.readBytesWithLength());
        numBytes = this.readUB4();
        if (numBytes > 0)
          obj.snapshot = Buffer2.from(this.readBytesWithLength());
        this.skipUB2();
        numBytes = this.readUB4();
        this.skipUB2();
        if (numBytes > 0)
          obj.packedData = Buffer2.from(this.readBytesWithLength());
        return obj;
      }
      //---------------------------------------------------------------------------
      // readInt8()
      //
      // Reads a signed 8-bit integer from the buffer.
      //---------------------------------------------------------------------------
      readInt8() {
        const buf = this.readBytes(1);
        return buf.readInt8();
      }
      //---------------------------------------------------------------------------
      // readOracleDate()
      //
      // Reads an Oracle date from the buffer and returns a Date or a String,
      // depending on the desired type.
      //---------------------------------------------------------------------------
      readOracleDate(useLocalTime) {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return null;
        }
        return this.parseOracleDate(buf, useLocalTime);
      }
      //---------------------------------------------------------------------------
      // readOracleIntervalYM()
      //
      // Reads interval year to month value from the buffer and returns a
      // JavaScript object representing that value.
      //---------------------------------------------------------------------------
      readOracleIntervalYM() {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return null;
        }
        return this.parseOracleIntervalYM(buf);
      }
      //---------------------------------------------------------------------------
      // readOracleIntervalDS()
      //
      // Reads interval day to second value from the buffer and returns a
      // JavaScript object representing that value.
      //---------------------------------------------------------------------------
      readOracleIntervalDS() {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return null;
        }
        return this.parseOracleIntervalDS(buf);
      }
      //---------------------------------------------------------------------------
      // readOracleNumber()
      //
      // Reads an Oracle number from the buffer and returns a Number or a String,
      // depending on the desired type.
      //---------------------------------------------------------------------------
      readOracleNumber() {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return null;
        }
        return this.parseOracleNumber(buf);
      }
      //---------------------------------------------------------------------------
      // readSB2()
      //
      // Reads a signed, variable length integer of up to 2 bytes in length.
      //---------------------------------------------------------------------------
      readSB2() {
        return this._readInteger(2, true, false);
      }
      //---------------------------------------------------------------------------
      // readSB4()
      //
      // Reads a signed, variable length integer of up to 4 bytes in length.
      //---------------------------------------------------------------------------
      readSB4() {
        return this._readInteger(4, true, false);
      }
      //---------------------------------------------------------------------------
      // readSB8()
      //
      // Reads a signed, variable length integer of up to 8 bytes in length.
      //---------------------------------------------------------------------------
      readSB8() {
        return this._readInteger(8, true, false);
      }
      //---------------------------------------------------------------------------
      // readStr()
      //
      // Reads a string from the buffer in the specified character set form.
      //---------------------------------------------------------------------------
      readStr(csfrm) {
        const buf = this.readBytesWithLength();
        if (!buf) {
          return null;
        }
        if (csfrm === constants.CSFRM_IMPLICIT)
          return buf.toString();
        return Buffer2.from(buf).swap16().toString("utf16le");
      }
      //---------------------------------------------------------------------------
      // readStrAndLength()
      //
      // Reads a length from the buffer and then, if the length is non-zero, reads
      // string from the buffer and returns it.
      //---------------------------------------------------------------------------
      readStrAndLength() {
        const buf = this.readBytesAndLength();
        return buf ? buf.toString() : null;
      }
      //---------------------------------------------------------------------------
      // readUB2()
      //
      // Reads an unsigned, variable length integer of up to 2 bytes in length.
      //---------------------------------------------------------------------------
      readUB2() {
        return this._readInteger(2, false, false);
      }
      //---------------------------------------------------------------------------
      // readUB4()
      //
      // Reads an unsigned, variable length integer of up to 4 bytes in length.
      //---------------------------------------------------------------------------
      readUB4() {
        return this._readInteger(4, false, false);
      }
      //---------------------------------------------------------------------------
      // readUB8()
      //
      // Reads an unsigned, variable length integer of up to 8 bytes in length.
      //---------------------------------------------------------------------------
      readUB8() {
        return this._readInteger(8, false, false);
      }
      //---------------------------------------------------------------------------
      // readUInt8()
      //
      // Reads an unsigned 8-bit integer from the buffer.
      //---------------------------------------------------------------------------
      readUInt8() {
        const buf = this.readBytes(1);
        return buf[0];
      }
      //---------------------------------------------------------------------------
      // readUInt16BE()
      //
      // Reads an unsigned 16-bit integer from the buffer in big endian order.
      //---------------------------------------------------------------------------
      readUInt16BE() {
        const buf = this.readBytes(2);
        return buf.readUInt16BE();
      }
      //---------------------------------------------------------------------------
      // readUInt16LE()
      //
      // Reads an unsigned 16-bit integer from the buffer in little endian order.
      //---------------------------------------------------------------------------
      readUInt16LE() {
        const buf = this.readBytes(2);
        return buf.readUInt16LE();
      }
      //---------------------------------------------------------------------------
      // readUInt32BE()
      //
      // Reads an unsigned 32-bit integer from the buffer in big endian order.
      //---------------------------------------------------------------------------
      readUInt32BE() {
        const buf = this.readBytes(4);
        return buf.readUInt32BE();
      }
      //---------------------------------------------------------------------------
      // reserveBytes()
      //
      // Reserves the specified number of bytes in the buffer. If not enough bytes
      // remain in the buffer, the buffer is grown.
      //---------------------------------------------------------------------------
      reserveBytes(numBytes) {
        if (numBytes > this.numBytesLeft()) {
          this._grow(this.pos + numBytes);
        }
        const pos = this.pos;
        this.pos += numBytes;
        return pos;
      }
      //---------------------------------------------------------------------------
      // skipBytes()
      //
      // Skips the specified number of bytes in the buffer.
      //---------------------------------------------------------------------------
      skipBytes(numBytes) {
        if (numBytes > this.numBytesLeft())
          errors.throwErr(errors.ERR_UNEXPECTED_END_OF_DATA);
        this.pos += numBytes;
      }
      //---------------------------------------------------------------------------
      // skipSB4()
      //
      // Skips a signed, variable length integer of up to 4 bytes in length.
      //---------------------------------------------------------------------------
      skipSB4() {
        return this._readInteger(4, true, true);
      }
      //---------------------------------------------------------------------------
      // skipUB1()
      //
      // Skips a single byte integer in the buffer.
      //---------------------------------------------------------------------------
      skipUB1() {
        this.skipBytes(1);
      }
      //---------------------------------------------------------------------------
      // skipUB2()
      //
      // Skips an unsigned, variable length integer of up to 2 bytes in length.
      //---------------------------------------------------------------------------
      skipUB2() {
        return this._readInteger(2, false, true);
      }
      //---------------------------------------------------------------------------
      // skipUB4()
      //
      // Skips an unsigned, variable length integer of up to 4 bytes in length.
      //---------------------------------------------------------------------------
      skipUB4() {
        return this._readInteger(4, false, true);
      }
      //---------------------------------------------------------------------------
      // skipUB8()
      //
      // Skips an unsigned, variable length integer of up to 8 bytes in length.
      //---------------------------------------------------------------------------
      skipUB8() {
        return this._readInteger(8, false, true);
      }
      //---------------------------------------------------------------------------
      // writeBinaryDouble()
      //
      // Writes the number in binary double format to the buffer.
      //---------------------------------------------------------------------------
      writeBinaryDouble(n, pos) {
        if (!pos) {
          pos = this.reserveBytes(8);
        }
        this.buf.writeDoubleBE(n, pos);
        if ((this.buf[pos] & 128) === 0) {
          this.buf[pos] |= 128;
        } else {
          this.buf[pos] ^= 255;
          this.buf[pos + 1] ^= 255;
          this.buf[pos + 2] ^= 255;
          this.buf[pos + 3] ^= 255;
          this.buf[pos + 4] ^= 255;
          this.buf[pos + 5] ^= 255;
          this.buf[pos + 6] ^= 255;
          this.buf[pos + 7] ^= 255;
        }
      }
      //---------------------------------------------------------------------------
      // writeBinaryFloat()
      //
      // Writes the number in binary float format to the buffer.
      //---------------------------------------------------------------------------
      writeBinaryFloat(n, pos) {
        if (!pos) {
          pos = this.reserveBytes(4);
        }
        this.buf.writeFloatBE(n, pos);
        if ((this.buf[pos] & 128) === 0) {
          this.buf[pos] |= 128;
        } else {
          this.buf[pos] ^= 255;
          this.buf[pos + 1] ^= 255;
          this.buf[pos + 2] ^= 255;
          this.buf[pos + 3] ^= 255;
        }
      }
      //---------------------------------------------------------------------------
      // writeBytes()
      //
      // Writes the bytes in the supplied buffer to the buffer.
      //---------------------------------------------------------------------------
      writeBytes(value) {
        let start = 0;
        let valueLen = value.length;
        while (valueLen > 0) {
          const bytesLeft = this.numBytesLeft();
          if (bytesLeft === 0) {
            this._grow(this.pos + valueLen);
          }
          const bytesToWrite = Math.min(bytesLeft, valueLen);
          value.copy(this.buf, this.pos, start, start + bytesToWrite);
          this.pos += bytesToWrite;
          start += bytesToWrite;
          valueLen -= bytesToWrite;
        }
      }
      // _writeRawBytesAndLength()
      //
      // Writes the length in the format required before
      // writing the bytes.
      //---------------------------------------------------------------------------
      _writeRawBytesAndLength(value, numBytes) {
        if (numBytes <= constants.TNS_MAX_SHORT_LENGTH) {
          this.writeUInt8(numBytes);
          if (numBytes > 0) {
            this.writeBytes(value);
          }
        } else {
          let start = 0;
          this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);
          while (numBytes > 0) {
            const chunkLen = Math.min(numBytes, constants.BUFFER_CHUNK_SIZE);
            this.writeUB4(chunkLen);
            this.writeBytes(value.subarray(start, start + chunkLen));
            numBytes -= chunkLen;
            start += chunkLen;
          }
          this.writeUB4(0);
        }
      }
      //---------------------------------------------------------------------------
      // writeBytesWithLength()
      //
      // Writes the bytes in the supplied buffer to the buffer, but first writes
      // the length. If the length exceeds a fixed value, the value is written in
      // chunks instead.
      //---------------------------------------------------------------------------
      writeBytesWithLength(value) {
        const numBytes = value.length;
        this._writeRawBytesAndLength(value, numBytes);
      }
      //---------------------------------------------------------------------------
      // writeDbObject()
      //
      // Writes a database object to the buffer.
      //---------------------------------------------------------------------------
      writeDbObject(obj) {
        this.writeUB4(obj.toid.length);
        this.writeBytesWithLength(obj.toid);
        if (obj.oid) {
          this.writeUB4(obj.oid.length);
          this.writeBytesWithLength(obj.oid);
        } else {
          this.writeUB4(0);
        }
        this.writeUB4(0);
        this.writeUB4(0);
        const packedData = obj._getPackedData();
        this.writeUB4(packedData.length);
        this.writeUB4(obj.flags);
        this.writeBytesWithLength(packedData);
      }
      //---------------------------------------------------------------------------
      // writeOracleDate()
      //
      // Writes the date to the buffer using the given Oracle type. Note that if a
      // timestamp with zero milliseconds is written, the type is automatically
      // changed to DB_TYPE_DATE (except for DB_TYPE_TIMESTAMP_TZ which requires
      // the full amount to be written).
      //---------------------------------------------------------------------------
      writeOracleDate(date, type, writeLength = true) {
        let fsec;
        let length = type._bufferSizeFactor;
        if (length > 7) {
          fsec = date.getUTCMilliseconds() * 1e3 * 1e3;
          if (fsec === 0 && length <= 11)
            length = 7;
        }
        if (writeLength) {
          this.writeUInt8(length);
        }
        const pos = this.reserveBytes(length);
        if (type === types.DB_TYPE_DATE || type == types.DB_TYPE_TIMESTAMP) {
          const year = date.getFullYear();
          this.buf[pos] = Math.trunc(year / 100) + 100;
          this.buf[pos + 1] = year % 100 + 100;
          this.buf[pos + 2] = date.getMonth() + 1;
          this.buf[pos + 3] = date.getDate();
          this.buf[pos + 4] = date.getHours() + 1;
          this.buf[pos + 5] = date.getMinutes() + 1;
          this.buf[pos + 6] = date.getSeconds() + 1;
        } else {
          const year = date.getUTCFullYear();
          this.buf[pos] = Math.trunc(year / 100) + 100;
          this.buf[pos + 1] = year % 100 + 100;
          this.buf[pos + 2] = date.getUTCMonth() + 1;
          this.buf[pos + 3] = date.getUTCDate();
          this.buf[pos + 4] = date.getUTCHours() + 1;
          this.buf[pos + 5] = date.getUTCMinutes() + 1;
          this.buf[pos + 6] = date.getUTCSeconds() + 1;
        }
        if (length > 7) {
          this.buf.writeInt32BE(fsec, pos + 7);
          if (length > 11) {
            this.buf[pos + 11] = constants.TZ_HOUR_OFFSET;
            this.buf[pos + 12] = constants.TZ_MINUTE_OFFSET;
          }
        }
      }
      //---------------------------------------------------------------------------
      // writeOracleIntervalYM()
      //
      // Writes a time interval to the buffer in Oracle Interval Year To Month
      // format. It is assumed that the 'value' parameter is a valid IntervalYM
      // object at this stage.
      //---------------------------------------------------------------------------
      writeOracleIntervalYM(value, writeLength = true) {
        if (writeLength) {
          this.writeUInt8(5);
        }
        this.writeUInt32BE(value.years + constants.TNS_DURATION_MID);
        this.writeUInt8(value.months + constants.TNS_DURATION_OFFSET);
      }
      //---------------------------------------------------------------------------
      // writeOracleIntervalDS()
      //
      // Writes a time interval to the buffer in Oracle Interval Day To Second
      // format. It is assumed that the 'value' parameter is a valid IntervalDS
      // object at this stage.
      //---------------------------------------------------------------------------
      writeOracleIntervalDS(value, writeLength = true) {
        if (writeLength) {
          this.writeUInt8(11);
        }
        this.writeUInt32BE(value.days + constants.TNS_DURATION_MID);
        this.writeUInt8(value.hours + constants.TNS_DURATION_OFFSET);
        this.writeUInt8(value.minutes + constants.TNS_DURATION_OFFSET);
        this.writeUInt8(value.seconds + constants.TNS_DURATION_OFFSET);
        this.writeUInt32BE(value.fseconds + constants.TNS_DURATION_MID);
      }
      //---------------------------------------------------------------------------
      // writeOracleNumber()
      //
      // Writes the number (in string form) in Oracle Number format to the buffer.
      //---------------------------------------------------------------------------
      writeOracleNumber(value) {
        let isNegative = false;
        if (value[0] === "-") {
          isNegative = true;
          value = value.substring(1);
        }
        let exponent = 0;
        const exponentPos = value.indexOf("e");
        if (exponentPos > 0) {
          exponent = Number(value.substring(exponentPos + 1));
          value = value.substring(0, exponentPos);
        }
        const decimalPos = value.indexOf(".");
        if (decimalPos > 0) {
          exponent -= value.length - decimalPos - 1;
          value = value.substring(0, decimalPos) + value.substring(decimalPos + 1);
        }
        if (value[0] === "0") {
          value = value.replace(/^0+/, "");
        }
        if (value.length > 0 && value[value.length - 1] === "0") {
          const trimmedValue = value.replace(/0+$/, "");
          exponent += value.length - trimmedValue.length;
          value = trimmedValue;
        }
        if (value.length > constants.NUMBER_MAX_DIGITS || exponent >= 126 || exponent <= -131) {
          errors.throwErr(errors.ERR_ORACLE_NUMBER_NO_REPR);
        }
        if (exponent > 0 && exponent % 2 === 1 || exponent < 0 && exponent % 2 === -1) {
          exponent--;
          value += "0";
        }
        if (value.length % 2 === 1) {
          value = "0" + value;
        }
        const appendSentinel = isNegative && value.length < constants.NUMBER_MAX_DIGITS;
        const numPairs = value.length / 2;
        let exponentOnWire = (exponent + value.length) / 2 + 192;
        if (isNegative) {
          exponentOnWire = exponentOnWire ^ 255;
        } else if (value.length === 0 && exponent === 0) {
          exponentOnWire = 128;
        }
        let pos = this.reserveBytes(numPairs + 2 + appendSentinel);
        this.buf[pos++] = numPairs + 1 + appendSentinel;
        this.buf[pos++] = exponentOnWire;
        for (let i = 0; i < value.length; i += 2) {
          const base100Digit = Number(value.substring(i, i + 2));
          if (isNegative) {
            this.buf[pos++] = 101 - base100Digit;
          } else {
            this.buf[pos++] = base100Digit + 1;
          }
        }
        if (appendSentinel) {
          this.buf[pos] = 102;
        }
      }
      //---------------------------------------------------------------------------
      // writeStr()
      //
      // Writes the string to the buffer.
      //---------------------------------------------------------------------------
      writeStr(s) {
        this.writeBytes(Buffer2.from(s));
      }
      //---------------------------------------------------------------------------
      // writeInt32BE()
      //
      // Writes a signed 32-bit integer to the buffer in big endian order.
      //---------------------------------------------------------------------------
      writeInt32BE(n) {
        const pos = this.reserveBytes(4);
        this.buf.writeInt32BE(n, pos);
      }
      //---------------------------------------------------------------------------
      // writeSB4()
      //
      // Writes a signed integer (up to 4 bytes in length) in variable length
      // format to the buffer.
      //---------------------------------------------------------------------------
      writeSB4(value) {
        let sign = 0;
        if (value < 0) {
          value = -value;
          sign = 128;
        }
        if (value === 0) {
          this.writeUInt8(0);
        } else if (value <= 255) {
          this.writeUInt8(1 | sign);
          this.writeUInt8(value);
        } else if (value <= 65535) {
          this.writeUInt8(2 | sign);
          this.writeUInt16BE(value);
        } else {
          this.writeUInt8(4 | sign);
          this.writeUInt32BE(value);
        }
      }
      //---------------------------------------------------------------------------
      // writeUB4()
      //
      // Writes an unsigned integer (up to 4 bytes in length) in variable length
      // format to the buffer.
      //---------------------------------------------------------------------------
      writeUB4(value) {
        if (value === 0) {
          this.writeUInt8(0);
        } else if (value <= 255) {
          this.writeUInt8(1);
          this.writeUInt8(value);
        } else if (value <= 65535) {
          this.writeUInt8(2);
          this.writeUInt16BE(value);
        } else {
          this.writeUInt8(4);
          this.writeUInt32BE(value);
        }
      }
      //---------------------------------------------------------------------------
      // writeUB2()
      //
      // Writes an unsigned integer (up to 2 bytes in length) in variable length
      // format to the buffer.
      //---------------------------------------------------------------------------
      writeUB2(value) {
        if (value === 0) {
          this.writeUInt8(0);
        } else if (value <= 255) {
          this.writeUInt8(1);
          this.writeUInt8(value);
        } else {
          this.writeUInt8(2);
          this.writeUInt16BE(value);
        }
      }
      //---------------------------------------------------------------------------
      // writeUB8()
      //
      // Writes an unsigned integer (up to 8 bytes in length) in variable length
      // format to the buffer.
      //---------------------------------------------------------------------------
      writeUB8(value) {
        if (value === 0) {
          this.writeUInt8(0);
        } else if (value <= 255) {
          this.writeUInt8(1);
          this.writeUInt8(value);
        } else if (value <= 65535) {
          this.writeUInt8(2);
          this.writeUInt16BE(value);
        } else if (value <= 4294967295) {
          this.writeUInt8(4);
          this.writeUInt32BE(value);
        } else {
          this.writeUInt8(8);
          this.writeUInt64BE(value);
        }
      }
      //---------------------------------------------------------------------------
      // writeUInt8()
      //
      // Writes an unsigned 8-bit integer to the buffer.
      //---------------------------------------------------------------------------
      writeUInt8(n) {
        const pos = this.reserveBytes(1);
        this.buf[pos] = n;
      }
      // writeSB1()
      //
      // Writes an signed 8-bit integer to the buffer.
      //---------------------------------------------------------------------------
      writeSB1(n) {
        const pos = this.reserveBytes(1);
        this.buf[pos] = n;
      }
      //---------------------------------------------------------------------------
      // writeUInt16BE()
      //
      // Writes an unsigned 16-bit integer to the buffer in big endian order.
      //---------------------------------------------------------------------------
      writeUInt16BE(n) {
        const pos = this.reserveBytes(2);
        this.buf.writeUInt16BE(n, pos);
      }
      //---------------------------------------------------------------------------
      // writeUInt32BE()
      //
      // Writes an unsigned 32-bit integer to the buffer in big endian order.
      //---------------------------------------------------------------------------
      writeUInt32BE(n) {
        const pos = this.reserveBytes(4);
        this.buf.writeUInt32BE(n, pos);
      }
      //---------------------------------------------------------------------------
      // writeUInt64BE()
      //
      // Writes an unsigned 64-bit integer to the buffer in big endian order. Since
      // Node.js doesn't support anything above 32-bits without using BigInt, the
      // higher order bits are simply written as 0.
      //---------------------------------------------------------------------------
      writeUInt64BE(n) {
        const pos = this.reserveBytes(8);
        this.buf.writeUInt32BE(0, pos);
        this.buf.writeUInt32BE(n, pos + 4);
      }
      //---------------------------------------------------------------------------
      // writeUInt16LE()
      //
      // Writes an unsigned 16-bit integer to the buffer in little endian order.
      //---------------------------------------------------------------------------
      writeUInt16LE(n) {
        const pos = this.reserveBytes(2);
        this.buf.writeUInt16LE(n, pos);
      }
    };
    var GrowableBuffer = class extends BaseBuffer {
      //---------------------------------------------------------------------------
      // constructor()
      //
      // Initializes the buffer with an initial fixed chunk size.
      //---------------------------------------------------------------------------
      constructor(initializer) {
        if (initializer) {
          super(initializer);
        } else {
          super(constants.BUFFER_CHUNK_SIZE);
          this.size = this.maxSize;
        }
      }
      //---------------------------------------------------------------------------
      // _grow()
      //
      // Called when the buffer needs to grow. Ensures that sufficient space is
      // allocated to include the requested number of bytes, rounded to the nearest
      // chunk size.
      //---------------------------------------------------------------------------
      _grow(numBytes) {
        const remainder = numBytes % constants.BUFFER_CHUNK_SIZE;
        if (remainder > 0) {
          numBytes += constants.BUFFER_CHUNK_SIZE - remainder;
        }
        const buf = Buffer2.allocUnsafe(numBytes);
        this.buf.copy(buf);
        this.buf = buf;
        this.maxSize = this.size = numBytes;
      }
    };
    module2.exports = {
      BaseBuffer,
      GrowableBuffer
    };
  }
});

// node_modules/oracledb/lib/impl/datahandlers/vector.js
var require_vector = __commonJS({
  "node_modules/oracledb/lib/impl/datahandlers/vector.js"(exports2, module2) {
    "use strict";
    var { BaseBuffer, GrowableBuffer } = require_buffer();
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants2();
    var errors = require_errors();
    var types = require_types();
    var VectorDecoder = class extends BaseBuffer {
      //---------------------------------------------------------------------------
      // decode()
      //
      // Decodes the VECTOR image and returns a JavaScript array corresponding to
      // its contents.
      //---------------------------------------------------------------------------
      decode() {
        const magicByte = this.readUInt8();
        if (magicByte != constants.TNS_VECTOR_MAGIC_BYTE)
          errors.throwErr(
            errors.ERR_UNEXPECTED_DATA,
            Buffer2.from([magicByte]).toString("hex")
          );
        const version = this.readUInt8();
        if (version > constants.TNS_VECTOR_VERSION_WITH_SPARSE)
          errors.throwErr(errors.ERR_VECTOR_VERSION_NOT_SUPPORTED, version);
        const flags = this.readUInt16BE();
        const vectorFormat = this.readUInt8();
        let numElements = this.readUInt32BE();
        let elementSize, value, sparseValue;
        if (vectorFormat === constants.VECTOR_FORMAT_BINARY || flags & constants.TNS_VECTOR_FLAG_NORM)
          this.skipBytes(8);
        let sparseFormat;
        if (flags & constants.TNS_VECTOR_FLAG_SPARSE) {
          sparseFormat = true;
          sparseValue = {};
          sparseValue.numDimensions = numElements;
          numElements = this.readUInt16BE();
          sparseValue.indices = new Uint32Array(numElements);
          for (let i = 0; i < numElements; i++) {
            sparseValue.indices[i] = this.readUInt32BE();
          }
        }
        if (vectorFormat === constants.VECTOR_FORMAT_FLOAT32) {
          elementSize = 4;
          value = new Float32Array(numElements);
        } else if (vectorFormat === constants.VECTOR_FORMAT_FLOAT64) {
          elementSize = 8;
          value = new Float64Array(numElements);
        } else if (vectorFormat === constants.VECTOR_FORMAT_INT8) {
          elementSize = 1;
          value = new Int8Array(numElements);
        } else if (vectorFormat === constants.VECTOR_FORMAT_BINARY) {
          elementSize = 1;
          numElements = numElements / 8;
          value = new Uint8Array(numElements);
        } else {
          errors.throwErr(errors.ERR_VECTOR_FORMAT_NOT_SUPPORTED, vectorFormat);
        }
        if (sparseFormat) {
          sparseValue.values = value;
        }
        let res;
        for (let i = 0; i < numElements; i++) {
          const buf = this.readBytes(elementSize);
          if (vectorFormat === constants.VECTOR_FORMAT_FLOAT32) {
            res = this.parseBinaryFloat(buf);
          } else if (vectorFormat === constants.VECTOR_FORMAT_FLOAT64) {
            res = this.parseBinaryDouble(buf);
          } else {
            res = buf[0];
          }
          value[i] = res;
        }
        return sparseFormat ? types.SparseVector.create(sparseValue) : value;
      }
    };
    var VectorEncoder = class extends GrowableBuffer {
      // Writes Header from value.
      // It returns function to serialize the value.
      // sparseVal is provided for SparseVector.
      _updateVectorHeader(value, sparseVal) {
        let flags = constants.TNS_VECTOR_FLAG_NORMSRC | constants.TNS_VECTOR_FLAG_NORM;
        let numElements = value.length;
        let vectorVersion = constants.TNS_VECTOR_VERSION_BASE;
        let vectorFormat = constants.VECTOR_FORMAT_FLOAT32;
        let writeFn = this.writeBinaryFloat.bind(this);
        if (Array.isArray(value) || value instanceof Float64Array) {
          vectorFormat = constants.VECTOR_FORMAT_FLOAT64;
          writeFn = this.writeBinaryDouble.bind(this);
        } else if (value instanceof Int8Array) {
          vectorFormat = constants.VECTOR_FORMAT_INT8;
          writeFn = this.writeSB1.bind(this);
        } else if (value.constructor.name === "Uint8Array") {
          vectorFormat = constants.VECTOR_FORMAT_BINARY;
          numElements = numElements * 8;
          vectorVersion = constants.TNS_VECTOR_VERSION_WITH_BINARY;
          flags = constants.TNS_VECTOR_FLAG_NORMSRC;
          writeFn = this.writeUInt8.bind(this);
        }
        if (sparseVal && sparseVal instanceof types.SparseVector) {
          vectorVersion = constants.TNS_VECTOR_VERSION_WITH_SPARSE;
          numElements = sparseVal.numDimensions;
          flags |= constants.TNS_VECTOR_FLAG_SPARSE;
        }
        this.writeUInt8(constants.TNS_VECTOR_MAGIC_BYTE);
        this.writeUInt8(vectorVersion);
        this.writeUInt16BE(flags);
        this.writeUInt8(vectorFormat);
        this.writeUInt32BE(numElements);
        this.reserveBytes(8);
        return writeFn;
      }
      //---------------------------------------------------------------------------
      // encode()
      //
      // Encodes the value as OSON and returns a buffer containing the OSON bytes.
      //---------------------------------------------------------------------------
      encode(value) {
        let writeFn;
        if (value instanceof types.SparseVector) {
          writeFn = this._updateVectorHeader(value.values, value);
          const numElements = value.indices.length;
          this.writeUInt16BE(numElements);
          value.indices.forEach((element) => {
            this.writeUInt32BE(element);
          });
          value = value.values;
        } else {
          writeFn = this._updateVectorHeader(value);
        }
        value.forEach((element) => {
          writeFn(element);
        });
        return this.buf.subarray(0, this.pos);
      }
    };
    module2.exports = {
      VectorDecoder,
      VectorEncoder
    };
  }
});

// node_modules/oracledb/lib/settings.js
var require_settings = __commonJS({
  "node_modules/oracledb/lib/settings.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var errors = require_errors();
    var types = require_types();
    var nodbUtil = require_util();
    var vector = require_vector();
    var Settings = class {
      constructor() {
        this.autoCommit = false;
        this.connectionClass = "";
        this.dbObjectAsPojo = false;
        this.edition = "";
        this.errorOnConcurrentExecute = false;
        this.events = false;
        this.externalAuth = false;
        this.fetchArraySize = 100;
        this.fetchAsBuffer = [];
        this.fetchAsString = [];
        this.lobPrefetchSize = 16384;
        this.maxRows = 0;
        this.outFormat = constants.OUT_FORMAT_ARRAY;
        this.poolIncrement = 1;
        this.poolMax = 4;
        this.poolMaxPerShard = 0;
        this.poolMin = 0;
        this.poolPingInterval = 60;
        this.poolPingTimeout = 5e3;
        this.poolTimeout = 60;
        this.prefetchRows = 2;
        this.queueTimeout = 6e4;
        this.queueMax = 500;
        this.stmtCacheSize = 30;
        this.configProviderCacheTimeout = 86400;
        this.thin = true;
        this.thinDriverInitialized = false;
        this.createFetchTypeMap(this.fetchAsString, this.fetchAsBuffer);
        this.fetchTypeHandler = void 0;
        this.dbObjectTypeHandler = void 0;
        this._JsonId = types.JsonId;
        this._SparseVector = types.SparseVector;
        this._IntervalYM = types.IntervalYM;
        this._IntervalDS = types.IntervalDS;
      }
      //---------------------------------------------------------------------------
      // _getDateComponents()
      //
      // Returns the components of a date. DATE and TIMESTAMP data from the
      // database are returned as though they used the JavaScript time zone
      // setting. TIMESTAMP WITH TIME ZONE and TIMESTAMP WITH LOCAL TIME ZONE data
      // are returned in native JavaScript format (since they contain time zone
      // information). This is used only in Thick mode (from node-oracledb 6.0.0).
      //---------------------------------------------------------------------------
      _getDateComponents(useLocal, date) {
        if (useLocal) {
          return [
            date.getFullYear(),
            date.getMonth() + 1,
            date.getDate(),
            date.getHours(),
            date.getMinutes(),
            date.getSeconds(),
            date.getMilliseconds() * 1e3 * 1e3
          ];
        } else {
          return [
            date.getUTCFullYear(),
            date.getUTCMonth() + 1,
            date.getUTCDate(),
            date.getUTCHours(),
            date.getUTCMinutes(),
            date.getUTCSeconds(),
            date.getUTCMilliseconds() * 1e3 * 1e3
          ];
        }
      }
      //---------------------------------------------------------------------------
      // _makeDate()
      //
      // Returns a date from the given components. DATE and TIMESTAMP data from the
      // database are returned as though they used the JavaScript time zone
      // setting. TIMESTAMP WITH TIME ZONE and TIMESTAMP WITH LOCAL TIME ZONE data
      // are returned in native JavaScript format (since they contain time zone
      // information).
      //---------------------------------------------------------------------------
      _makeDate(useLocal, year, month, day, hour, minute, second, fseconds, offset) {
        return nodbUtil.makeDate(useLocal, year, month, day, hour, minute, second, fseconds, offset);
      }
      //---------------------------------------------------------------------------
      // _decodeVector()
      //
      // Returns a typed array by decoding buffer.
      //
      //---------------------------------------------------------------------------
      _decodeVector(buffer) {
        const decoder = new vector.VectorDecoder(buffer);
        return decoder.decode();
      }
      //---------------------------------------------------------------------------
      // _encodeVector()
      //
      // Create a Vector image from typedarray
      //
      //---------------------------------------------------------------------------
      _encodeVector(value) {
        const encoder = new vector.VectorEncoder();
        return encoder.encode(value);
      }
      //---------------------------------------------------------------------------
      // addToOptions()
      //
      // Adds the named settingsto the options, if no option has already been
      // specified.
      //---------------------------------------------------------------------------
      addToOptions(options) {
        for (let i = 1; i < arguments.length; i++) {
          const key = arguments[i];
          if (options[key] === void 0)
            options[key] = this[key];
        }
      }
      //---------------------------------------------------------------------------
      // createFetchTypeMap()
      //
      // Creates the fetch type map. This overrides the default fetch type mapping
      // used by the driver with the contents of the fetchAsString and
      // fetchAsBuffer arrays. The error checking is performed here as well in
      // order to eliminate repeated code.
      // ---------------------------------------------------------------------------
      createFetchTypeMap(fetchAsString, fetchAsBuffer) {
        const map = new Map(types.DB_TYPE_FETCH_TYPE_MAP);
        for (const element of fetchAsString) {
          switch (element) {
            case types.DB_TYPE_NUMBER:
              map.set(types.DB_TYPE_BINARY_DOUBLE, types.DB_TYPE_VARCHAR);
              map.set(types.DB_TYPE_BINARY_FLOAT, types.DB_TYPE_VARCHAR);
              map.set(types.DB_TYPE_BINARY_INTEGER, types.DB_TYPE_VARCHAR);
              map.set(types.DB_TYPE_NUMBER, types.DB_TYPE_VARCHAR);
              break;
            case types.DB_TYPE_TIMESTAMP:
              map.set(types.DB_TYPE_DATE, types.DB_TYPE_VARCHAR);
              map.set(types.DB_TYPE_TIMESTAMP, types.DB_TYPE_VARCHAR);
              map.set(types.DB_TYPE_TIMESTAMP_TZ, types.DB_TYPE_VARCHAR);
              map.set(types.DB_TYPE_TIMESTAMP_LTZ, types.DB_TYPE_VARCHAR);
              break;
            case types.DB_TYPE_CLOB:
            case types.DB_TYPE_NCLOB:
              map.set(types.DB_TYPE_CLOB, types.DB_TYPE_LONG);
              map.set(types.DB_TYPE_NCLOB, types.DB_TYPE_LONG_NVARCHAR);
              break;
            case types.DB_TYPE_VECTOR:
              map.set(types.DB_TYPE_VECTOR, types.DB_TYPE_LONG);
              break;
            case types.DB_TYPE_RAW:
              map.set(types.DB_TYPE_RAW, types.DB_TYPE_VARCHAR);
              break;
            case types.DB_TYPE_JSON:
              map.set(types.DB_TYPE_JSON, types.DB_TYPE_VARCHAR);
              break;
            default:
              errors.throwErr(errors.ERR_INVALID_TYPE_FOR_CONVERSION);
          }
        }
        for (const element of fetchAsBuffer) {
          switch (element) {
            case types.DB_TYPE_BLOB:
              map.set(types.DB_TYPE_BLOB, types.DB_TYPE_LONG_RAW);
              break;
            default:
              errors.throwErr(errors.ERR_INVALID_TYPE_FOR_CONVERSION);
          }
        }
        this.fetchTypeMap = map;
      }
    };
    module2.exports = new Settings();
  }
});

// node_modules/oracledb/lib/errors.js
var require_errors = __commonJS({
  "node_modules/oracledb/lib/errors.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ERR_PREFIX = "NJS";
    var ERR_INTEGRITY_ERROR_CODES = [
      1,
      // unique constraint violated
      1400,
      // cannot insert NULL
      1438,
      // value larger than specified precision
      2290,
      // check constraint violated
      2291,
      // integrity constraint violated - parent key not found
      2292,
      // integrity constraint violated - child record found
      21525,
      // attribute or collection element violated its constraints
      40479
      // internal JSON serializer error
    ];
    var ERR_INVALID_POOL = 2;
    var ERR_INVALID_CONNECTION = 3;
    var ERR_INVALID_PROPERTY_VALUE = 4;
    var ERR_INVALID_PARAMETER_VALUE = 5;
    var ERR_INVALID_PROPERTY_VALUE_IN_PARAM = 7;
    var ERR_INVALID_NUMBER_OF_PARAMETERS = 9;
    var ERR_UNSUPPORTED_DATA_TYPE = 10;
    var ERR_BIND_VALUE_AND_TYPE_MISMATCH = 11;
    var ERR_INVALID_BIND_DATA_TYPE = 12;
    var ERR_INVALID_BIND_DIRECTION = 13;
    var ERR_NO_TYPE_FOR_CONVERSION = 15;
    var ERR_INSUFFICIENT_BUFFER_FOR_BINDS = 16;
    var ERR_BUSY_RS = 17;
    var ERR_INVALID_RS = 18;
    var ERR_NOT_A_QUERY = 19;
    var ERR_INVALID_TYPE_FOR_CONVERSION = 21;
    var ERR_INVALID_LOB = 22;
    var ERR_BUSY_LOB = 23;
    var ERR_INSUFFICIENT_MEMORY = 24;
    var ERR_INVALID_TYPE_FOR_ARRAY_BIND = 34;
    var ERR_REQUIRED_MAX_ARRAY_SIZE = 35;
    var ERR_INVALID_ARRAY_SIZE = 36;
    var ERR_INCOMPATIBLE_TYPE_ARRAY_BIND = 37;
    var ERR_CONN_REQUEST_TIMEOUT = 40;
    var ERR_CANNOT_CONVERT_RS_TO_STREAM = 41;
    var ERR_CANNOT_INVOKE_RS_METHODS = 42;
    var ERR_RS_ALREADY_CONVERTED = 43;
    var ERR_INVALID_BIND_UNIT = 44;
    var ERR_CANNOT_LOAD_BINARY = 45;
    var ERR_POOL_WITH_ALIAS_ALREADY_EXISTS = 46;
    var ERR_POOL_WITH_ALIAS_NOT_FOUND = 47;
    var ERR_INCOMPATIBLE_TYPE_ARRAY_INDEX_BIND = 52;
    var ERR_MIXED_BIND = 55;
    var ERR_MISSING_MAX_SIZE_BY_POS = 56;
    var ERR_MISSING_MAX_SIZE_BY_NAME = 57;
    var ERR_MAX_SIZE_TOO_SMALL = 58;
    var ERR_MISSING_TYPE_BY_POS = 59;
    var ERR_MISSING_TYPE_BY_NAME = 60;
    var ERR_INVALID_SUBSCR = 61;
    var ERR_MISSING_SUBSCR_CALLBACK = 62;
    var ERR_MISSING_SUBSCR_SQL = 63;
    var ERR_POOL_CLOSING = 64;
    var ERR_POOL_CLOSED = 65;
    var ERR_INVALID_SODA_DOC_CURSOR = 66;
    var ERR_NO_BINARY_AVAILABLE = 67;
    var ERR_INVALID_ERR_NUM = 68;
    var ERR_NODE_TOO_OLD = 69;
    var ERR_INVALID_AQ_MESSAGE = 70;
    var ERR_DBL_CONNECT_STRING = 75;
    var ERR_QUEUE_MAX_EXCEEDED = 76;
    var ERR_UNSUPPORTED_DATA_TYPE_IN_JSON = 78;
    var ERR_DBL_USER = 80;
    var ERR_CONCURRENT_OPS = 81;
    var ERR_POOL_RECONFIGURING = 82;
    var ERR_POOL_STATISTICS_DISABLED = 83;
    var ERR_TOKEN_BASED_AUTH = 84;
    var ERR_POOL_TOKEN_BASED_AUTH = 85;
    var ERR_CONN_TOKEN_BASED_AUTH = 86;
    var ERR_TOKEN_HAS_EXPIRED = 87;
    var ERR_NOT_IMPLEMENTED = 89;
    var ERR_INIT_ORACLE_CLIENT_ARGS = 90;
    var ERR_MISSING_FILE = 91;
    var ERR_INVALID_NUMBER_OF_CONNECTIONS = 92;
    var ERR_EXEC_MODE_ONLY_FOR_DML = 95;
    var ERR_INVALID_BIND_NAME = 97;
    var ERR_WRONG_NUMBER_OF_BINDS = 98;
    var ERR_BUFFER_LENGTH_INSUFFICIENT = 99;
    var ERR_NCHAR_CS_NOT_SUPPORTED = 100;
    var ERR_MISSING_CREDENTIALS = 101;
    var ERR_UNEXPECTED_END_OF_DATA = 102;
    var ERR_UNEXPECTED_MESSAGE_TYPE = 103;
    var ERR_POOL_HAS_BUSY_CONNECTIONS = 104;
    var ERR_NAN_VALUE = 105;
    var ERR_INTERNAL = 106;
    var ERR_INVALID_REF_CURSOR = 107;
    var ERR_INVALID_TYPE_NUM = 109;
    var ERR_INVALID_ORACLE_TYPE_NUM = 110;
    var ERR_UNEXPECTED_NEGATIVE_INTEGER = 111;
    var ERR_INTEGER_TOO_LARGE = 112;
    var ERR_UNEXPECTED_DATA = 113;
    var ERR_OSON_FIELD_NAME_LIMITATION = 114;
    var ERR_ORACLE_NUMBER_NO_REPR = 115;
    var ERR_UNSUPPORTED_VERIFIER_TYPE = 116;
    var ERR_THIN_CONNECTION_ALREADY_CREATED = 118;
    var ERR_UNSUPPORTED_CONVERSION = 119;
    var ERR_FETCH_TYPE_HANDLER_RETURN_VALUE = 120;
    var ERR_FETCH_TYPE_HANDLER_TYPE = 121;
    var ERR_FETCH_TYPE_HANDLER_CONVERTER = 122;
    var ERR_CALL_TIMEOUT_EXCEEDED = 123;
    var ERR_EMPTY_CONNECT_STRING = 125;
    var ERR_OSON_VERSION_NOT_SUPPORTED = 126;
    var ERR_UNKOWN_SERVER_SIDE_PIGGYBACK = 127;
    var ERR_UNKNOWN_COLUMN_TYPE_NAME = 128;
    var ERR_INVALID_OBJECT_TYPE_NAME = 129;
    var ERR_TDS_TYPE_NOT_SUPPORTED = 130;
    var ERR_INVALID_COLL_INDEX_SET = 131;
    var ERR_INVALID_COLL_INDEX_GET = 132;
    var ERR_DELETE_ELEMENTS_OF_VARRAY = 133;
    var ERR_WRONG_VALUE_FOR_DBOBJECT_ATTR = 134;
    var ERR_WRONG_VALUE_FOR_DBOBJECT_ELEM = 135;
    var ERR_WRONG_CRED_FOR_EXTAUTH = 136;
    var ERR_MISSING_BIND_VALUE = 137;
    var ERR_SERVER_VERSION_NOT_SUPPORTED = 138;
    var ERR_UNEXPECTED_XML_TYPE = 139;
    var ERR_WRONG_USER_FORMAT_EXTAUTH_PROXY = 140;
    var ERR_TOO_MANY_BATCH_ERRORS = 141;
    var ERR_WRONG_LENGTH_FOR_DBOBJECT_ATTR = 142;
    var ERR_WRONG_LENGTH_FOR_DBOBJECT_ELEM = 143;
    var ERR_VECTOR_FORMAT_NOT_SUPPORTED = 144;
    var ERR_VECTOR_VERSION_NOT_SUPPORTED = 145;
    var ERR_OBJECT_IS_NOT_A_COLLECTION = 146;
    var ERR_CURSOR_HAS_BEEN_CLOSED = 147;
    var ERR_DML_RETURNING_DUP_BINDS = 149;
    var ERR_INVALID_TPC_BEGIN_FLAGS = 150;
    var ERR_INVALID_TPC_END_FLAGS = 151;
    var ERR_UNKNOWN_TRANSACTION_STATE = 152;
    var ERR_INVALID_TRANSACTION_SIZE = 153;
    var ERR_INVALID_BRANCH_SIZE = 154;
    var ERR_OPERATION_NOT_SUPPORTED_ON_BFILE = 155;
    var ERR_OPERATION_ONLY_SUPPORTED_ON_BFILE = 156;
    var ERR_EXECMANY_NOT_ALLOWED_ON_QUERIES = 157;
    var ERR_VECTOR_SPARSE_INDICES_IS_NOT_ARRAY = 158;
    var ERR_VECTOR_SPARSE_VALUES_IS_NOT_ARRAY = 159;
    var ERR_VECTOR_SPARSE_DIMS_IS_NOT_INTEGER = 160;
    var ERR_VECTOR_SPARSE_INDICES_VALUES_NOT_EQUAL = 161;
    var ERR_VECTOR_SPARSE_INVALID_JSON = 162;
    var ERR_VECTOR_SPARSE_INVALID_STRING = 163;
    var ERR_VECTOR_SPARSE_INVALID_INPUT = 164;
    var ERR_VECTOR_SPARSE_INDICES_ELEM_IS_NOT_VALID = 165;
    var ERR_DB_FETCH_TYPE_HANDLER_CONVERTER = 166;
    var ERR_DB_FETCH_TYPE_HANDLER_RETURN_VALUE = 167;
    var ERR_ACCESS_TOKEN = 168;
    var ERR_CALLOUT_FN = 169;
    var ERR_SESSIONLESS_DIFFERING_METHODS = 170;
    var ERR_SESSIONLESS_ALREADY_ACTIVE = 171;
    var ERR_SESSIONLESS_INACTIVE = 172;
    var ERR_INVALID_SERVER_RESPONSE = 173;
    var ERR_PAYLOAD_CANNOT_BE_ENQUEUED = 174;
    var ERR_CONNECTION_CLOSED = 500;
    var ERR_CONNECTION_LOSTCONTACT = 501;
    var ERR_CONNECTION_INCOMPLETE = 503;
    var ERR_PROXY_CONNECTION_FAILURE = 504;
    var ERR_TLS_INIT_FAILURE = 505;
    var ERR_TLS_AUTH_FAILURE = 506;
    var ERR_TLS_DNMATCH_FAILURE = 507;
    var ERR_TLS_HOSTMATCH_FAILURE = 508;
    var ERR_INVALID_PACKET = 509;
    var ERR_CONNECTION_TIMEDOUT = 510;
    var ERR_CONNECTION_REFUSED = 511;
    var ERR_INVALID_CONNECT_STRING_PARAMETERS = 512;
    var ERR_CONNECTION_INBAND = 513;
    var ERR_INVALID_CONNECT_STRING_SYNTAX = 514;
    var ERR_INVALID_EZCONNECT_SYNTAX = 515;
    var ERR_NO_CONFIG_DIR = 516;
    var ERR_TNS_ENTRY_NOT_FOUND = 517;
    var ERR_INVALID_SERVICE_NAME = 518;
    var ERR_INVALID_SID = 519;
    var ERR_TNS_NAMES_FILE_MISSING = 520;
    var ERR_CONNECTION_EOF = 521;
    var ERR_CONFIG_PROVIDER_FAILED_TO_RETRIEVE_CONFIG = 523;
    var ERR_REGISTER_HOOKFN_CONFIGPROVIDER = 524;
    var ERR_WALLET_TYPE_NOT_SUPPORTED = 529;
    var ERR_HOST_NOT_FOUND = 530;
    var ERR_ANO_PACKET = 531;
    var ERR_ANO_STATUS = 532;
    var ERR_ANO_NEGOTIATION = 533;
    var ERR_DATA_COMPRESSION = 534;
    var ERR_CONFIG_PROVIDER_PARAM_TYPE = 535;
    var WRN_COMPILATION_CREATE = 700;
    var adjustErrorXref = /* @__PURE__ */ new Map();
    adjustErrorXref.set("DPI-1010", ERR_INVALID_CONNECTION);
    adjustErrorXref.set("DPI-1024", [ERR_INVALID_COLL_INDEX_GET, "at index ([0-9]+) does"]);
    adjustErrorXref.set("DPI-1044", ERR_ORACLE_NUMBER_NO_REPR);
    adjustErrorXref.set("DPI-1055", ERR_NAN_VALUE);
    adjustErrorXref.set("DPI-1063", ERR_EXEC_MODE_ONLY_FOR_DML);
    adjustErrorXref.set("DPI-1067", [ERR_CALL_TIMEOUT_EXCEEDED, "call timeout of ([0-9]+) ms"]);
    adjustErrorXref.set("DPI-1080", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("OCI-22303", [ERR_INVALID_OBJECT_TYPE_NAME, 'type "([^"]*"."[^"]*)"']);
    adjustErrorXref.set("OCI-22164", ERR_DELETE_ELEMENTS_OF_VARRAY);
    adjustErrorXref.set("OCI-22165", [ERR_INVALID_COLL_INDEX_SET, /index \[([0-9]+)\] must be in the range of \[([0-9]+)\] to \[([0-9]+)\]/]);
    adjustErrorXref.set("ORA-00022", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-00028", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-00031", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-00045", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-00378", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-00600", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-00602", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-00603", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-00609", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-01012", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-01041", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-01043", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-01089", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-01092", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-02396", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-03113", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-03114", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-03122", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-03135", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-12153", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-12537", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-12547", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-12570", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-12583", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-27146", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-28511", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-56600", ERR_CONNECTION_CLOSED);
    adjustErrorXref.set("ORA-24338", ERR_INVALID_REF_CURSOR);
    adjustErrorXref.set("ORA-25708", ERR_TOKEN_HAS_EXPIRED);
    adjustErrorXref.set("ORA-24344", WRN_COMPILATION_CREATE);
    adjustErrorXref.set("ORA-26202", ERR_SESSIONLESS_INACTIVE);
    adjustErrorXref.set("ORA-26211", ERR_SESSIONLESS_DIFFERING_METHODS);
    adjustErrorXref.set("ORA-26216", ERR_SESSIONLESS_ALREADY_ACTIVE);
    adjustErrorXref.set("DPI-1071", ERR_PAYLOAD_CANNOT_BE_ENQUEUED);
    var messages = /* @__PURE__ */ new Map();
    messages.set(
      ERR_INVALID_POOL,
      // NJS-002
      "invalid pool"
    );
    messages.set(
      ERR_INVALID_CONNECTION,
      // NJS-003
      "invalid or closed connection"
    );
    messages.set(
      ERR_INVALID_PROPERTY_VALUE,
      // NJS-004
      'invalid value for property "%s"'
    );
    messages.set(
      ERR_INVALID_PARAMETER_VALUE,
      // NJS-005
      "invalid value for parameter %d"
    );
    messages.set(
      ERR_INVALID_PROPERTY_VALUE_IN_PARAM,
      // NJS-007
      'invalid value for "%s" in parameter %d'
    );
    messages.set(
      ERR_INVALID_NUMBER_OF_PARAMETERS,
      // NJS-009
      "invalid number of function parameters: %d provided but expected between %d and %d"
    );
    messages.set(
      ERR_UNSUPPORTED_DATA_TYPE,
      // NJS-010
      "unsupported data type %d in column %d"
    );
    messages.set(
      ERR_BIND_VALUE_AND_TYPE_MISMATCH,
      // NJS-011
      "encountered bind value and type mismatch"
    );
    messages.set(
      ERR_INVALID_BIND_DATA_TYPE,
      // NJS-012
      "encountered invalid bind data type in parameter %d"
    );
    messages.set(
      ERR_INVALID_BIND_DIRECTION,
      // NJS-013
      "invalid bind direction"
    );
    messages.set(
      ERR_NO_TYPE_FOR_CONVERSION,
      // NJS-015
      "type was not specified for conversion"
    );
    messages.set(
      ERR_INSUFFICIENT_BUFFER_FOR_BINDS,
      // NJS-016
      "buffer is too small for OUT binds"
    );
    messages.set(
      ERR_BUSY_RS,
      // NJS-017
      "concurrent operations on ResultSet are not allowed"
    );
    messages.set(
      ERR_INVALID_RS,
      // NJS-018
      "invalid ResultSet"
    );
    messages.set(
      ERR_NOT_A_QUERY,
      // NJS-019
      "ResultSet cannot be returned for non-query statements"
    );
    messages.set(
      ERR_INVALID_TYPE_FOR_CONVERSION,
      // NJS-021
      "invalid type for conversion specified"
    );
    messages.set(
      ERR_INVALID_LOB,
      // NJS-022
      "invalid Lob"
    );
    messages.set(
      ERR_BUSY_LOB,
      // NJS-023
      "concurrent operations on a Lob are not allowed"
    );
    messages.set(
      ERR_INSUFFICIENT_MEMORY,
      // NJS-024
      "memory allocation failed"
    );
    messages.set(
      ERR_INVALID_TYPE_FOR_ARRAY_BIND,
      // NJS-034
      "data type is unsupported for array bind"
    );
    messages.set(
      ERR_REQUIRED_MAX_ARRAY_SIZE,
      // NJS-035
      "maxArraySize is required for IN OUT array bind"
    );
    messages.set(
      ERR_INVALID_ARRAY_SIZE,
      // NJS-036
      'length of given array is greater than "maxArraySize"'
    );
    messages.set(
      ERR_INCOMPATIBLE_TYPE_ARRAY_BIND,
      // NJS-037
      'invalid data type at array index %d for bind ":%s"'
    );
    messages.set(
      ERR_CONN_REQUEST_TIMEOUT,
      // NJS-040
      'connection request timeout. Request exceeded "queueTimeout" of %d'
    );
    messages.set(
      ERR_CANNOT_CONVERT_RS_TO_STREAM,
      // NJS-041
      "cannot convert ResultSet to QueryStream after invoking methods"
    );
    messages.set(
      ERR_CANNOT_INVOKE_RS_METHODS,
      // NJS-042
      "cannot invoke ResultSet methods after converting to QueryStream"
    );
    messages.set(
      ERR_RS_ALREADY_CONVERTED,
      // NJS-043
      "ResultSet already converted to QueryStream"
    );
    messages.set(
      ERR_INVALID_BIND_UNIT,
      // NJS-044
      'bind object must contain one of the following attributes: "dir", "type", "maxSize", or "val"'
    );
    messages.set(
      ERR_CANNOT_LOAD_BINARY,
      // NJS-045
      "cannot load a node-oracledb Thick mode binary for Node.js. Please try using Thin mode. %s"
    );
    messages.set(
      ERR_POOL_WITH_ALIAS_ALREADY_EXISTS,
      // NJS-046
      'pool alias "%s" already exists in the connection pool cache'
    );
    messages.set(
      ERR_POOL_WITH_ALIAS_NOT_FOUND,
      // NJS-047
      'pool alias "%s" not found in connection pool cache'
    );
    messages.set(
      ERR_INCOMPATIBLE_TYPE_ARRAY_INDEX_BIND,
      // NJS-052
      "invalid data type at array index %d for bind position %d"
    );
    messages.set(
      ERR_MIXED_BIND,
      // NJS-055
      "binding by position and name cannot be mixed"
    );
    messages.set(
      ERR_MISSING_MAX_SIZE_BY_POS,
      // NJS-056
      "maxSize for bind position %d must be specified and be greater than zero"
    );
    messages.set(
      ERR_MISSING_MAX_SIZE_BY_NAME,
      // NJS-057
      'maxSize for bind "%s" must be specified and greater than zero'
    );
    messages.set(
      ERR_MAX_SIZE_TOO_SMALL,
      // NJS-058
      "maxSize of %d is too small for value of length %d in row %d"
    );
    messages.set(
      ERR_MISSING_TYPE_BY_POS,
      // NJS-059
      "type must be specified for bind position %d"
    );
    messages.set(
      ERR_MISSING_TYPE_BY_NAME,
      // NJS-060
      'type must be specified for bind "%s"'
    );
    messages.set(
      ERR_INVALID_SUBSCR,
      // NJS-061
      "invalid subscription"
    );
    messages.set(
      ERR_MISSING_SUBSCR_CALLBACK,
      // NJS-062
      "subscription notification callback missing"
    );
    messages.set(
      ERR_MISSING_SUBSCR_SQL,
      // NJS-063
      "subscription notification SQL missing"
    );
    messages.set(
      ERR_POOL_CLOSING,
      // NJS-064
      "connection pool is closing"
    );
    messages.set(
      ERR_POOL_CLOSED,
      // NJS-065
      "connection pool was closed"
    );
    messages.set(
      ERR_INVALID_SODA_DOC_CURSOR,
      // NJS-066
      "invalid SODA document cursor"
    );
    messages.set(
      ERR_NO_BINARY_AVAILABLE,
      // NJS-067
      "a pre-built node-oracledb Thick mode binary was not found for %s"
    );
    messages.set(
      ERR_INVALID_ERR_NUM,
      // NJS-068
      "invalid error number %d supplied"
    );
    messages.set(
      ERR_NODE_TOO_OLD,
      // NJS-069
      "node-oracledb %s requires Node.js %s or later"
    );
    messages.set(
      ERR_INVALID_AQ_MESSAGE,
      // NJS-070
      "message must be a string, buffer, database object or an object containing a payload property which itself is a string, buffer or database object"
    );
    messages.set(
      ERR_DBL_CONNECT_STRING,
      // NJS-075
      'only one of "connectString" and "connectionString" can be used'
    );
    messages.set(
      ERR_QUEUE_MAX_EXCEEDED,
      // NJS-076
      'connection request rejected. Pool queue length "queueMax" %d reached'
    );
    messages.set(
      ERR_UNSUPPORTED_DATA_TYPE_IN_JSON,
      // NJS-078
      "unsupported data type %d in JSON value"
    );
    messages.set(
      ERR_DBL_USER,
      // NJS-080
      'only one of "user" and "username" can be used'
    );
    messages.set(
      ERR_CONCURRENT_OPS,
      // NJS-081
      "concurrent operations on a connection are disabled"
    );
    messages.set(
      ERR_POOL_RECONFIGURING,
      // NJS-082
      "connection pool is being reconfigured"
    );
    messages.set(
      ERR_POOL_STATISTICS_DISABLED,
      // NJS-083
      "pool statistics are not enabled"
    );
    messages.set(
      ERR_TOKEN_BASED_AUTH,
      // NJS-084
      "invalid access token"
    );
    messages.set(
      ERR_POOL_TOKEN_BASED_AUTH,
      // NJS-085
      'invalid connection pool configuration with token-based authentication. The "homogeneous" and "externalAuth" attributes must be set to true'
    );
    messages.set(
      ERR_CONN_TOKEN_BASED_AUTH,
      // NJS-086
      'invalid standalone configuration with token-based authentication. The "externalAuth" attribute must be set to true'
    );
    messages.set(
      ERR_TOKEN_HAS_EXPIRED,
      // NJS-087
      "access token has expired"
    );
    messages.set(
      ERR_NOT_IMPLEMENTED,
      // NJS-089
      "%s is not supported by node-oracledb in Thin mode"
    );
    messages.set(
      ERR_INIT_ORACLE_CLIENT_ARGS,
      // NJS-090
      "initOracleClient() was already called with different arguments"
    );
    messages.set(
      ERR_MISSING_FILE,
      // NJS-091
      "file %s is missing"
    );
    messages.set(
      ERR_INVALID_NUMBER_OF_CONNECTIONS,
      // NJS-092
      '"poolMax" %d must be greater than or equal to "poolMin" %d'
    );
    messages.set(
      ERR_EXEC_MODE_ONLY_FOR_DML,
      // NJS-095
      'setting "batchErrors" or "dmlRowCounts" to true is only permitted for DML statements'
    );
    messages.set(
      ERR_INVALID_BIND_NAME,
      // NJS-097
      'no bind placeholder named ":%s" was found in the statement text'
    );
    messages.set(
      ERR_WRONG_NUMBER_OF_BINDS,
      // NJS-098
      "%d bind placeholders were used in the SQL statement but %d bind values were provided"
    );
    messages.set(
      ERR_BUFFER_LENGTH_INSUFFICIENT,
      // NJS-099
      "internal error: buffer of length %d insufficient to hold %d bytes"
    );
    messages.set(
      ERR_NCHAR_CS_NOT_SUPPORTED,
      // NJS-100
      "national character set id %d is not supported by node-oracledb in Thin mode"
    );
    messages.set(
      ERR_MISSING_CREDENTIALS,
      // NJS-101
      "no credentials specified"
    );
    messages.set(
      ERR_UNEXPECTED_END_OF_DATA,
      // NJS-102
      "unexpected end of data: want %d bytes but only %d bytes are available"
    );
    messages.set(
      ERR_UNEXPECTED_MESSAGE_TYPE,
      // NJS-103
      "unexpected message type %d received at position %d of packet %d"
    );
    messages.set(
      ERR_POOL_HAS_BUSY_CONNECTIONS,
      // NJS-104
      "connection pool cannot be closed because connections are busy"
    );
    messages.set(
      ERR_NAN_VALUE,
      // NJS-105
      "value is not a number (NaN) and cannot be used in Oracle Database numbers"
    );
    messages.set(
      ERR_INTERNAL,
      // NJS-106
      "internal error: %s"
    );
    messages.set(
      ERR_INVALID_REF_CURSOR,
      // NJS-107
      "invalid cursor"
    );
    messages.set(
      ERR_INVALID_TYPE_NUM,
      // NJS-109
      "invalid type number %d"
    );
    messages.set(
      ERR_INVALID_ORACLE_TYPE_NUM,
      // NJS-110
      "invalid Oracle type number %d [csfrm: %d]"
    );
    messages.set(
      ERR_UNEXPECTED_NEGATIVE_INTEGER,
      // NJS-111
      "internal error: read a negative integer when expecting a positive integer at position %d of packet %d"
    );
    messages.set(
      ERR_INTEGER_TOO_LARGE,
      // NJS-112
      "internal error: read integer of length %d when expecting integer of no more than length %d at position %d of packet %d"
    );
    messages.set(
      ERR_UNEXPECTED_DATA,
      // NJS-113
      "unexpected data received: %s"
    );
    messages.set(
      ERR_OSON_FIELD_NAME_LIMITATION,
      // NJS-114
      "OSON field names may not exceed %d UTF-8 encoded bytes"
    );
    messages.set(
      ERR_ORACLE_NUMBER_NO_REPR,
      // NJS-115
      "value cannot be represented as an Oracle Database number"
    );
    messages.set(
      ERR_UNSUPPORTED_VERIFIER_TYPE,
      // NJS-116
      "password verifier type 0x%s is not supported by node-oracledb in Thin mode"
    );
    messages.set(
      ERR_THIN_CONNECTION_ALREADY_CREATED,
      // NJS-118
      "node-oracledb Thick mode cannot be enabled because a Thin mode connection has already been created"
    );
    messages.set(
      ERR_UNSUPPORTED_CONVERSION,
      // NJS-119
      "conversion from type %s to type %s is not supported"
    );
    messages.set(
      ERR_FETCH_TYPE_HANDLER_RETURN_VALUE,
      // NJS-120
      "fetchTypeHandler return value must be an object"
    );
    messages.set(
      ERR_FETCH_TYPE_HANDLER_TYPE,
      // NJS-121
      'fetchTypeHandler return value attribute "type" must be a valid database type'
    );
    messages.set(
      ERR_FETCH_TYPE_HANDLER_CONVERTER,
      // NJS-122
      'fetchTypeHandler return value attribute "converter" must be a function'
    );
    messages.set(
      ERR_CALL_TIMEOUT_EXCEEDED,
      // NJS-123
      "call timeout of %d ms exceeded"
    );
    messages.set(
      ERR_EMPTY_CONNECT_STRING,
      // NJS-125
      '"connectString" cannot be empty or undefined. Bequeath connections are not supported in Thin mode'
    );
    messages.set(
      ERR_OSON_VERSION_NOT_SUPPORTED,
      // NJS-126
      "OSON version %s is not supported"
    );
    messages.set(
      ERR_UNKOWN_SERVER_SIDE_PIGGYBACK,
      // NJS-127
      "internal error: unknown server side piggyback opcode %s"
    );
    messages.set(
      ERR_UNKNOWN_COLUMN_TYPE_NAME,
      // NJS-128
      'internal error: unknown column type name "%s"'
    );
    messages.set(
      ERR_INVALID_OBJECT_TYPE_NAME,
      // NJS-129
      'invalid object type name: "%s"'
    );
    messages.set(
      ERR_TDS_TYPE_NOT_SUPPORTED,
      // NJS-130
      "Oracle TDS data type %d is not supported"
    );
    messages.set(
      ERR_INVALID_COLL_INDEX_SET,
      // NJS-131
      "given index [%d] must be in the range of [%d] to [%d]"
    );
    messages.set(
      ERR_INVALID_COLL_INDEX_GET,
      // NJS-132
      "element at index %d does not exist"
    );
    messages.set(
      ERR_DELETE_ELEMENTS_OF_VARRAY,
      // NJS-133
      "cannot delete elements of a VARRAY"
    );
    messages.set(
      ERR_WRONG_VALUE_FOR_DBOBJECT_ATTR,
      // NJS-134
      "value is of wrong type for attribute %s of object %s"
    );
    messages.set(
      ERR_WRONG_VALUE_FOR_DBOBJECT_ELEM,
      // NJS-135
      "value is of wrong type for an element of object %s"
    );
    messages.set(
      ERR_WRONG_CRED_FOR_EXTAUTH,
      // NJS-136
      "user name and password cannot be set when using external authentication"
    );
    messages.set(
      ERR_MISSING_BIND_VALUE,
      // NJS-137
      'a bind variable replacement value for placeholder ":%s" was not provided'
    );
    messages.set(
      ERR_SERVER_VERSION_NOT_SUPPORTED,
      // NJS-138
      "connections to this database server version are not supported by node-oracledb in Thin mode"
    );
    messages.set(
      ERR_UNEXPECTED_XML_TYPE,
      // NJS-139
      "unexpected XML type with flag %d"
    );
    messages.set(
      ERR_WRONG_USER_FORMAT_EXTAUTH_PROXY,
      // NJS-140
      "user name must be enclosed in [] when using external authentication with a proxy user"
    );
    messages.set(
      ERR_TOO_MANY_BATCH_ERRORS,
      // NJS-141
      "the number of batch errors from executemany() exceeds 65535"
    );
    messages.set(
      ERR_WRONG_LENGTH_FOR_DBOBJECT_ATTR,
      // NJS-142
      "value too large for attribute %s of object %s (actual: %d, maximum: %d)"
    );
    messages.set(
      ERR_WRONG_LENGTH_FOR_DBOBJECT_ELEM,
      // NJS-143
      "value too large for element %d of object %s (actual: %d, maximum: %d)"
    );
    messages.set(
      ERR_VECTOR_FORMAT_NOT_SUPPORTED,
      // NJS-144
      "VECTOR format %d is not supported"
    );
    messages.set(
      ERR_VECTOR_VERSION_NOT_SUPPORTED,
      // NJS-145
      "VECTOR version %d is not supported"
    );
    messages.set(
      ERR_OBJECT_IS_NOT_A_COLLECTION,
      // NJS-146
      "object %s is not a collection"
    );
    messages.set(
      ERR_CURSOR_HAS_BEEN_CLOSED,
      // NJS-147
      "cursor has been closed by the database"
    );
    messages.set(
      ERR_DML_RETURNING_DUP_BINDS,
      // NJS-149
      'the bind variable placeholder "%s" cannot be used both before and after the RETURNING clause in a DML RETURNING statement'
    );
    messages.set(
      ERR_INVALID_TPC_BEGIN_FLAGS,
      // NJS-150
      "invalid flags for tpcBegin() in Two Phase Commit"
    );
    messages.set(
      ERR_INVALID_TPC_END_FLAGS,
      // NJS-151
      "invalid flags for tpcEnd() in Two Phase Commit"
    );
    messages.set(
      ERR_UNKNOWN_TRANSACTION_STATE,
      // NJS-152
      "internal error: unknown transaction state {state} in Two Phase Commit"
    );
    messages.set(
      ERR_INVALID_TRANSACTION_SIZE,
      // NJS-153
      "size of the transaction ID must be non-zero and must not exceed 64. Its current size is %d."
    );
    messages.set(
      ERR_INVALID_BRANCH_SIZE,
      // NJS-154
      "size of the branch ID is %d and cannot exceed 64"
    );
    messages.set(
      ERR_OPERATION_NOT_SUPPORTED_ON_BFILE,
      // NJS-155
      "operation is not supported on BFILE LOBs"
    );
    messages.set(
      ERR_OPERATION_ONLY_SUPPORTED_ON_BFILE,
      // NJS-156
      "operation is only supported on BFILE LOBs"
    );
    messages.set(
      ERR_EXECMANY_NOT_ALLOWED_ON_QUERIES,
      // NJS-157
      "executeMany() cannot be used with SELECT statement or WITH SQL clause"
    );
    messages.set(
      ERR_VECTOR_SPARSE_INDICES_IS_NOT_ARRAY,
      // NJS-158
      "SPARSE VECTOR indices is not Uint32Array or an Array"
    );
    messages.set(
      ERR_VECTOR_SPARSE_VALUES_IS_NOT_ARRAY,
      // NJS-159
      "SPARSE VECTOR values is not an Array"
    );
    messages.set(
      ERR_VECTOR_SPARSE_DIMS_IS_NOT_INTEGER,
      // NJS-160
      "SPARSE VECTOR dimensions is not an Positive Integer"
    );
    messages.set(
      ERR_VECTOR_SPARSE_INDICES_VALUES_NOT_EQUAL,
      // NJS-161
      "SPARSE VECTOR indices and values must be of same length"
    );
    messages.set(
      ERR_VECTOR_SPARSE_INVALID_JSON,
      // NJS-162
      "SPARSE VECTOR string data is not valid JSON"
    );
    messages.set(
      ERR_VECTOR_SPARSE_INVALID_STRING,
      // NJS-163
      "SPARSE VECTOR string data Array should have exactly 3 elements"
    );
    messages.set(
      ERR_VECTOR_SPARSE_INVALID_INPUT,
      // NJS-164
      "SPARSE VECTOR Invalid Input Data"
    );
    messages.set(
      ERR_VECTOR_SPARSE_INDICES_ELEM_IS_NOT_VALID,
      // NJS-165
      "SPARSE VECTOR indices element at index %d is not valid"
    );
    messages.set(
      ERR_DB_FETCH_TYPE_HANDLER_CONVERTER,
      // NJS-166
      'DBFetchTypeHandler return value attribute "converter" must be a function'
    );
    messages.set(
      ERR_DB_FETCH_TYPE_HANDLER_RETURN_VALUE,
      // NJS-167
      "DBFetchTypeHandler return value must be an object"
    );
    messages.set(
      ERR_ACCESS_TOKEN,
      // NJS-168
      "access token function failed."
    );
    messages.set(
      ERR_CALLOUT_FN,
      // NJS-169
      "External function call failed."
    );
    messages.set(
      ERR_SESSIONLESS_DIFFERING_METHODS,
      //NJS-170
      "Different ways to start or suspend sessionless transactions are being used(server procedures and client APIs)"
    );
    messages.set(
      ERR_SESSIONLESS_ALREADY_ACTIVE,
      //NJS-171
      "Suspend, commit or rollback the currently active sessionless transaction before beginning or resuming another one."
    );
    messages.set(
      ERR_SESSIONLESS_INACTIVE,
      //NJS-172
      "No sessionless transaction is active"
    );
    messages.set(
      ERR_INVALID_SERVER_RESPONSE,
      //NJS-173
      "Invalid server response to connection request"
    );
    messages.set(
      ERR_PAYLOAD_CANNOT_BE_ENQUEUED,
      // NJS-174
      "Payload cannot be enqueued since it does not match the payload type supported by the queue"
    );
    messages.set(
      ERR_CONNECTION_CLOSED,
      // NJS-500
      "connection to Oracle Database was closed or broken"
    );
    messages.set(
      ERR_CONNECTION_LOSTCONTACT,
      // NJS-501
      "connection to host %s port %d terminated unexpectedly. (CONNECTION_ID=%s)\n%s"
    );
    messages.set(
      ERR_CONNECTION_INCOMPLETE,
      // NJS-503
      "connection to host %s port %d could not be established. (CONNECTION_ID=%s)\n%s"
    );
    messages.set(
      ERR_PROXY_CONNECTION_FAILURE,
      // NJS-504
      "connection establishment through a web proxy at host %s port %d failed. (CONNECTION_ID=%s)\n%s"
    );
    messages.set(
      ERR_TLS_INIT_FAILURE,
      // NJS-505
      "unable to initiate TLS connection. Please check if wallet credentials are valid\n%s"
    );
    messages.set(
      ERR_TLS_AUTH_FAILURE,
      // NJS-506
      "connection to host %s port %d encountered TLS handshake failure. (CONNECTION_ID=%s)\n%s"
    );
    messages.set(
      ERR_TLS_DNMATCH_FAILURE,
      // NJS-507
      "TLS detected an invalid certificate. Server DN in certificate does not match the specified DN"
    );
    messages.set(
      ERR_TLS_HOSTMATCH_FAILURE,
      // NJS-508
      "TLS detected an invalid certificate. %s not present in certificate"
    );
    messages.set(
      ERR_INVALID_PACKET,
      // NJS-509
      "internal error: invalid packet type or malformed packet received"
    );
    messages.set(
      ERR_CONNECTION_TIMEDOUT,
      // NJS-510
      'connection to host %s port %d timed out. Request exceeded "%s" of %d seconds. (CONNECTION_ID=%s)'
    );
    messages.set(
      ERR_CONNECTION_REFUSED,
      // NJS-511
      "connection to listener at host %s port %d was refused. (CONNECTION_ID=%s)\nCause: %s"
    );
    messages.set(
      ERR_INVALID_CONNECT_STRING_PARAMETERS,
      // NJS-512
      "invalid connection string parameters.\n%s"
    );
    messages.set(
      ERR_CONNECTION_INBAND,
      // NJS-513
      "error received through in-band notification: %s"
    );
    messages.set(
      ERR_INVALID_CONNECT_STRING_SYNTAX,
      // NJS-514
      "syntax error in connection string"
    );
    messages.set(
      ERR_INVALID_EZCONNECT_SYNTAX,
      // NJS-515
      "error in Easy Connect connection string: %s: %s"
    );
    messages.set(
      ERR_NO_CONFIG_DIR,
      // NJS-516
      "no configuration directory set or available to search for tnsnames.ora"
    );
    messages.set(
      ERR_TNS_ENTRY_NOT_FOUND,
      // NJS-517
      'cannot connect to Oracle Database. Unable to find "%s" in "%s"'
    );
    messages.set(
      ERR_INVALID_SERVICE_NAME,
      // NJS-518
      'cannot connect to Oracle Database. Service "%s" is not registered with the listener at host %s port %s. (CONNECTION_ID=%s)'
    );
    messages.set(
      ERR_INVALID_SID,
      // NJS-519
      'cannot connect to Oracle Database. SID "%s" is not registered with the listener at host %s port %s. (CONNECTION_ID=%s)'
    );
    messages.set(
      ERR_TNS_NAMES_FILE_MISSING,
      // NJS-520
      "cannot connect to Oracle Database. File tnsnames.ora not found in %s"
    );
    messages.set(
      ERR_CONNECTION_EOF,
      // NJS-521
      "connection to host %s port %d received end-of-file on communication channel. (CONNECTION_ID=%s)"
    );
    messages.set(
      ERR_CONFIG_PROVIDER_FAILED_TO_RETRIEVE_CONFIG,
      // NJS-523
      "Failed to retrieve configuration from Centralized Configuration Provider:\n %s"
    );
    messages.set(
      ERR_REGISTER_HOOKFN_CONFIGPROVIDER,
      // NJS-524
      "%s Configuration provider plugin not registered. Please register the hook function for the same"
    );
    messages.set(
      ERR_WALLET_TYPE_NOT_SUPPORTED,
      // NJS-529
      "Invalid wallet content format. Supported format is PEM"
    );
    messages.set(
      ERR_HOST_NOT_FOUND,
      // NJS-530
      "The host addresses or URLs provided by the connect string are incorrect or unresolvable in your network."
    );
    messages.set(
      ERR_ANO_PACKET,
      // NJS-531
      "Error in Advanced Networking Option packet received from the server"
    );
    messages.set(
      ERR_ANO_STATUS,
      // NJS-532
      "%s service recieved status failure"
    );
    messages.set(
      ERR_ANO_NEGOTIATION,
      // NJS-533
      "Advanced Networking Option service negotiation failed. Native Network Encryption and DataIntegrity only supported in node-oracledb thick mode.\nCause: ORA-%s"
    );
    messages.set(ERR_DATA_COMPRESSION, "Error during data compression/decompression: %s\n");
    messages.set(
      ERR_CONFIG_PROVIDER_PARAM_TYPE,
      // NJS-535
      "Parameter does not have a valid type: %s\n"
    );
    messages.set(
      WRN_COMPILATION_CREATE,
      // NJS-700
      "creation succeeded with compilation errors"
    );
    function assert(condition) {
      if (!condition) {
        const args = Array.prototype.slice.call(arguments, 1);
        throwErr(...args);
      }
    }
    function assertArgCount(args, minArgCount, maxArgCount) {
      assert(
        args.length >= minArgCount && args.length <= maxArgCount,
        ERR_INVALID_NUMBER_OF_PARAMETERS,
        args.length,
        minArgCount,
        maxArgCount
      );
    }
    function assertParamPropBool(obj, parameterNum, propName) {
      if (obj[propName] !== void 0) {
        assertParamPropValue(
          typeof obj[propName] === "boolean",
          parameterNum,
          propName
        );
      }
    }
    function assertParamPropFunction(obj, parameterNum, propName) {
      if (obj[propName] !== void 0) {
        assertParamPropValue(
          typeof obj[propName] === "function",
          parameterNum,
          propName
        );
      }
    }
    function assertParamPropInt(obj, parameterNum, propName) {
      if (obj[propName] !== void 0) {
        assertParamPropValue(
          Number.isInteger(obj[propName]),
          parameterNum,
          propName
        );
      }
    }
    function assertParamPropUnsignedInt(obj, parameterNum, propName) {
      if (obj[propName] !== void 0) {
        assertParamPropValue(
          Number.isInteger(obj[propName]) && obj[propName] >= 0,
          parameterNum,
          propName
        );
      }
    }
    function assertParamPropUnsignedIntNonZero(obj, parameterNum, propName) {
      if (obj[propName] !== void 0) {
        assertParamPropValue(
          Number.isInteger(obj[propName]) && obj[propName] > 0,
          parameterNum,
          propName
        );
      }
    }
    function assertParamPropString(obj, parameterNum, propName) {
      if (obj[propName] !== void 0) {
        assertParamPropValue(
          typeof obj[propName] === "string",
          parameterNum,
          propName
        );
      }
    }
    function assertParamPropValue(condition, parameterNum, propName) {
      assert(
        condition,
        ERR_INVALID_PROPERTY_VALUE_IN_PARAM,
        propName,
        parameterNum
      );
    }
    function assertParamValue(condition, parameterNum) {
      assert(condition, ERR_INVALID_PARAMETER_VALUE, parameterNum);
    }
    function assertPropValue(condition, propName) {
      assert(condition, ERR_INVALID_PROPERTY_VALUE, propName);
    }
    function getErr(errorNum) {
      let baseText = messages.get(errorNum);
      let args = [...arguments];
      if (!baseText) {
        args = [void 0, errorNum];
        errorNum = ERR_INVALID_ERR_NUM;
        baseText = messages.get(errorNum);
      }
      const errorNumStr = errorNum.toString().padStart(3, "0");
      const code = `${ERR_PREFIX}-${errorNumStr}`;
      args[0] = `${code}: ${baseText}`;
      const err = new Error(util.format(...args));
      err.code = code;
      err.isRecoverable = errorNum === ERR_CONNECTION_CLOSED;
      Error.captureStackTrace(err, getErr);
      return err;
    }
    function throwErr() {
      throw getErr(...arguments);
    }
    function throwErrWithORAError() {
      const err = getErr(...arguments);
      const pos = err.message.indexOf("ORA-");
      const oraError = err.message.substring(pos + 4, pos + 9);
      err.message = err.message + "\nHelp: https://docs.oracle.com/error-help/db/ora-" + oraError;
      throw err;
    }
    function throwNotImplemented(feature) {
      throwErr(ERR_NOT_IMPLEMENTED, feature);
    }
    function transformErr(err, fnOpt) {
      if (!err.code) {
        const pos = err.message.indexOf(":");
        if (pos > 0) {
          err.code = err.message.substr(0, pos);
          const settings = require_settings();
          if (err.errorNum && settings.thin) {
            err.message += `
Help: https://docs.oracle.com/error-help/db/ora-${err.errorNum.toString().padStart(5, "0")}/`;
          }
          if (adjustErrorXref.has(err.code)) {
            let args = [];
            let driverErrorNum;
            const driverErrorInfo = adjustErrorXref.get(err.code);
            if (typeof driverErrorInfo === "number") {
              driverErrorNum = driverErrorInfo;
            } else {
              driverErrorNum = driverErrorInfo[0];
              const pattern = driverErrorInfo[1];
              const results = err.message.match(pattern);
              if (results) {
                args = results.slice(1);
              }
            }
            const newErr = getErr(driverErrorNum, ...args);
            err.code = newErr.code;
            err.message = newErr.message + "\n" + err.message;
          }
        }
      }
      if (err.requiresStackCapture) {
        delete err.requiresStackCapture;
        Error.captureStackTrace(err, fnOpt);
      }
      return err;
    }
    function throwWrapErr(err, fnOpt) {
      const newErr = getErr(fnOpt);
      newErr.stack = err.stack;
      throw newErr;
    }
    module2.exports = {
      ERR_INTEGRITY_ERROR_CODES,
      ERR_INVALID_POOL,
      ERR_INVALID_CONNECTION,
      ERR_INVALID_PROPERTY_VALUE,
      ERR_INVALID_PARAMETER_VALUE,
      ERR_INVALID_PROPERTY_VALUE_IN_PARAM,
      ERR_INVALID_NUMBER_OF_PARAMETERS,
      ERR_UNSUPPORTED_DATA_TYPE,
      ERR_BIND_VALUE_AND_TYPE_MISMATCH,
      ERR_INVALID_BIND_DATA_TYPE,
      ERR_INVALID_BIND_DIRECTION,
      ERR_NO_TYPE_FOR_CONVERSION,
      ERR_INSUFFICIENT_BUFFER_FOR_BINDS,
      ERR_BUSY_RS,
      ERR_INVALID_RS,
      ERR_NOT_A_QUERY,
      ERR_INVALID_TYPE_FOR_CONVERSION,
      ERR_INVALID_LOB,
      ERR_BUSY_LOB,
      ERR_INSUFFICIENT_MEMORY,
      ERR_INVALID_TYPE_FOR_ARRAY_BIND,
      ERR_REQUIRED_MAX_ARRAY_SIZE,
      ERR_INVALID_ARRAY_SIZE,
      ERR_INCOMPATIBLE_TYPE_ARRAY_BIND,
      ERR_CONN_REQUEST_TIMEOUT,
      ERR_CANNOT_CONVERT_RS_TO_STREAM,
      ERR_CANNOT_INVOKE_RS_METHODS,
      ERR_RS_ALREADY_CONVERTED,
      ERR_INVALID_BIND_UNIT,
      ERR_CANNOT_LOAD_BINARY,
      ERR_POOL_WITH_ALIAS_ALREADY_EXISTS,
      ERR_POOL_WITH_ALIAS_NOT_FOUND,
      ERR_INCOMPATIBLE_TYPE_ARRAY_INDEX_BIND,
      ERR_MIXED_BIND,
      ERR_MISSING_MAX_SIZE_BY_POS,
      ERR_MISSING_MAX_SIZE_BY_NAME,
      ERR_MAX_SIZE_TOO_SMALL,
      ERR_MISSING_TYPE_BY_POS,
      ERR_MISSING_TYPE_BY_NAME,
      ERR_INVALID_SUBSCR,
      ERR_MISSING_SUBSCR_CALLBACK,
      ERR_MISSING_SUBSCR_SQL,
      ERR_POOL_CLOSING,
      ERR_POOL_CLOSED,
      ERR_INVALID_SODA_DOC_CURSOR,
      ERR_NO_BINARY_AVAILABLE,
      ERR_INVALID_ERR_NUM,
      ERR_NODE_TOO_OLD,
      ERR_INVALID_AQ_MESSAGE,
      ERR_DBL_CONNECT_STRING,
      ERR_QUEUE_MAX_EXCEEDED,
      ERR_UNSUPPORTED_DATA_TYPE_IN_JSON,
      ERR_DBL_USER,
      ERR_CONCURRENT_OPS,
      ERR_POOL_RECONFIGURING,
      ERR_POOL_STATISTICS_DISABLED,
      ERR_TOKEN_BASED_AUTH,
      ERR_POOL_TOKEN_BASED_AUTH,
      ERR_CONN_TOKEN_BASED_AUTH,
      ERR_TOKEN_HAS_EXPIRED,
      ERR_NOT_IMPLEMENTED,
      ERR_INIT_ORACLE_CLIENT_ARGS,
      ERR_MISSING_FILE,
      ERR_INVALID_NUMBER_OF_CONNECTIONS,
      ERR_EXEC_MODE_ONLY_FOR_DML,
      ERR_CONNECTION_CLOSED,
      ERR_CONNECTION_LOSTCONTACT,
      ERR_CONNECTION_INCOMPLETE,
      ERR_PROXY_CONNECTION_FAILURE,
      ERR_TLS_INIT_FAILURE,
      ERR_TLS_AUTH_FAILURE,
      ERR_TLS_DNMATCH_FAILURE,
      ERR_TLS_HOSTMATCH_FAILURE,
      ERR_INVALID_PACKET,
      ERR_CONNECTION_TIMEDOUT,
      ERR_CONNECTION_REFUSED,
      ERR_INVALID_CONNECT_STRING_PARAMETERS,
      ERR_CONNECTION_INBAND,
      ERR_INVALID_CONNECT_STRING_SYNTAX,
      ERR_INVALID_EZCONNECT_SYNTAX,
      ERR_NO_CONFIG_DIR,
      ERR_TNS_ENTRY_NOT_FOUND,
      ERR_CONNECTION_EOF,
      ERR_CONFIG_PROVIDER_FAILED_TO_RETRIEVE_CONFIG,
      ERR_CONFIG_PROVIDER_PARAM_TYPE,
      ERR_REGISTER_HOOKFN_CONFIGPROVIDER,
      ERR_DATA_COMPRESSION,
      ERR_WALLET_TYPE_NOT_SUPPORTED,
      ERR_HOST_NOT_FOUND,
      ERR_ANO_PACKET,
      ERR_ANO_STATUS,
      ERR_ANO_NEGOTIATION,
      ERR_INVALID_BIND_NAME,
      ERR_WRONG_NUMBER_OF_BINDS,
      ERR_BUFFER_LENGTH_INSUFFICIENT,
      ERR_NCHAR_CS_NOT_SUPPORTED,
      ERR_MISSING_CREDENTIALS,
      ERR_UNEXPECTED_END_OF_DATA,
      ERR_UNEXPECTED_MESSAGE_TYPE,
      ERR_POOL_HAS_BUSY_CONNECTIONS,
      ERR_INTERNAL,
      ERR_INVALID_REF_CURSOR,
      ERR_UNSUPPORTED_VERIFIER_TYPE,
      ERR_NAN_VALUE,
      ERR_ORACLE_NUMBER_NO_REPR,
      ERR_INVALID_SERVICE_NAME,
      ERR_INVALID_SID,
      ERR_TNS_NAMES_FILE_MISSING,
      ERR_INVALID_TYPE_NUM,
      ERR_INVALID_ORACLE_TYPE_NUM,
      ERR_UNEXPECTED_NEGATIVE_INTEGER,
      ERR_INTEGER_TOO_LARGE,
      ERR_UNEXPECTED_DATA,
      ERR_OSON_FIELD_NAME_LIMITATION,
      ERR_OSON_VERSION_NOT_SUPPORTED,
      ERR_THIN_CONNECTION_ALREADY_CREATED,
      ERR_UNSUPPORTED_CONVERSION,
      ERR_FETCH_TYPE_HANDLER_RETURN_VALUE,
      ERR_FETCH_TYPE_HANDLER_TYPE,
      ERR_FETCH_TYPE_HANDLER_CONVERTER,
      ERR_CALL_TIMEOUT_EXCEEDED,
      ERR_EMPTY_CONNECT_STRING,
      ERR_UNKOWN_SERVER_SIDE_PIGGYBACK,
      ERR_UNKNOWN_COLUMN_TYPE_NAME,
      ERR_INVALID_OBJECT_TYPE_NAME,
      ERR_TDS_TYPE_NOT_SUPPORTED,
      ERR_INVALID_COLL_INDEX_SET,
      ERR_INVALID_COLL_INDEX_GET,
      ERR_DELETE_ELEMENTS_OF_VARRAY,
      ERR_WRONG_VALUE_FOR_DBOBJECT_ATTR,
      ERR_WRONG_VALUE_FOR_DBOBJECT_ELEM,
      ERR_WRONG_CRED_FOR_EXTAUTH,
      ERR_MISSING_BIND_VALUE,
      ERR_SERVER_VERSION_NOT_SUPPORTED,
      ERR_UNEXPECTED_XML_TYPE,
      ERR_WRONG_USER_FORMAT_EXTAUTH_PROXY,
      ERR_TOO_MANY_BATCH_ERRORS,
      ERR_WRONG_LENGTH_FOR_DBOBJECT_ATTR,
      ERR_WRONG_LENGTH_FOR_DBOBJECT_ELEM,
      ERR_VECTOR_FORMAT_NOT_SUPPORTED,
      ERR_VECTOR_VERSION_NOT_SUPPORTED,
      ERR_OBJECT_IS_NOT_A_COLLECTION,
      ERR_CURSOR_HAS_BEEN_CLOSED,
      ERR_DML_RETURNING_DUP_BINDS,
      ERR_INVALID_TPC_BEGIN_FLAGS,
      ERR_INVALID_TPC_END_FLAGS,
      ERR_UNKNOWN_TRANSACTION_STATE,
      ERR_INVALID_TRANSACTION_SIZE,
      ERR_INVALID_BRANCH_SIZE,
      ERR_SESSIONLESS_DIFFERING_METHODS,
      ERR_SESSIONLESS_ALREADY_ACTIVE,
      ERR_SESSIONLESS_INACTIVE,
      ERR_INVALID_SERVER_RESPONSE,
      ERR_PAYLOAD_CANNOT_BE_ENQUEUED,
      ERR_CONNECTION_CLOSED_CODE: `${ERR_PREFIX}-${ERR_CONNECTION_CLOSED}`,
      ERR_OPERATION_NOT_SUPPORTED_ON_BFILE,
      ERR_OPERATION_ONLY_SUPPORTED_ON_BFILE,
      ERR_EXECMANY_NOT_ALLOWED_ON_QUERIES,
      ERR_VECTOR_SPARSE_INDICES_IS_NOT_ARRAY,
      ERR_VECTOR_SPARSE_VALUES_IS_NOT_ARRAY,
      ERR_VECTOR_SPARSE_DIMS_IS_NOT_INTEGER,
      ERR_VECTOR_SPARSE_INDICES_VALUES_NOT_EQUAL,
      ERR_VECTOR_SPARSE_INVALID_JSON,
      ERR_VECTOR_SPARSE_INVALID_STRING,
      ERR_VECTOR_SPARSE_INVALID_INPUT,
      ERR_VECTOR_SPARSE_INDICES_ELEM_IS_NOT_VALID,
      ERR_DB_FETCH_TYPE_HANDLER_CONVERTER,
      ERR_DB_FETCH_TYPE_HANDLER_RETURN_VALUE,
      ERR_ACCESS_TOKEN,
      ERR_CALLOUT_FN,
      WRN_COMPILATION_CREATE,
      assert,
      assertArgCount,
      assertParamPropBool,
      assertParamPropFunction,
      assertParamPropInt,
      assertParamPropString,
      assertParamPropUnsignedInt,
      assertParamPropUnsignedIntNonZero,
      assertParamPropValue,
      assertParamValue,
      assertPropValue,
      getErr,
      throwErr,
      throwErrWithORAError,
      throwNotImplemented,
      transformErr,
      throwWrapErr
    };
  }
});

// node_modules/oracledb/lib/traceHandler.js
var require_traceHandler = __commonJS({
  "node_modules/oracledb/lib/traceHandler.js"(exports2, module2) {
    "use strict";
    var TraceHandlerBase = class {
      constructor() {
        this._config = {};
      }
      // check if sending traces is enabled.
      isEnabled() {
        return this._config.enable;
      }
      // Enable sending traces
      enable() {
        this._config.enable = true;
      }
      // Disable sending traces
      disable() {
        this._config.enable = false;
      }
      // It is called before invoking a public async method.
      onEnterFn() {
      }
      // It is called after invoking a public async method.
      // The same traceContext object passed inside onEnterFn
      // will be passed in this function.
      onExitFn() {
      }
      // called when a round trip is begun
      // OpenTelemetry will start a new span as a child of the public API span.
      onBeginRoundTrip() {
      }
      // called when a round trip has ended
      // OpenTelemetry will end the span
      // The same traceContext object passed inside onBeginRoundTrip
      // is passed here.
      onEndRoundTrip() {
      }
    };
    var _currentTraceObject;
    function setTraceInstance(obj) {
      _currentTraceObject = obj;
    }
    function getTraceInstance() {
      return _currentTraceObject;
    }
    function isEnabled() {
      return _currentTraceObject?.isEnabled();
    }
    module2.exports = {
      // class
      TraceHandlerBase,
      // methods
      setTraceInstance,
      getTraceInstance,
      isEnabled
    };
  }
});

// node_modules/oracledb/package.json
var require_package = __commonJS({
  "node_modules/oracledb/package.json"(exports2, module2) {
    module2.exports = {
      name: "oracledb",
      version: "6.10.0",
      description: "A Node.js module for Oracle Database access from JavaScript and TypeScript",
      license: "(Apache-2.0 OR UPL-1.0)",
      homepage: "http://oracle.github.io/node-oracledb/",
      keywords: [
        "Oracle",
        "Database",
        "official",
        "DB",
        "SQL",
        "JSON",
        "PL/SQL",
        "SODA",
        "OCI",
        "API",
        "client",
        "library",
        "driver",
        "add-on",
        "extension",
        "binding",
        "interface",
        "adapter",
        "module"
      ],
      repository: {
        type: "git",
        url: "git://github.com/oracle/node-oracledb.git"
      },
      scripts: {
        install: "node package/install.js",
        prune: "node package/prunebinaries.js"
      },
      engines: {
        node: ">=14.17"
      },
      maintainers: [
        {
          name: "Oracle Corp."
        }
      ],
      bugs: {
        url: "https://github.com/oracle/node-oracledb/issues"
      },
      main: "./index.js"
    };
  }
});

// node_modules/oracledb/lib/util.js
var require_util = __commonJS({
  "node_modules/oracledb/lib/util.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var errors = require_errors();
    var process2 = require("process");
    var util = require("util");
    var types = require_types();
    var constants = require_constants();
    var traceHandler = require_traceHandler();
    var crypto = require("crypto");
    var pemHeaders = [
      "-----BEGIN CERTIFICATE-----",
      "-----BEGIN PUBLIC KEY-----",
      "-----BEGIN PRIVATE KEY-----",
      "-----BEGIN RSA PRIVATE KEY-----",
      "-----BEGIN DSA PRIVATE KEY-----",
      "-----BEGIN EC PRIVATE KEY-----",
      "-----BEGIN ENCRYPTED PRIVATE KEY-----"
    ];
    var pemFooters = [
      "-----END CERTIFICATE-----",
      "-----END PUBLIC KEY-----",
      "-----END PRIVATE KEY-----",
      "-----END RSA PRIVATE KEY-----",
      "-----END DSA PRIVATE KEY-----",
      "-----END EC PRIVATE KEY-----",
      "-----END ENCRYPTED PRIVATE KEY-----"
    ];
    var validNetworkCharacterSet = /* @__PURE__ */ new Set([
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "<",
      ">",
      "/",
      "\\",
      ",",
      ".",
      ":",
      ";",
      "'",
      '"',
      "-",
      "_",
      "$",
      "+",
      "*",
      "#",
      "&",
      "!",
      "%",
      "?",
      "@"
    ]);
    var packageJSON;
    try {
      packageJSON = require_package();
    } catch (err) {
      errors.throwErr(errors.ERR_MISSING_FILE, "package.json");
    }
    var PACKAGE_JSON_VERSION = packageJSON.version;
    var RELEASE_DIR = "build/Release";
    var BINARY_FILE = "oracledb-" + PACKAGE_JSON_VERSION + "-" + process2.platform + "-" + process2.arch + ".node";
    var BUILD_FILE = "oracledb.node";
    var STAGING_DIR = "package/Staging";
    function assertParamPropNetworkName(obj, parameterNum, propName) {
      errors.assertParamPropString(obj, parameterNum, propName);
      const sanitizedValue = sanitize(obj[propName]);
      errors.assertParamPropValue(obj[propName] === sanitizedValue, parameterNum, propName);
    }
    function getInstallURL() {
      return "Node-oracledb installation instructions: https://node-oracledb.readthedocs.io/en/latest/user_guide/installation.html";
    }
    function isPemFile(content) {
      content = content.trim();
      return pemHeaders.some((header) => content.includes(header)) && pemFooters.some((footer) => content.endsWith(footer));
    }
    function getInstallHelp() {
      let arch, url;
      let mesg = getInstallURL() + "\n";
      if (process2.platform === "linux") {
        if (process2.arch === "x64") {
          url = "https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html\n";
          arch = "64-bit";
        } else if (process2.arch === "x32") {
          url = "https://www.oracle.com/database/technologies/instant-client/linux-x86-32-downloads.html\n";
          arch = "32-bit";
        } else {
          url = "https://www.oracle.com/database/technologies/instant-client.html\n";
          arch = process2.arch;
        }
        mesg += "You must have Linux " + arch + " Oracle Client libraries configured with ldconfig, or in LD_LIBRARY_PATH.\n";
        mesg += "If you do not have Oracle Database on this computer, then install the Instant Client Basic or Basic Light package from \n";
        mesg += url;
      } else if (process2.platform === "darwin") {
        if (process2.arch === "x64") {
          url = "https://www.oracle.com/database/technologies/instant-client/macos-intel-x86-downloads.html\n";
          arch = "64-bit";
        } else {
          url = "https://www.oracle.com/database/technologies/instant-client.html\n";
          arch = process2.arch;
        }
        mesg += "You must have macOS " + arch + " Oracle Instant Client Basic or Basic Light package libraries in\n";
        mesg += '/usr/local/lib or set by calling oracledb.initOracleClient({libDir: "/my/instant_client_directory"}).\n';
        mesg += "Oracle Instant Client can be downloaded from " + url;
      } else if (process2.platform === "win32") {
        if (process2.arch === "x64") {
          url = "https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html\n";
          arch = "64-bit";
        } else if (process2.arch === "x32") {
          url = "https://www.oracle.com/database/technologies/instant-client/microsoft-windows-32-downloads.html\n";
          arch = "32-bit";
        } else {
          url = "https://www.oracle.com/database/technologies/instant-client.html\n";
          arch = process2.arch;
        }
        mesg += "You must have Windows " + arch + " Oracle Client libraries in your PATH environment variable.\n";
        mesg += "If you do not have Oracle Database on this computer, then install the Instant Client Basic or Basic Light package from\n";
        mesg += url;
        mesg += "A Microsoft Visual Studio Redistributable suitable for your Oracle client library version must be available.\n";
      } else {
        url = "https://www.oracle.com/database/technologies/instant-client.html\n";
        mesg += "You must have " + process2.arch + " Oracle Client libraries in your operating system library search path.\n";
        mesg += "If you do not have Oracle Database on this computer, then install an Instant Client Basic or Basic Light package from: \n";
        mesg += url;
      }
      return mesg;
    }
    function getOperationName(methodName) {
      const className = this.constructor.name === "Object" ? "oracledb" : `oracledb.${this.constructor.name}`;
      return `${className}.${methodName}`;
    }
    function traceEnterFn(traceContext) {
      if (!traceHandler.isEnabled()) {
        return;
      }
      if (this._impl) {
        this._impl._callLevelTraceData = {};
      }
      traceContext.additionalConfig = {};
      traceContext.additionalConfig.self = this;
      traceContext.additionalConfig.args = traceContext.args;
      traceContext.operation = getOperationName.call(this, traceContext.fn.name);
      traceContext.connectLevelConfig = this._impl?._getConnectTraceConfig();
      traceHandler.getTraceInstance().onEnterFn(traceContext);
    }
    function traceExitFn(traceContext, result, err) {
      const callExitFn = traceHandler.isEnabled();
      if (!callExitFn) {
        return;
      }
      traceContext.error = err;
      traceContext.additionalConfig.result = result;
      if (this._impl) {
        traceContext.callLevelConfig = this._impl._callLevelTraceData;
      }
      if (["oracledb.getConnection", "oracledb.createPool"].includes(traceContext.operation)) {
        if (err) {
          if (traceContext.args && traceContext.args.length >= 1) {
            const config = {};
            const inp = traceContext.args[0];
            config.user = inp.user || inp.username;
            config.connectString = inp.connectString || inp.connectionString;
            traceContext.connectLevelConfig = config;
          }
        } else {
          traceContext.connectLevelConfig = result._impl._getConnectTraceConfig();
        }
      } else if (traceContext.operation === "oracledb.Pool.getConnection") {
        if (!err) {
          traceContext.connectLevelConfig = result._impl._getConnectTraceConfig();
        }
      }
      traceHandler.getTraceInstance().onExitFn(traceContext);
      if (this._impl) {
        this._impl._callLevelTraceData = void 0;
      }
    }
    function callbackify(func) {
      const wrapper = function() {
        if (typeof arguments[arguments.length - 1] !== "function") {
          return func.apply(this, arguments);
        }
        const args = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
        const cb = arguments[arguments.length - 1];
        func.apply(this, args).then(function(result) {
          cb(null, result);
        }, cb);
      };
      if (func.name) {
        Object.defineProperty(wrapper, "name", { value: func.name });
      }
      return wrapper;
    }
    function wrapFn(func, serialize, preventConcurrentErrorCode) {
      const wrapper = async function wrapper2() {
        let connImpl;
        const traceEnabled = traceHandler.isEnabled();
        const traceContext = { fn: func, args: arguments };
        if (preventConcurrentErrorCode) {
          if (this._isActive)
            errors.throwErr(preventConcurrentErrorCode);
          this._isActive = true;
        }
        if (serialize && this._impl) {
          connImpl = this._impl._getConnImpl();
          await connImpl._acquireLock();
        }
        let result, tErr;
        try {
          if (traceEnabled) {
            traceEnterFn.call(this, traceContext);
          }
          result = await traceContext.fn.apply(this, arguments);
          return result;
        } catch (err) {
          tErr = errors.transformErr(err, wrapper2);
          throw tErr;
        } finally {
          if (connImpl)
            connImpl._releaseLock();
          if (preventConcurrentErrorCode) {
            this._isActive = false;
          }
          if (traceEnabled) {
            traceExitFn.call(this, traceContext, result, tErr);
          }
        }
      };
      if (func.name) {
        Object.defineProperty(wrapper, "name", { value: func.name });
      }
      return wrapper;
    }
    function wrapFns(proto) {
      let nameIndex = 1;
      let serialize = true;
      let preventConcurrentErrorCode;
      if (typeof arguments[1] === "number") {
        nameIndex++;
        preventConcurrentErrorCode = arguments[1];
      } else if (typeof arguments[1] === "boolean") {
        nameIndex++;
        serialize = arguments[1];
      }
      for (let i = nameIndex; i < arguments.length; i++) {
        const name = arguments[i];
        const f = proto[name];
        proto[name] = callbackify(wrapFn(f, serialize, preventConcurrentErrorCode));
      }
    }
    function isArrayOfStrings(value) {
      if (!Array.isArray(value))
        return false;
      for (let i = 0; i < value.length; i++) {
        if (typeof value[i] !== "string")
          return false;
      }
      return true;
    }
    function isObject(value) {
      return value !== null && typeof value === "object";
    }
    function isObjectOrArray(value) {
      return value !== null && typeof value === "object" || Array.isArray(value);
    }
    function isPrivilege(value) {
      if (value & constants.SYSPRELIM) {
        value = value ^ constants.SYSPRELIM;
      }
      return value === constants.SYSASM || value === constants.SYSBACKUP || value === constants.SYSDBA || value === constants.SYSDG || value === constants.SYSKM || value === constants.SYSOPER || value === constants.SYSRAC;
    }
    function isShardingKey(value) {
      if (!Array.isArray(value))
        return false;
      for (let i = 0; i < value.length; i++) {
        const element = value[i];
        const ok = typeof element === "string" || typeof element === "number" || Buffer2.isBuffer(element) || util.types.isDate(element);
        if (!ok)
          return false;
      }
      return true;
    }
    function isAppContext(value) {
      if (!Array.isArray(value))
        return false;
      for (let i = 0; i < value.length; i++) {
        const element = value[i];
        if (!Array.isArray(element) || element.length !== 3)
          return false;
        for (let j = 0; j < 3; j++) {
          if (typeof element[j] !== "string")
            return false;
        }
      }
      return true;
    }
    function isXid(value) {
      return isObject(value) && Number.isInteger(value.formatId) && (Buffer2.isBuffer(value.globalTransactionId) || typeof value.globalTransactionId === "string") && (Buffer2.isBuffer(value.branchQualifier) || typeof value.branchQualifier === "string");
    }
    function normalizeXid(value) {
      let normalizedXid;
      if (Buffer2.isBuffer(value.globalTransactionId) && Buffer2.isBuffer(value.branchQualifier)) {
        normalizedXid = value;
      } else {
        normalizedXid = {
          formatId: value.formatId,
          globalTransactionId: value.globalTransactionId,
          branchQualifier: value.branchQualifier
        };
        if (typeof value.globalTransactionId === "string") {
          normalizedXid.globalTransactionId = Buffer2.from(value.globalTransactionId);
        }
        if (typeof value.branchQualifier === "string") {
          normalizedXid.branchQualifier = Buffer2.from(value.branchQualifier);
        }
      }
      if (normalizedXid.globalTransactionId.length > 64) {
        errors.throwErr(
          errors.ERR_INVALID_TRANSACTION_SIZE,
          normalizedXid.globalTransactionId.length
        );
      }
      if (normalizedXid.branchQualifier.length > 64) {
        errors.throwErr(
          errors.ERR_INVALID_BRANCH_SIZE,
          normalizedXid.branchQualifier.length
        );
      }
      return normalizedXid;
    }
    function isTransactionId(value) {
      return Buffer2.isBuffer(value) || typeof value === "string";
    }
    function normalizeTransactionId(value) {
      let normalizedTransactionId = value;
      if (normalizedTransactionId === void 0)
        normalizedTransactionId = crypto.randomUUID();
      if (typeof normalizedTransactionId === "string") {
        normalizedTransactionId = Buffer2.from(normalizedTransactionId);
        const len = normalizedTransactionId.length;
        if (len === 0 || len > 64)
          errors.throwErr(errors.ERR_INVALID_TRANSACTION_SIZE, len);
      }
      return normalizedTransactionId;
    }
    function isTokenExpired(token) {
      errors.assert(typeof token === "string", errors.ERR_TOKEN_BASED_AUTH);
      if (token.split(".")[1] === void 0) {
        errors.throwErr(errors.ERR_TOKEN_BASED_AUTH);
      }
      const base64Url = token.split(".")[1];
      const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
      const buff = Buffer2.from(base64, "base64");
      const payloadInit = buff.toString("ascii");
      let expiry = JSON.parse(payloadInit).exp;
      errors.assert(expiry != void 0, errors.ERR_TOKEN_BASED_AUTH);
      expiry = expiry * 1e3;
      return (/* @__PURE__ */ new Date()).getTime() > expiry;
    }
    function isTokenValid(accessToken) {
      switch (typeof accessToken) {
        case "string":
          if (accessToken === "") {
            errors.throwErr(errors.ERR_TOKEN_BASED_AUTH);
          }
          return !isTokenExpired(accessToken);
        case "object":
          if (accessToken.token === void 0 || accessToken.token === "" || accessToken.privateKey === void 0 || accessToken.privateKey === "") {
            errors.throwErr(errors.ERR_TOKEN_BASED_AUTH);
          }
          return !isTokenExpired(accessToken.token);
        default:
          errors.throwErr(errors.ERR_TOKEN_BASED_AUTH);
      }
    }
    function denormalizePrivateKey(privateKey) {
      privateKey = privateKey.replace(/\n/g, "");
      privateKey = privateKey.replace("-----BEGIN PRIVATE KEY-----", "");
      privateKey = privateKey.replace("-----END PRIVATE KEY-----", "");
      return privateKey;
    }
    function addTypeProperties(obj, attrName) {
      const clsAttrName = attrName + "Class";
      const nameAttrName = attrName + "Name";
      const cls = obj[clsAttrName];
      let dbType = obj[attrName];
      if (typeof dbType === "number") {
        dbType = obj[attrName] = types.getTypeByNum(dbType);
      }
      if (cls) {
        obj[nameAttrName] = cls.prototype.fqn;
      } else if (dbType) {
        obj[nameAttrName] = dbType.columnTypeName;
      }
    }
    function isVectorValue(value) {
      return value instanceof Float32Array || value instanceof Float64Array || value instanceof Int8Array || Object.getPrototypeOf(value) === Uint8Array.prototype || value instanceof types.SparseVector;
    }
    function makeDate(useLocal, year, month, day, hour, minute, second, fseconds, offset) {
      if (useLocal) {
        return new Date(year, month - 1, day, hour, minute, second, fseconds);
      }
      return new Date(Date.UTC(
        year,
        month - 1,
        day,
        hour,
        minute,
        second,
        fseconds
      ) - offset * 6e4);
    }
    function sanitize(text) {
      let value = text.split("");
      if (value[0] === "'" || value[0] === '"') {
        value = value.splice(1);
      }
      if (value[value.length - 1] === "'" || value[value.length - 1] === '"') {
        value.pop();
      }
      for (let i = 0; i < value.length; i++) {
        if (!validNetworkCharacterSet.has(value[i])) {
          value[i] = "?";
        }
      }
      if (value[value.length - 1] === "\\") {
        value[value.length - 1] = "?";
      }
      return value.join("");
    }
    module2.exports = {
      BINARY_FILE,
      BUILD_FILE,
      PACKAGE_JSON_VERSION,
      RELEASE_DIR,
      STAGING_DIR,
      addTypeProperties,
      assertParamPropNetworkName,
      callbackify,
      denormalizePrivateKey,
      getInstallURL,
      getInstallHelp,
      isArrayOfStrings,
      isObject,
      isObjectOrArray,
      isPrivilege,
      isShardingKey,
      isAppContext,
      isTokenExpired,
      isTokenValid,
      isTransactionId,
      isVectorValue,
      isXid,
      normalizeTransactionId,
      normalizeXid,
      makeDate,
      sanitize,
      wrapFn,
      wrapFns,
      isPemFile
    };
  }
});

// node_modules/oracledb/lib/impl/aqDeqOptions.js
var require_aqDeqOptions = __commonJS({
  "node_modules/oracledb/lib/impl/aqDeqOptions.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var AqDeqOptionsImpl = class {
      //---------------------------------------------------------------------------
      // getCondition()
      //
      // Returns the condition to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getCondition() {
        errors.throwNotImplemented("getting condition (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // getConsumerName()
      //
      // Returns the consumer name to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getConsumerName() {
        errors.throwNotImplemented("getting consumer name (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // getCorrelation()
      //
      // Returns the correlation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getCorrelation() {
        errors.throwNotImplemented("getting correlation (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // getMode()
      //
      // Returns the mode to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getMode() {
        errors.throwNotImplemented("getting mode (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // getMsgId()
      //
      // Returns the message id to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getMsgId() {
        errors.throwNotImplemented("getting message id (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // getNavigation()
      //
      // Returns the navigation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getNavigation() {
        errors.throwNotImplemented("getting navigation (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // getTransformation()
      //
      // Returns the transformation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getTransformation() {
        errors.throwNotImplemented("getting transformation (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // getVisibility()
      //
      // Returns the visibility to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getVisibility() {
        errors.throwNotImplemented("getting visibility (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // getWait()
      //
      // Returns the wait to use for dequeuing messages.
      //---------------------------------------------------------------------------
      getWait() {
        errors.throwNotImplemented("getting wait (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setCondition()
      //
      // Sets the condition to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setCondition() {
        errors.throwNotImplemented("setting condition (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setConsumerName()
      //
      // Sets the consumer name to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setConsumerName() {
        errors.throwNotImplemented("setting consumer name (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setCorrelation()
      //
      // Sets the correlation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setCorrelation() {
        errors.throwNotImplemented("setting correlation (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setDeliveryMode()
      //
      // Sets the delivery mode to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setDeliveryMode() {
        errors.throwNotImplemented("setting deliveryMode (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setMode()
      //
      // Sets the mode to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setMode() {
        errors.throwNotImplemented("setting mode (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setMsgId()
      //
      // Sets the message id to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setMsgId() {
        errors.throwNotImplemented("setting message id (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setNavigation()
      //
      // Sets the navigation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setNavigation() {
        errors.throwNotImplemented("setting navigation (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setTransformation()
      //
      // Sets the transformation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setTransformation() {
        errors.throwNotImplemented("setting transformation (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setVisibility()
      //
      // Sets the visibility to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setVisibility() {
        errors.throwNotImplemented("setting visibility (dequeue options)");
      }
      //---------------------------------------------------------------------------
      // setWait()
      //
      // Sets the wait to use for dequeuing messages.
      //---------------------------------------------------------------------------
      setWait() {
        errors.throwNotImplemented("setting wait (dequeue options)");
      }
    };
    module2.exports = AqDeqOptionsImpl;
  }
});

// node_modules/oracledb/lib/impl/aqEnqOptions.js
var require_aqEnqOptions = __commonJS({
  "node_modules/oracledb/lib/impl/aqEnqOptions.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var AqEnqOptionsImpl = class {
      //---------------------------------------------------------------------------
      // getDeliveryMode()
      //
      // Returns the delivery mode to use for enqueuing messages.
      //---------------------------------------------------------------------------
      getDeliveryMode() {
        errors.throwNotImplemented("getting delivery mode (enqueue options)");
      }
      //---------------------------------------------------------------------------
      // getTransformation()
      //
      // Returns the transformation to use for enqueuing messages.
      //---------------------------------------------------------------------------
      getTransformation() {
        errors.throwNotImplemented("getting transformation (enqueue options)");
      }
      //---------------------------------------------------------------------------
      // getVisibility()
      //
      // Returns the visibility to use for enqueuing messages.
      //---------------------------------------------------------------------------
      getVisibility() {
        errors.throwNotImplemented("getting visibility (enqueue options)");
      }
      //---------------------------------------------------------------------------
      // setDeliveryMode()
      //
      // Sets the delivery mode to use for enqueuing messages.
      //---------------------------------------------------------------------------
      setDeliveryMode() {
        errors.throwNotImplemented("setting delivery mode (enqueue options)");
      }
      //---------------------------------------------------------------------------
      // setTransformation()
      //
      // Sets the transformation to use for enqueuing messages.
      //---------------------------------------------------------------------------
      setTransformation() {
        errors.throwNotImplemented("setting transformation (enqueue options)");
      }
      //---------------------------------------------------------------------------
      // setVisibility()
      //
      // Sets the visibility to use for enqueuing messages.
      //---------------------------------------------------------------------------
      setVisibility() {
        errors.throwNotImplemented("setting visibility (enqueue options)");
      }
    };
    module2.exports = AqEnqOptionsImpl;
  }
});

// node_modules/oracledb/lib/impl/aqMessage.js
var require_aqMessage = __commonJS({
  "node_modules/oracledb/lib/impl/aqMessage.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var AqMessageImpl = class {
      //---------------------------------------------------------------------------
      // getCorrelation()
      //
      // Returns the correlation associated with the message.
      //---------------------------------------------------------------------------
      getCorrelation() {
        errors.throwNotImplemented("getting correlation (message)");
      }
      //---------------------------------------------------------------------------
      // getDelay()
      //
      // Returns the delay associated with the message.
      //---------------------------------------------------------------------------
      getDelay() {
        errors.throwNotImplemented("getting delay (message)");
      }
      //---------------------------------------------------------------------------
      // getDeliveryMode()
      //
      // Returns the delivery mode associated with the message.
      //---------------------------------------------------------------------------
      getDeliveryMode() {
        errors.throwNotImplemented("getting delivery mode (message)");
      }
      //---------------------------------------------------------------------------
      // getExceptionQueue()
      //
      // Returns the exception queue associated with the message.
      //---------------------------------------------------------------------------
      getExceptionQueue() {
        errors.throwNotImplemented("getting exception queue (message)");
      }
      //---------------------------------------------------------------------------
      // getExpiration()
      //
      // Returns the expiration associated with the message.
      //---------------------------------------------------------------------------
      getExpiration() {
        errors.throwNotImplemented("getting expiration (message)");
      }
      //---------------------------------------------------------------------------
      // getMsgId()
      //
      // Returns the message id associated with the message.
      //---------------------------------------------------------------------------
      getMsgId() {
        errors.throwNotImplemented("getting message id (message)");
      }
      //---------------------------------------------------------------------------
      // getNumAttempts()
      //
      // Returns the number of attempts associated with the message.
      //---------------------------------------------------------------------------
      getNumAttempts() {
        errors.throwNotImplemented("getting number of attempts (message)");
      }
      //---------------------------------------------------------------------------
      // getOriginalMsgId()
      //
      // Returns the original message id associated with the message.
      //---------------------------------------------------------------------------
      getOriginalMsgId() {
        errors.throwNotImplemented("getting original message id (message)");
      }
      //---------------------------------------------------------------------------
      // getPayload()
      //
      // Returns the payload associated with the message.
      //---------------------------------------------------------------------------
      getPayload() {
        errors.throwNotImplemented("getting payload (message)");
      }
      //---------------------------------------------------------------------------
      // getPriority()
      //
      // Returns the priority associated with the message.
      //---------------------------------------------------------------------------
      getPriority() {
        errors.throwNotImplemented("getting priority (message)");
      }
      //---------------------------------------------------------------------------
      // getState()
      //
      // Returns the state associated with the message.
      //---------------------------------------------------------------------------
      getState() {
        errors.throwNotImplemented("getting state (message)");
      }
    };
    module2.exports = AqMessageImpl;
  }
});

// node_modules/oracledb/lib/impl/base.js
var require_base = __commonJS({
  "node_modules/oracledb/lib/impl/base.js"(exports2, module2) {
    "use strict";
    var BaseImpl = class {
      //---------------------------------------------------------------------------
      // _getConnectTraceConfig()
      //
      // Retrieves connect trace config from connection object.
      //---------------------------------------------------------------------------
      _getConnectTraceConfig() {
        const connImpl = this._getConnImpl();
        if (connImpl) {
          return connImpl._getConnectTraceConfig();
        }
      }
    };
    module2.exports = BaseImpl;
  }
});

// node_modules/oracledb/lib/impl/aqQueue.js
var require_aqQueue = __commonJS({
  "node_modules/oracledb/lib/impl/aqQueue.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var BaseImpl = require_base();
    var AqQueueImpl = class extends BaseImpl {
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        return this._connection;
      }
      //---------------------------------------------------------------------------
      // deqMany()
      //
      // Dequeues multiple items from a queue.
      //---------------------------------------------------------------------------
      deqMany() {
        errors.throwNotImplemented("dequeuing multiple items from a queue");
      }
      //---------------------------------------------------------------------------
      // deqOne()
      //
      // Dequeues a single item from a queue.
      //---------------------------------------------------------------------------
      deqOne() {
        errors.throwNotImplemented("dequeuing a single item from a queue");
      }
      //---------------------------------------------------------------------------
      // enqMany()
      //
      // Enqueues multiple items from a queue.
      //---------------------------------------------------------------------------
      enqMany() {
        errors.throwNotImplemented("enqueuing multiple items from a queue");
      }
      //---------------------------------------------------------------------------
      // enqOne()
      //
      // Enqueues a single item from a queue.
      //---------------------------------------------------------------------------
      enqOne() {
        errors.throwNotImplemented("enqueuing a single item from a queue");
      }
    };
    module2.exports = AqQueueImpl;
  }
});

// node_modules/oracledb/lib/impl/dbObject.js
var require_dbObject = __commonJS({
  "node_modules/oracledb/lib/impl/dbObject.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var DbObjectImpl = class {
      constructor(objType) {
        this._objType = objType;
      }
      //---------------------------------------------------------------------------
      // append()
      //
      // Appends an element to the collection.
      //---------------------------------------------------------------------------
      append() {
        errors.throwNotImplemented("appending element to collection");
      }
      //---------------------------------------------------------------------------
      // copy()
      //
      // Creates and returns a copy of the object.
      //---------------------------------------------------------------------------
      copy() {
        errors.throwNotImplemented("copying an object");
      }
      //---------------------------------------------------------------------------
      // deleteElement()
      //
      // Deletes an element from a collection.
      //---------------------------------------------------------------------------
      deleteElement() {
        errors.throwNotImplemented("deleting an element from a collection");
      }
      //---------------------------------------------------------------------------
      // getElement()
      //
      // Returns an element from the collection.
      //---------------------------------------------------------------------------
      getElement() {
        errors.throwNotImplemented("getting an element from a collection");
      }
      //---------------------------------------------------------------------------
      // getFirstIndex()
      //
      // Returns the first index in a collection.
      //---------------------------------------------------------------------------
      getFirstIndex() {
        errors.throwNotImplemented("getting the first index in a collection");
      }
      //---------------------------------------------------------------------------
      // getKeys()
      //
      // Returns the keys of the collection in a JavaScript array.
      //---------------------------------------------------------------------------
      getKeys() {
        errors.throwNotImplemented("returning the keys of a collection");
      }
      //---------------------------------------------------------------------------
      // getLastIndex()
      //
      // Returns the last index in a collection.
      //---------------------------------------------------------------------------
      getLastIndex() {
        errors.throwNotImplemented("getting the last index in a collection");
      }
      //---------------------------------------------------------------------------
      // getNextIndex()
      //
      // Returns the next index in a collection.
      //---------------------------------------------------------------------------
      getNextIndex() {
        errors.throwNotImplemented("getting the next index in a collection");
      }
      //---------------------------------------------------------------------------
      // getPrevIndex()
      //
      // Returns the previous index in a collection.
      //---------------------------------------------------------------------------
      getPrevIndex() {
        errors.throwNotImplemented("getting the previous index in a collection");
      }
      //---------------------------------------------------------------------------
      // getValues()
      //
      // Returns the values of the collection in a JavaScript array.
      //---------------------------------------------------------------------------
      getValues() {
        errors.throwNotImplemented("getting the values in a collection");
      }
      //---------------------------------------------------------------------------
      // hasElement()
      //
      // Returns whether an element exists at the given index.
      //---------------------------------------------------------------------------
      hasElement() {
        errors.throwNotImplemented("getting if value exists in a collection");
      }
      //---------------------------------------------------------------------------
      // setElement()
      //
      // Sets the element at the given index in the collection.
      //---------------------------------------------------------------------------
      setElement() {
        errors.throwNotImplemented("setting an element in a collection");
      }
      //---------------------------------------------------------------------------
      // trim()
      //
      // Trim the specified number of elements from the end of the collection.
      //---------------------------------------------------------------------------
      trim() {
        errors.throwNotImplemented("trimming elements from a collection");
      }
    };
    module2.exports = DbObjectImpl;
  }
});

// node_modules/oracledb/lib/impl/connection.js
var require_connection = __commonJS({
  "node_modules/oracledb/lib/impl/connection.js"(exports2, module2) {
    "use strict";
    var settings = require_settings();
    var errors = require_errors();
    var util = require("util");
    var ConnectionImpl = class {
      constructor() {
        this._inProgress = false;
        this._dbObjectTypes = /* @__PURE__ */ new Map();
        this._requestQueue = [];
        this._osonMaxFieldNameSize = 255;
      }
      //---------------------------------------------------------------------------
      // _acquireLock()
      //
      // Acquire a lock on the connection in order to prevent concurrent use of the
      // connection.
      //---------------------------------------------------------------------------
      async _acquireLock() {
        if (this._inProgress) {
          if (settings.errorOnConcurrentExecute) {
            errors.throwErr(errors.ERR_CONCURRENT_OPS);
          }
          await new Promise((resolve3, reject) => {
            const payload = { resolve: resolve3, reject };
            this._requestQueue.push(payload);
          });
        }
        this._inProgress = true;
      }
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      // ---------------------------------------------------------------------------
      _getConnImpl() {
        return this;
      }
      //---------------------------------------------------------------------------
      // _getConnectTraceConfig()
      //
      // returns the necessary connection config used for debug/trace.
      // ---------------------------------------------------------------------------
      _getConnectTraceConfig() {
        let traceConfig;
        if (this._pool) {
          traceConfig = this._pool._getConnectTraceConfig();
        } else {
          traceConfig = { connectString: this._connectString, user: this._user };
        }
        traceConfig.serviceName = this.getServiceName();
        traceConfig.instanceName = this.getInstanceName();
        traceConfig.pdbName = this.getDbName();
        if (settings.thin) {
          traceConfig.hostName = this.getHostName();
          traceConfig.port = this.getPort();
          traceConfig.protocol = this.getProtocol();
        }
        return traceConfig;
      }
      //---------------------------------------------------------------------------
      // _getDbObjectType()
      //
      // Return the object identifying the object type. These are cached by fully
      // qualified name and by OID (thin mode only).
      //---------------------------------------------------------------------------
      _getDbObjectType(schema, name, packageName, oid) {
        let dbObjectType;
        if (oid) {
          dbObjectType = this._dbObjectTypes.get(oid);
          if (dbObjectType)
            return dbObjectType;
        }
        const fqn = packageName ? `${schema}.${packageName}.${name}` : `${schema}.${name}`;
        dbObjectType = this._dbObjectTypes.get(fqn);
        if (!dbObjectType) {
          dbObjectType = {
            oid,
            fqn,
            schema,
            name,
            packageName,
            partial: true,
            isXmlType: schema === "SYS" && name === "XMLTYPE"
          };
          this._dbObjectTypes.set(fqn, dbObjectType);
        }
        if (oid && !dbObjectType.oid) {
          dbObjectType.oid = oid;
          this._dbObjectTypes.set(oid, dbObjectType);
        }
        return dbObjectType;
      }
      //---------------------------------------------------------------------------
      // _isDate()
      //
      // Method for determining if a value is a Date object. This method can be
      // removed once Node-API version 5 is used in the C extension.
      // ---------------------------------------------------------------------------
      _isDate(val) {
        return util.types.isDate(val);
      }
      //---------------------------------------------------------------------------
      // _releaseLock()
      //
      // Release the lock on the connection to allow another use of the connection.
      //---------------------------------------------------------------------------
      _releaseLock() {
        if (this._requestQueue.length > 0) {
          const payload = this._requestQueue.shift();
          payload.resolve();
        } else {
          this._inProgress = false;
        }
      }
      //---------------------------------------------------------------------------
      // breakExecution()
      //
      // Breaks execution of a running statement.
      //---------------------------------------------------------------------------
      breakExecution() {
        errors.throwNotImplemented("getting Oracle Server version number");
      }
      //---------------------------------------------------------------------------
      // changePassword()
      //
      // Changes the password of the specified user.
      //---------------------------------------------------------------------------
      changePassword() {
        errors.throwNotImplemented("changing the password");
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Close the connection.
      //---------------------------------------------------------------------------
      close() {
        errors.throwNotImplemented("closing the connection");
      }
      //---------------------------------------------------------------------------
      // commit()
      //
      // Commits the transaction.
      //---------------------------------------------------------------------------
      commit() {
        errors.throwNotImplemented("committing the transaction");
      }
      //---------------------------------------------------------------------------
      // createLob()
      //
      // Creates a temporary LOB and returns it.
      //---------------------------------------------------------------------------
      createLob() {
        errors.throwNotImplemented("creating a temporary LOB");
      }
      //---------------------------------------------------------------------------
      // execute()
      //
      // Executes a SQL statement and returns the results.
      //---------------------------------------------------------------------------
      execute() {
        errors.throwNotImplemented("executing a SQL statement");
      }
      //---------------------------------------------------------------------------
      // executeMany()
      //
      // Executes a SQL statement and returns the results.
      //---------------------------------------------------------------------------
      executeMany() {
        errors.throwNotImplemented("executing a SQL statement multiple times");
      }
      //---------------------------------------------------------------------------
      // getCallTimeout()
      //
      // Returns the call timeout value.
      //---------------------------------------------------------------------------
      getCallTimeout() {
        errors.throwNotImplemented("getting call timeout");
      }
      //---------------------------------------------------------------------------
      // getCurrentSchema()
      //
      // Returns the current schema.
      //---------------------------------------------------------------------------
      getCurrentSchema() {
        errors.throwNotImplemented("getting current schema");
      }
      //---------------------------------------------------------------------------
      // getDbDomain()
      //
      // Returns the Oracle Database domain name associated with the connection.
      //---------------------------------------------------------------------------
      getDbDomain() {
        errors.throwNotImplemented("getting db domain");
      }
      //---------------------------------------------------------------------------
      // getDbName()
      //
      // Returns the Oracle Database name associated with the connection.
      //---------------------------------------------------------------------------
      getDbName() {
        errors.throwNotImplemented("getting db name");
      }
      //---------------------------------------------------------------------------
      // getDbObjectClass()
      //
      // Returns a database object class given its name.
      //---------------------------------------------------------------------------
      getDbObjectClass() {
        errors.throwNotImplemented("getting a database object class");
      }
      //---------------------------------------------------------------------------
      // getExternalName()
      //
      // Returns the external name for TPC logging.
      //---------------------------------------------------------------------------
      getExternalName() {
        errors.throwNotImplemented("getting the external name");
      }
      //---------------------------------------------------------------------------
      // getInstanceName()
      //
      // Returns the Oracle Database instance name associated with the connection.
      //---------------------------------------------------------------------------
      getInstanceName() {
        errors.throwNotImplemented("getting the Oracle Database instance name.");
      }
      //---------------------------------------------------------------------------
      // getInternalName()
      //
      // Returns the internal name for TPC logging.
      //---------------------------------------------------------------------------
      getInternalName() {
        errors.throwNotImplemented("getting the internal name");
      }
      //---------------------------------------------------------------------------
      // getLTXID()
      //
      // Returns the the logical transaction ID for database transactions.
      //---------------------------------------------------------------------------
      getLTXID() {
        errors.throwNotImplemented("getting the logical transaction id");
      }
      //---------------------------------------------------------------------------
      // getMaxIdentifierLength()
      //
      // Returns the maximum length of identifiers supported by the database to
      // which this connection has been established.
      //---------------------------------------------------------------------------
      getMaxIdentifierLength() {
        errors.throwNotImplemented("getting the maximum identifier length");
      }
      //---------------------------------------------------------------------------
      // getMaxOpenCursors()
      //
      // Returns maximum number of cursors that can be opened in one session.
      //---------------------------------------------------------------------------
      getMaxOpenCursors() {
        errors.throwNotImplemented("getting max open cursors");
      }
      //---------------------------------------------------------------------------
      // getOracleServerVersion()
      //
      // Returns an integer identifying the Oracle Server version.
      //---------------------------------------------------------------------------
      getOracleServerVersion() {
        errors.throwNotImplemented("getting Oracle Server version number");
      }
      //---------------------------------------------------------------------------
      // getOracleServerVersionString()
      //
      // Returns a string identifying the Oracle Server version.
      //---------------------------------------------------------------------------
      getOracleServerVersionString() {
        errors.throwNotImplemented("getting Oracle Server version as a string");
      }
      //---------------------------------------------------------------------------
      // getQueue()
      //
      // Returns a queue with the given name.
      //---------------------------------------------------------------------------
      getQueue() {
        errors.throwNotImplemented("getting a queue");
      }
      //---------------------------------------------------------------------------
      // getServiceName()
      //
      // Returns the Oracle Database service name associated with the connection.
      //---------------------------------------------------------------------------
      getServiceName() {
        errors.throwNotImplemented("getting service name");
      }
      //---------------------------------------------------------------------------
      // getSodaDatabase()
      //
      // Returns a SodaDatabase object associated with the connection.
      //---------------------------------------------------------------------------
      getSodaDatabase() {
        errors.throwNotImplemented("getting a SODA database");
      }
      //---------------------------------------------------------------------------
      // getStatementInfo()
      //
      // Returns information about a statement.
      //---------------------------------------------------------------------------
      getStatementInfo() {
        errors.throwNotImplemented("getting information about a statement");
      }
      //---------------------------------------------------------------------------
      // getStmtCacheSize()
      //
      // Returns the size of the statement cache.
      //---------------------------------------------------------------------------
      getStmtCacheSize() {
        errors.throwNotImplemented("getting the statement cache size");
      }
      //---------------------------------------------------------------------------
      // getTag()
      //
      // Returns the tag associated with the connection.
      //---------------------------------------------------------------------------
      getTag() {
        errors.throwNotImplemented("getting the tag for the connection");
      }
      //---------------------------------------------------------------------------
      // getTransactionInProgress()
      //
      // Returns boolean based on the presence of an active transaction on the
      // connection
      //---------------------------------------------------------------------------
      getTransactionInProgress() {
        errors.throwNotImplemented("getting the status of an active transaction on the connection");
      }
      //---------------------------------------------------------------------------
      // getWarning()
      //
      // Returns a warning on a connection
      //---------------------------------------------------------------------------
      getWarning() {
        errors.throwNotImplemented("getting information about warning");
      }
      //---------------------------------------------------------------------------
      // isHealthy()
      //
      // Returns whether the connection is healthy or not.
      //---------------------------------------------------------------------------
      isHealthy() {
        errors.throwNotImplemented("getting the health of the connection");
      }
      isCompressionEnabled() {
        errors.throwNotImplemented("getting the data compression status on the connection");
      }
      //---------------------------------------------------------------------------
      // ping()
      //
      // Sends a "ping" to the database to see if it is "alive".
      //---------------------------------------------------------------------------
      ping() {
        errors.throwNotImplemented("sending a ping to the database");
      }
      //---------------------------------------------------------------------------
      // rollback()
      //
      // Rolls back a transaction.
      //---------------------------------------------------------------------------
      rollback() {
        errors.throwNotImplemented("rolling back a transaction");
      }
      //---------------------------------------------------------------------------
      // setAction()
      //
      // Sets the end-to-end tracing attribute "action".
      //---------------------------------------------------------------------------
      setAction() {
        errors.throwNotImplemented("setting end-to-end attribute 'action'");
      }
      //---------------------------------------------------------------------------
      // setCallTimeout()
      //
      // Sets the call timeout value.
      //---------------------------------------------------------------------------
      setCallTimeout() {
        errors.throwNotImplemented("setting call timeout");
      }
      //---------------------------------------------------------------------------
      // setClientId()
      //
      // Sets the end-to-end tracing attribute "clientId".
      //---------------------------------------------------------------------------
      setClientId() {
        errors.throwNotImplemented("setting end-to-end attribute 'clientId'");
      }
      //---------------------------------------------------------------------------
      // setClientInfo()
      //
      // Sets the end-to-end tracing attribute "clientInfo".
      //---------------------------------------------------------------------------
      setClientInfo() {
        errors.throwNotImplemented("setting end-to-end attribute 'clientInfo'");
      }
      //---------------------------------------------------------------------------
      // setCurrentSchema()
      //
      // Sets the current schema.
      //---------------------------------------------------------------------------
      setCurrentSchema() {
        errors.throwNotImplemented("setting the current schema");
      }
      //---------------------------------------------------------------------------
      // setDbOp()
      //
      // Sets the end-to-end tracing attribute "dbOp".
      //---------------------------------------------------------------------------
      setDbOp() {
        errors.throwNotImplemented("setting end-to-end attribute 'dbOp'");
      }
      //---------------------------------------------------------------------------
      // setECID()
      //
      // Sets the end-to-end tracing attribute "ecid".
      //---------------------------------------------------------------------------
      setECID() {
        errors.throwNotImplemented("setting end-to-end attribute 'ecid'");
      }
      //---------------------------------------------------------------------------
      // setExternalName()
      //
      // Sets the external name for TPC logging.
      //---------------------------------------------------------------------------
      setExternalName() {
        errors.throwNotImplemented("setting the external name");
      }
      //---------------------------------------------------------------------------
      // setInternalName()
      //
      // Sets the internal name for TPC logging.
      //---------------------------------------------------------------------------
      setInternalName() {
        errors.throwNotImplemented("setting the internal name");
      }
      //---------------------------------------------------------------------------
      // setStmtCacheSize()
      //
      // Sets the size of the statement cache.
      //---------------------------------------------------------------------------
      setStmtCacheSize() {
        errors.throwNotImplemented("setting the size of the statement cache");
      }
      //---------------------------------------------------------------------------
      // setModule()
      //
      // Sets the end-to-end tracing attribute "module".
      //---------------------------------------------------------------------------
      setModule() {
        errors.throwNotImplemented("setting end-to-end attribute 'module'");
      }
      //---------------------------------------------------------------------------
      // setTag()
      //
      // Sets the tag associated with the connection.
      //---------------------------------------------------------------------------
      setTag() {
        errors.throwNotImplemented("setting the tag for the connection");
      }
      //---------------------------------------------------------------------------
      // shutdown()
      //
      // Shuts down the database instance.
      //---------------------------------------------------------------------------
      shutdown() {
        errors.throwNotImplemented("shutting down the database instance");
      }
      //---------------------------------------------------------------------------
      // startup()
      //
      // Starts up a database instance.
      //---------------------------------------------------------------------------
      startup() {
        errors.throwNotImplemented("starting up the database instance");
      }
      //---------------------------------------------------------------------------
      // subscribe()
      //
      // Subscribes to events in the database.
      //---------------------------------------------------------------------------
      subscribe() {
        errors.throwNotImplemented("subscribing to events in the database");
      }
      //---------------------------------------------------------------------------
      // tpcBegin()
      //
      // Starts a two-phase transaction.
      //---------------------------------------------------------------------------
      tpcBegin() {
        errors.throwNotImplemented("starting a two-phase transaction");
      }
      //---------------------------------------------------------------------------
      // tpcCommit()
      //
      // Commits a two-phase transaction.
      //---------------------------------------------------------------------------
      tpcCommit() {
        errors.throwNotImplemented("committing a two-phase transaction");
      }
      //---------------------------------------------------------------------------
      // tpcEnd()
      //
      // Ends a two-phase transaction.
      //---------------------------------------------------------------------------
      tpcEnd() {
        errors.throwNotImplemented("ending a two-phase transaction");
      }
      //---------------------------------------------------------------------------
      // tpcForget()
      //
      // Forgets a two-phase transaction.
      //---------------------------------------------------------------------------
      tpcForget() {
        errors.throwNotImplemented("forgetting a two-phase transaction");
      }
      //---------------------------------------------------------------------------
      // tpcPrepare()
      //
      // Prepares a two-phase transaction for commit.
      //---------------------------------------------------------------------------
      tpcPrepare() {
        errors.throwNotImplemented("preparing a two-phase transaction");
      }
      //---------------------------------------------------------------------------
      // tpcRollback()
      //
      // Rolls back a two-phase transaction.
      //---------------------------------------------------------------------------
      tpcRollback() {
        errors.throwNotImplemented("rolling back a two-phase transaction");
      }
      //---------------------------------------------------------------------------
      // unsubscribe()
      //
      // Unsubscribes from events in the database.
      //---------------------------------------------------------------------------
      unsubscribe() {
        errors.throwNotImplemented("unsubscribing from events");
      }
      //---------------------------------------------------------------------------
      // getHostName()
      //
      // Returns the Oracle Database host name associated with the connection.
      //---------------------------------------------------------------------------
      getHostName() {
        errors.throwNotImplemented("getting HostName");
      }
      //---------------------------------------------------------------------------
      // getPort()
      //
      // Returns the Oracle Database port number associated with the connection.
      //---------------------------------------------------------------------------
      getPort() {
        errors.throwNotImplemented("getting Port");
      }
      //---------------------------------------------------------------------------
      // getProtocol()
      //
      // Returns the protocol associated with the connection.
      //---------------------------------------------------------------------------
      getProtocol() {
        errors.throwNotImplemented("getting Protocol");
      }
    };
    module2.exports = ConnectionImpl;
  }
});

// node_modules/oracledb/lib/impl/lob.js
var require_lob = __commonJS({
  "node_modules/oracledb/lib/impl/lob.js"(exports2, module2) {
    "use strict";
    var ConnectionImpl = require_connection();
    var errors = require_errors();
    var BaseImpl = require_base();
    var LobImpl = class extends BaseImpl {
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        let parentObj = this._parentObj;
        while (!(parentObj instanceof ConnectionImpl))
          parentObj = parentObj._parentObj;
        return parentObj;
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Close the LOB.
      //---------------------------------------------------------------------------
      close() {
        errors.throwNotImplemented("closing a LOB");
      }
      //---------------------------------------------------------------------------
      // fileExists()
      //
      // Checks if BFILE present or not.
      //---------------------------------------------------------------------------
      fileExists() {
        errors.throwNotImplemented("check if BFILE exists");
      }
      //---------------------------------------------------------------------------
      // getData()
      //
      // Returns all of the data in the LOB.
      //---------------------------------------------------------------------------
      getData() {
        errors.throwNotImplemented("getting all of the data from a LOB");
      }
      //---------------------------------------------------------------------------
      // getDirFileName()
      //
      // returns directory and filename of LOB (BFILE).
      //----------------------------------------------------------------------------
      getDirFileName() {
        errors.throwNotImplemented("getting directory and filename of LOB(BFILE)");
      }
      //---------------------------------------------------------------------------
      // read()
      //
      // Reads data from the LOB at the specified offset.
      //---------------------------------------------------------------------------
      read() {
        errors.throwNotImplemented("reading from a LOB");
      }
      //---------------------------------------------------------------------------
      // setDirFileName()
      //
      // sets directory and filename for LOB (BFILE)
      //---------------------------------------------------------------------------
      setDirFileName() {
        errors.throwNotImplemented("setting directory and filename of LOB(BFILE)");
      }
      //---------------------------------------------------------------------------
      // write()
      //
      // Writes data to the LOB at the specified offset.
      //---------------------------------------------------------------------------
      write() {
        errors.throwNotImplemented("writing to a LOB");
      }
    };
    module2.exports = LobImpl;
  }
});

// node_modules/oracledb/lib/impl/pool.js
var require_pool = __commonJS({
  "node_modules/oracledb/lib/impl/pool.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var nodbUtil = require_util();
    var PoolImpl = class {
      //---------------------------------------------------------------------------
      // _accessTokenHandler()
      //
      // Access token handler callback function which wraps the user callback and
      // returns the token to the implementation.
      //---------------------------------------------------------------------------
      async _accessTokenHandler(userFn, externalObj, refresh, accessTokenConfig) {
        let accessToken;
        try {
          let result = userFn(refresh, accessTokenConfig);
          if (result instanceof Promise) {
            result = await result;
          }
          if (!nodbUtil.isTokenValid(result)) {
            errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);
          }
          if (typeof result === "object" && result.privateKey !== void 0) {
            result.privateKey = nodbUtil.denormalizePrivateKey(result.privateKey);
          }
          accessToken = result;
        } finally {
          this.returnAccessToken(externalObj, accessToken);
        }
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Close the pool.
      //---------------------------------------------------------------------------
      close() {
        errors.throwNotImplemented("closing the pool");
      }
      //---------------------------------------------------------------------------
      // create()
      //
      // Creates the pool and makes it available for use.
      //---------------------------------------------------------------------------
      create() {
        errors.throwNotImplemented("creating the pool");
      }
      //---------------------------------------------------------------------------
      // getConnection()
      //
      // Returns a connection from the pool.
      //---------------------------------------------------------------------------
      getConnection() {
        errors.throwNotImplemented("getting a connection from the pool");
      }
      //---------------------------------------------------------------------------
      // getConnectionsInUse()
      //
      // Returns the number of connections in use in the pool.
      //---------------------------------------------------------------------------
      getConnectionsInUse() {
        errors.throwNotImplemented("getting num connection in use");
      }
      //---------------------------------------------------------------------------
      // getConnectionsOpen()
      //
      // Returns the number of connections opened by the pool.
      //---------------------------------------------------------------------------
      getConnectionsOpen() {
        errors.throwNotImplemented("getting num connection open");
      }
      //---------------------------------------------------------------------------
      // getPoolIncrement()
      //
      // Returns the number of connections to create when the pool needs to grow.
      //---------------------------------------------------------------------------
      getPoolIncrement() {
        errors.throwNotImplemented("getting the pool increment");
      }
      //---------------------------------------------------------------------------
      // getPoolMax()
      //
      // Returns the maximum number of connections allowed in the pool.
      //---------------------------------------------------------------------------
      getPoolMax() {
        errors.throwNotImplemented("getting the pool max");
      }
      //---------------------------------------------------------------------------
      // getPoolMaxPerShard()
      //
      // Returns the maximum number of connections allowed per shard in the pool.
      //---------------------------------------------------------------------------
      getPoolMaxPerShard() {
        errors.throwNotImplemented("getting the pool max per shard");
      }
      //---------------------------------------------------------------------------
      // getPoolMin()
      //
      // Returns the minimum number of connections allowed in the pool.
      //---------------------------------------------------------------------------
      getPoolMin() {
        errors.throwNotImplemented("getting the pool min");
      }
      //---------------------------------------------------------------------------
      // getPoolPingInterval()
      //
      // Returns the pool ping interval (seconds).
      //---------------------------------------------------------------------------
      getPoolPingInterval() {
        errors.throwNotImplemented("getting the pool ping interval");
      }
      //---------------------------------------------------------------------------
      // getPoolPingTimeout()
      //
      // Returns the pool ping Timeout (milliseconds).
      //---------------------------------------------------------------------------
      getPoolPingTimeout() {
        errors.throwNotImplemented("getting the pool ping Timeout");
      }
      //---------------------------------------------------------------------------
      // getPoolTimeout()
      //
      // Returns the pool timeout.
      //---------------------------------------------------------------------------
      getPoolTimeout() {
        errors.throwNotImplemented("getting the pool timeout");
      }
      //---------------------------------------------------------------------------
      // getMaxLifetimeSession()
      //
      // Returns the pool max lifetime for a session.
      //---------------------------------------------------------------------------
      getMaxLifetimeSession() {
        errors.throwNotImplemented("getting the pool max lifetime");
      }
      //---------------------------------------------------------------------------
      // getStmtCacheSize()
      //
      // Returns the statement cache size associate with the pool.
      //---------------------------------------------------------------------------
      getStmtCacheSize() {
        errors.throwNotImplemented("getting the pool statement cache size");
      }
      //---------------------------------------------------------------------------
      // _getConnectTraceConfig()
      //
      // Returns the necessary connection config used by pool for debug/trace.
      //---------------------------------------------------------------------------
      _getConnectTraceConfig() {
        return {
          connectString: this._connectString,
          user: this._user,
          poolMin: this.getPoolMin(),
          poolMax: this.getPoolMax(),
          poolIncrement: this.getPoolIncrement()
        };
      }
      //---------------------------------------------------------------------------
      // getSodaMetaDataCache()
      //
      // Returns whether the SODA metadata cache is enabled or not.
      //---------------------------------------------------------------------------
      getSodaMetaDataCache() {
        errors.throwNotImplemented("getting the SODA metadata cache flag");
      }
      //---------------------------------------------------------------------------
      // reconfigure()
      //
      // Reconfigures the pool with new parameters.
      //---------------------------------------------------------------------------
      reconfigure() {
        errors.throwNotImplemented("reconfiguring the pool");
      }
      //---------------------------------------------------------------------------
      // setAccessToken()
      //
      // Sets the access token to use with the pool.
      //---------------------------------------------------------------------------
      setAccessToken() {
        errors.throwNotImplemented("sets the access token");
      }
    };
    module2.exports = PoolImpl;
  }
});

// node_modules/oracledb/lib/future.js
var require_future = __commonJS({
  "node_modules/oracledb/lib/future.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var Future = class {
      constructor() {
        this._featureFlags = {};
        this._featureFlags.oldJsonColumnAsObj = false;
      }
      get oldJsonColumnAsObj() {
        return this._featureFlags.oldJsonColumnAsObj;
      }
      // fetch VARCHAR2 and LOB columns that contain JSON data (and have
      // the "IS JSON" constraint enabled) in the same way that columns
      // of type JSON (which requires Oracle Database 21 and higher) are fetched.
      set oldJsonColumnAsObj(value) {
        errors.assertPropValue(typeof value === "boolean", "oldJsonColumnAsObj");
        this._featureFlags.oldJsonColumnAsObj = value;
      }
    };
    module2.exports = new Future();
  }
});

// node_modules/oracledb/lib/lob.js
var require_lob2 = __commonJS({
  "node_modules/oracledb/lib/lob.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var { Duplex } = require("stream");
    var constants = require_constants();
    var errors = require_errors();
    var nodbUtil = require_util();
    var types = require_types();
    var Lob = class extends Duplex {
      constructor() {
        super({ decodeStrings: false });
        this.offset = 1;
        this._isActive = false;
        this.once("finish", function() {
          if (this._autoCloseLob) {
            this.destroy();
          }
        });
      }
      // called by BFILE specific functions to throw errors for other
      // datatypes.
      _checkIsBfile() {
        if (this.type !== types.DB_TYPE_BFILE) {
          errors.throwErr(errors.ERR_OPERATION_ONLY_SUPPORTED_ON_BFILE);
        }
      }
      // called by functions not allowed for BFILE and throw errors if
      // such operations are performed on BFILE.
      _checkNotBfile() {
        if (this.type === types.DB_TYPE_BFILE) {
          errors.throwErr(errors.ERR_OPERATION_NOT_SUPPORTED_ON_BFILE);
        }
      }
      // called by stream.destroy() and ensures that the LOB is closed if it has
      // not already been closed (never called directly)
      async _destroy(err, cb) {
        if (err && err.message.startsWith("NJS-003:"))
          delete this._impl;
        if (this._impl) {
          const lobImpl = this._impl;
          delete this._impl;
          try {
            await lobImpl.close();
          } catch (closeErr) {
            cb(closeErr);
            return;
          }
        }
        cb(err);
      }
      // implementation of streaming read; if LOB is set to auto-close, the lob is
      // automatically closed when an error occurs or when there are no more bytes
      // to transfer; all that needs to be done here is to destroy the streaming
      // LOB
      async _read() {
        try {
          const data = await this._serializedRead(this.offset);
          if (data) {
            this.offset += data.length;
            this.push(data);
          } else {
            this.push(null);
            if (this._autoCloseLob) {
              this.destroy();
            }
          }
        } catch (err) {
          if (this._autoCloseLob)
            this.destroy(err);
          throw err;
        }
      }
      // simple wrapper so that serialization can take place on a JavaScript fn
      async _readData(offset) {
        errors.assert(this._impl, errors.ERR_INVALID_LOB);
        try {
          return await this._impl.read(offset);
        } catch (err) {
          throw errors.transformErr(err, this._readData);
        }
      }
      // called to associate a LOB implementation with this user facing object
      _setup(lobImpl, autoCloseLob) {
        this._impl = lobImpl;
        if (this.type !== types.DB_TYPE_BFILE) {
          this._chunkSize = lobImpl.getChunkSize();
        }
        this._pieceSize = lobImpl.getPieceSize();
        this._length = lobImpl.getLength();
        this._type = lobImpl.getType();
        if (typeof this._type === "number") {
          this._type = types.getTypeByNum(this._type);
        }
        this._autoCloseLob = autoCloseLob;
      }
      // implementation of streaming write; if LOB is set to auto-close, the lob is
      // automatically closed in the "finish" event; all that needs to be done here
      // is to destroy the streaming LOB
      async _write(data, encoding, cb) {
        if (this.type == constants.DB_TYPE_BLOB && !Buffer2.isBuffer(data)) {
          data = Buffer2.from(data);
        } else if (this.type == constants.DB_TYPE_CLOB && Buffer2.isBuffer(data)) {
          data = data.toString();
        }
        try {
          await this._serializedWrite(this.offset, data);
        } catch (err) {
          if (this._autoCloseLob)
            this.destroy(err);
          cb(err);
          return;
        }
        this.offset += data.length;
        cb(null);
      }
      // simple wrapper so that serialization can take place on a JavaScript fn
      async _writeData(offset, data) {
        errors.assert(this._impl, errors.ERR_INVALID_LOB);
        try {
          await this._impl.write(offset, data);
        } catch (err) {
          throw errors.transformErr(err, this._writeData);
        }
      }
      //---------------------------------------------------------------------------
      // chunkSize
      //
      // Property for the chunk size of the LOB.
      //---------------------------------------------------------------------------
      get chunkSize() {
        this._checkNotBfile();
        return this._chunkSize;
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Close the LOB and make it unusable for further operations. If the LOB is
      // already closed, nothing is done in order to support multiple close()
      // calls.
      //
      // This method is deprecated and will be removed in a future version of the
      // node-oracledb driver. Use lob.destroy() instead. NOTE: this method will
      // emit a duplicate "close" event in order to be compatible with previous
      // versions of node-oracledb.
      //---------------------------------------------------------------------------
      async close() {
        errors.assertArgCount(arguments, 0, 0);
        if (this._impl) {
          const lobImpl = this._impl;
          delete this._impl;
          try {
            await lobImpl.close();
            this.emit("close");
          } catch (err) {
            this.destroy(err);
          }
        }
      }
      //---------------------------------------------------------------------------
      // getData()
      //
      // Return a portion (or all) of the data in the LOB. Note that the amount
      // and offset are in bytes for BLOB and BFILE type LOBs and in UCS - 2 code
      // points for CLOB and NCLOB type LOBs.UCS-2 code points are equivalent
      // to characters for all but supplemental characters.If supplemental
      // characters are in the LOB, the offset and amount will have to be chosen
      // carefully to avoid splitting a character.
      // Returns data in the LOB as a single string or buffer.
      //---------------------------------------------------------------------------
      async getData(offset, amount) {
        errors.assertArgCount(arguments, 0, 2);
        if (offset === void 0) {
          offset = 1;
        } else {
          errors.assertParamValue(Number.isInteger(offset) && offset > 0, 1);
        }
        if (amount === void 0) {
          amount = 0;
        } else {
          errors.assertParamValue(Number.isInteger(amount) && amount > 0, 2);
        }
        errors.assert(this._impl, errors.ERR_INVALID_LOB);
        return await this._impl.getData(offset, amount);
      }
      //---------------------------------------------------------------------------
      // getDirFileName()
      //  To obtain the BFILE Lob object properties dirName & fileName
      //---------------------------------------------------------------------------
      getDirFileName() {
        this._checkIsBfile();
        return this._impl.getDirFileName();
      }
      //--------------------------------------------------------------------------
      // setDirFileName()
      //  To set the BFILE Lob object properties dirName & fileName
      //--------------------------------------------------------------------------
      setDirFileName(a1) {
        this._checkIsBfile();
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(nodbUtil.isObject(a1), 1);
        errors.assertParamValue(Object.hasOwn(a1, "dirName"), 1);
        errors.assertParamValue(Object.hasOwn(a1, "fileName"), 1);
        errors.assertPropValue(
          a1.dirName != "" && a1.dirName != null,
          "dirName"
        );
        errors.assertPropValue(
          a1.fileName != "" && a1.fileName != null,
          "fileName"
        );
        this._impl.setDirFileName(a1);
      }
      //---------------------------------------------------------------------------
      // fileExists
      //
      //   To obtain file existence status of BFILE file
      //---------------------------------------------------------------------------
      async fileExists() {
        this._checkIsBfile();
        return await this._impl.fileExists();
      }
      //---------------------------------------------------------------------------
      // length
      //
      // Property for the length of the LOB.
      //---------------------------------------------------------------------------
      get length() {
        return this._length;
      }
      //---------------------------------------------------------------------------
      // pieceSize
      //
      // Property for the size to use for each piece that is transferred when
      // reading from the LOB.
      //---------------------------------------------------------------------------
      get pieceSize() {
        return this._pieceSize;
      }
      set pieceSize(value) {
        errors.assertPropValue(Number.isInteger(value) && value >= 0, "pieceSize");
        errors.assert(this._impl, errors.ERR_INVALID_LOB);
        this._impl.setPieceSize(value);
        this._pieceSize = value;
      }
      //---------------------------------------------------------------------------
      // type
      //
      // Property for the type of the LOB.
      //---------------------------------------------------------------------------
      get type() {
        return this._type;
      }
    };
    nodbUtil.wrapFns(
      Lob.prototype,
      errors.ERR_BUSY_LOB,
      "close",
      "fileExists",
      "getData"
    );
    Lob.prototype._serializedRead = nodbUtil.wrapFn(Lob.prototype._readData, true);
    Lob.prototype._serializedWrite = nodbUtil.wrapFn(Lob.prototype._writeData, true);
    module2.exports = Lob;
  }
});

// node_modules/oracledb/lib/impl/datahandlers/oson.js
var require_oson = __commonJS({
  "node_modules/oracledb/lib/impl/datahandlers/oson.js"(exports2, module2) {
    "use strict";
    var { BaseBuffer, GrowableBuffer } = require_buffer();
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants2();
    var errors = require_errors();
    var types = require_types();
    var util = require("util");
    var vector = require_vector();
    var nodbUtil = require_util();
    var OsonDecoder = class extends BaseBuffer {
      //---------------------------------------------------------------------------
      // _decodeContainerNode()
      //
      // Decodes a container node (object or array) from the tree segment and
      // returns the JavaScript equivalent.
      //---------------------------------------------------------------------------
      _decodeContainerNode(nodeType) {
        let container, offsetsPos, fieldIdsPos;
        const containerOffset = this.pos - this.treeSegPos - 1;
        let numChildren = this._getNumChildren(nodeType);
        const isObject = (nodeType & 64) === 0;
        if (numChildren === void 0) {
          const offset = this._getOffset(nodeType);
          offsetsPos = this.pos;
          this.pos = this.treeSegPos + offset;
          const sharedNodeType = this.readUInt8();
          numChildren = this._getNumChildren(sharedNodeType);
          container = isObject ? {} : new Array(numChildren);
          fieldIdsPos = this.pos;
        } else if (isObject) {
          container = {};
          fieldIdsPos = this.pos;
          offsetsPos = this.pos + this.fieldIdLength * numChildren;
        } else {
          container = new Array(numChildren);
          offsetsPos = this.pos;
        }
        for (let i = 0; i < numChildren; i++) {
          let name;
          if (isObject) {
            let fieldId;
            if (this.fieldIdLength === 1) {
              fieldId = this.buf[fieldIdsPos];
            } else if (this.fieldIdLength == 2) {
              fieldId = this.buf.readUInt16BE(fieldIdsPos);
            } else {
              fieldId = this.buf.readUInt32BE(fieldIdsPos);
            }
            name = this.fieldNames[fieldId - 1];
            fieldIdsPos += this.fieldIdLength;
          }
          this.pos = offsetsPos;
          let offset = this._getOffset(nodeType);
          if (this.relativeOffsets) {
            offset += containerOffset;
          }
          offsetsPos = this.pos;
          this.pos = this.treeSegPos + offset;
          if (isObject) {
            container[name] = this._decodeNode();
          } else {
            container[i] = this._decodeNode();
          }
        }
        return container;
      }
      //---------------------------------------------------------------------------
      // _decodeNode()
      //
      // Decodes a node from the tree segment and returns the JavaScript
      // equivalent.
      //---------------------------------------------------------------------------
      _decodeNode() {
        let nodeType = this.readUInt8();
        if (nodeType & 128) {
          return this._decodeContainerNode(nodeType);
        }
        if (nodeType === constants.TNS_JSON_TYPE_NULL) {
          return null;
        } else if (nodeType === constants.TNS_JSON_TYPE_TRUE) {
          return true;
        } else if (nodeType === constants.TNS_JSON_TYPE_FALSE) {
          return false;
        } else if (nodeType === constants.TNS_JSON_TYPE_DATE || nodeType === constants.TNS_JSON_TYPE_TIMESTAMP7) {
          return this.parseOracleDate(this.readBytes(7));
        } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP) {
          return this.parseOracleDate(this.readBytes(11));
        } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP_TZ) {
          return this.parseOracleDate(this.readBytes(13));
        } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_FLOAT) {
          return this.parseBinaryFloat(this.readBytes(4));
        } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_DOUBLE) {
          return this.parseBinaryDouble(this.readBytes(8));
        } else if (nodeType === constants.TNS_JSON_TYPE_INTERVAL_YM) {
          return this.parseOracleIntervalYM(this.readBytes(5));
        } else if (nodeType === constants.TNS_JSON_TYPE_INTERVAL_DS) {
          return this.parseOracleIntervalDS(this.readBytes(11));
        } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8) {
          return this.readBytes(this.readUInt8()).toString();
        } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16) {
          return this.readBytes(this.readUInt16BE()).toString();
        } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32) {
          return this.readBytes(this.readUInt32BE()).toString();
        } else if (nodeType === constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8) {
          return parseFloat(this.readOracleNumber());
        } else if (nodeType === constants.TNS_JSON_TYPE_ID) {
          const buf = this.readBytes(this.readUInt8());
          const jsonId = new types.JsonId(buf.length);
          buf.copy(jsonId);
          return jsonId;
        } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16) {
          return Buffer2.from(this.readBytes(this.readUInt16BE()));
        } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32) {
          return Buffer2.from(this.readBytes(this.readUInt32BE()));
        } else if (nodeType === constants.TNS_JSON_TYPE_EXTENDED) {
          nodeType = this.readUInt8();
          if (nodeType === constants.TNS_JSON_TYPE_VECTOR) {
            const vecImage = this.readBytes(this.readUInt32BE());
            const decoder = new vector.VectorDecoder(vecImage);
            return decoder.decode();
          }
        }
        const typeBits = nodeType & 240;
        if (typeBits === 32 || typeBits === 96) {
          const len = nodeType & 15;
          return parseFloat(this.parseOracleNumber(this.readBytes(len + 1)));
        } else if (typeBits === 64 || typeBits === 80) {
          const len = nodeType & 15;
          return parseFloat(this.parseOracleNumber(this.readBytes(len)));
        } else if ((nodeType & 224) == 0) {
          if (nodeType === 0)
            return "";
          return this.readBytes(nodeType).toString();
        }
        errors.throwErr(errors.ERR_UNSUPPORTED_DATA_TYPE_IN_JSON, nodeType);
      }
      //---------------------------------------------------------------------------
      // _getNumChildren()
      //
      // Returns the number of children a container has. This is determined by
      // looking at the 4th and 5th most significant bits of the node type.
      //
      //   00 - number of children is uint8_t
      //   01 - number of children is uint16_t
      //   10 - number of children is uint32_t
      //   11 - field ids are shared with another object whose offset follows
      //
      // In the latter case the value undefined is returned and the number of
      // children must be read from the shared object at the specified offset.
      //---------------------------------------------------------------------------
      _getNumChildren(nodeType) {
        const childrenBits = nodeType & 24;
        if (childrenBits === 0) {
          return this.readUInt8();
        } else if (childrenBits === 8) {
          return this.readUInt16BE();
        } else if (childrenBits === 16) {
          return this.readUInt32BE();
        }
      }
      //---------------------------------------------------------------------------
      // _getOffset()
      //
      // Returns an offset. The offset will be either a 16-bit or 32-bit value
      // depending on the value of the 3rd significant bit of the node type.
      //---------------------------------------------------------------------------
      _getOffset(nodeType) {
        if (nodeType & 32) {
          return this.readUInt32BE();
        } else {
          return this.readUInt16BE();
        }
      }
      //---------------------------------------------------------------------------
      // _getFieldNames
      //
      // Reads the field names from the buffer.
      //---------------------------------------------------------------------------
      _getFieldNames(arrStartPos, numFields, offsetsSize, fieldNamesSegSize, fieldNamesSize) {
        this.skipBytes(numFields * fieldNamesSize);
        const offsetsPos = this.pos;
        this.skipBytes(numFields * offsetsSize);
        const ptr = this.readBytes(fieldNamesSegSize);
        const finalPos = this.pos;
        this.pos = offsetsPos;
        let offset;
        for (let i = arrStartPos; i < arrStartPos + numFields; i++) {
          if (offsetsSize === 2) {
            offset = this.readUInt16BE();
          } else {
            offset = this.readUInt32BE();
          }
          let temp;
          if (fieldNamesSize === 1) {
            temp = ptr.readUInt8(offset);
          } else {
            temp = ptr.readUInt16BE(offset);
          }
          this.fieldNames[i] = ptr.subarray(offset + fieldNamesSize, offset + temp + fieldNamesSize).toString();
        }
        this.pos = finalPos;
      }
      //---------------------------------------------------------------------------
      // decode()
      //
      // Decodes the OSON and returns a JavaScript object corresponding to its
      // contents.
      //---------------------------------------------------------------------------
      decode() {
        const magic = this.readBytes(3);
        if (magic[0] !== constants.TNS_JSON_MAGIC_BYTE_1 || magic[1] !== constants.TNS_JSON_MAGIC_BYTE_2 || magic[2] !== constants.TNS_JSON_MAGIC_BYTE_3) {
          errors.throwErr(errors.ERR_UNEXPECTED_DATA, magic.toString("hex"));
        }
        const version = this.readUInt8();
        if (version !== constants.TNS_JSON_VERSION_MAX_FNAME_255 && version !== constants.TNS_JSON_VERSION_MAX_FNAME_65535) {
          errors.throwErr(errors.ERR_OSON_VERSION_NOT_SUPPORTED, version);
        }
        const primaryFlags = this.readUInt16BE();
        this.relativeOffsets = primaryFlags & constants.TNS_JSON_FLAG_REL_OFFSET_MODE;
        if (primaryFlags & constants.TNS_JSON_FLAG_IS_SCALAR) {
          if (primaryFlags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {
            this.skipBytes(4);
          } else {
            this.skipBytes(2);
          }
          return this._decodeNode();
        }
        let numShortFieldNames;
        if (primaryFlags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32) {
          numShortFieldNames = this.readUInt32BE();
          this.fieldIdLength = 4;
        } else if (primaryFlags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16) {
          numShortFieldNames = this.readUInt16BE();
          this.fieldIdLength = 2;
        } else {
          numShortFieldNames = this.readUInt8();
          this.fieldIdLength = 1;
        }
        let shortFieldNameOffsetsSize, shortFieldNamesSegSize;
        if (primaryFlags & constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32) {
          shortFieldNameOffsetsSize = 4;
          shortFieldNamesSegSize = this.readUInt32BE();
        } else {
          shortFieldNameOffsetsSize = 2;
          shortFieldNamesSegSize = this.readUInt16BE();
        }
        let longFieldNameOffsetsSize, longFieldNamesSegSize;
        let numLongFieldNames = 0;
        if (version === constants.TNS_JSON_VERSION_MAX_FNAME_65535) {
          const secondaryFlags = this.readUInt16BE();
          if (secondaryFlags & constants.TNS_JSON_FLAG_SEC_FNAMES_SEG_UINT16) {
            longFieldNameOffsetsSize = 2;
          } else {
            longFieldNameOffsetsSize = 4;
          }
          numLongFieldNames = this.readUInt32BE();
          longFieldNamesSegSize = this.readUInt32BE();
        }
        if (primaryFlags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {
          this.skipBytes(4);
        } else {
          this.skipBytes(2);
        }
        this.skipBytes(2);
        this.fieldNames = new Array(numShortFieldNames + numLongFieldNames);
        if (numShortFieldNames > 0) {
          this._getFieldNames(
            0,
            numShortFieldNames,
            shortFieldNameOffsetsSize,
            shortFieldNamesSegSize,
            1
          );
        }
        if (numLongFieldNames > 0) {
          this._getFieldNames(
            numShortFieldNames,
            numLongFieldNames,
            longFieldNameOffsetsSize,
            longFieldNamesSegSize,
            2
          );
        }
        this.treeSegPos = this.pos;
        return this._decodeNode();
      }
    };
    var OsonFieldName = class {
      constructor(name, maxFieldNameSize) {
        this.name = name;
        this.nameBytes = Buffer2.from(name);
        if (this.nameBytes.length > maxFieldNameSize) {
          errors.throwErr(errors.ERR_OSON_FIELD_NAME_LIMITATION, maxFieldNameSize);
        }
        const INITIAL_HASHID = 0x811C9DC5n;
        const HASH_MULTIPLIER = 16777619n;
        const HASH_MASK = 0xffffffffn;
        this.hashId = INITIAL_HASHID;
        for (let i = 0; i < this.nameBytes.length; i++) {
          const c = BigInt(this.nameBytes[i]);
          this.hashId = (this.hashId ^ c) * HASH_MULTIPLIER & HASH_MASK;
        }
        this.hashId = Number(this.hashId) & 255;
      }
    };
    var OsonFieldNamesSegment = class extends GrowableBuffer {
      constructor() {
        super();
        this.fieldNames = [];
      }
      //---------------------------------------------------------------------------
      // addName()
      //
      // Adds a name to the field names segment.
      //---------------------------------------------------------------------------
      addName(fieldName) {
        fieldName.offset = this.pos;
        if (fieldName.nameBytes.length <= 255) {
          this.writeUInt8(fieldName.nameBytes.length);
        } else {
          this.writeUInt16BE(fieldName.nameBytes.length);
        }
        this.writeBytes(fieldName.nameBytes);
        this.fieldNames.push(fieldName);
      }
      //---------------------------------------------------------------------------
      // _processFieldNames()
      //
      // Processes the field names in preparation for encoding within OSON.
      //---------------------------------------------------------------------------
      _processFieldNames(fieldIdOffset) {
        this.fieldNames.sort((a, b) => {
          if (a.hashId < b.hashId)
            return -1;
          if (a.hashId > b.hashId)
            return 1;
          if (a.nameBytes.length < b.nameBytes.length)
            return -1;
          if (a.nameBytes.length > b.nameBytes.length)
            return 1;
          if (a.name < b.name)
            return -1;
          if (a.name > b.name)
            return 1;
          return 0;
        });
        for (let i = 0; i < this.fieldNames.length; i++) {
          this.fieldNames[i].fieldId = fieldIdOffset + i + 1;
        }
        if (this.fieldNames.length < 256) {
          this.fieldIdSize = 1;
        } else if (this.fieldNames.length < 65536) {
          this.fieldIdSize = 2;
        } else {
          this.fieldIdSize = 4;
        }
      }
    };
    var OsonTreeSegment = class extends GrowableBuffer {
      //---------------------------------------------------------------------------
      // _encodeArray()
      //
      // Encodes an array in the OSON tree segment.
      //---------------------------------------------------------------------------
      _encodeArray(value, encoder) {
        this._encodeContainer(constants.TNS_JSON_TYPE_ARRAY, value.length);
        const len = value.length * 4;
        const pos = this.reserveBytes(len);
        let offsetsBufPos = pos;
        for (const element of value) {
          this.buf.writeUInt32BE(this.pos, offsetsBufPos);
          offsetsBufPos += 4;
          this.encodeNode(element, encoder);
        }
      }
      //---------------------------------------------------------------------------
      // _encodeContainer()
      //
      // Encodes the first part of a container (array or object) in the OSON tree
      // segment.
      //---------------------------------------------------------------------------
      _encodeContainer(nodeType, numChildren) {
        nodeType |= 32;
        if (numChildren > 65535) {
          nodeType |= 16;
        } else if (numChildren > 255) {
          nodeType |= 8;
        }
        this.writeUInt8(nodeType);
        if (numChildren < 256) {
          this.writeUInt8(numChildren);
        } else if (numChildren < 65536) {
          this.writeUInt16BE(numChildren);
        } else {
          this.writeUInt32BE(numChildren);
        }
      }
      //---------------------------------------------------------------------------
      // _encodeObject()
      //
      // Encodes an object in the OSON tree segment.
      //---------------------------------------------------------------------------
      _encodeObject(value, encoder) {
        const numChildren = value.values.length;
        this._encodeContainer(constants.TNS_JSON_TYPE_OBJECT, numChildren);
        let fieldIdOffset = this.pos;
        let valueOffset = this.pos + numChildren * encoder.fieldIdSize;
        const finalOffset = valueOffset + numChildren * 4;
        this.reserveBytes(finalOffset - this.pos);
        for (let i = 0; i < value.fields.length; i++) {
          const fieldName = encoder.fieldNamesMap.get(value.fields[i]);
          if (encoder.fieldIdSize == 1) {
            this.buf[fieldIdOffset] = fieldName.fieldId;
          } else if (encoder.fieldIdSize == 2) {
            this.buf.writeUInt16BE(fieldName.fieldId, fieldIdOffset);
          } else {
            this.buf.writeUInt32BE(fieldName.fieldId, fieldIdOffset);
          }
          this.buf.writeUInt32BE(this.pos, valueOffset);
          fieldIdOffset += encoder.fieldIdSize;
          valueOffset += 4;
          this.encodeNode(value.values[i], encoder);
        }
      }
      //---------------------------------------------------------------------------
      // encodeNode()
      //
      // Encodes a value (node) in the OSON tree segment.
      //---------------------------------------------------------------------------
      encodeNode(value, encoder) {
        if (value === void 0 || value === null) {
          this.writeUInt8(constants.TNS_JSON_TYPE_NULL);
        } else if (typeof value === "boolean") {
          if (value) {
            this.writeUInt8(constants.TNS_JSON_TYPE_TRUE);
          } else {
            this.writeUInt8(constants.TNS_JSON_TYPE_FALSE);
          }
        } else if (typeof value === "number") {
          if (Number.isNaN(value)) {
            this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_DOUBLE);
            this.writeBinaryDouble(value);
          } else {
            this.writeUInt8(constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8);
            this.writeOracleNumber(value.toString());
          }
        } else if (typeof value === "string") {
          const buf = Buffer2.from(value);
          if (buf.length < 256) {
            this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8);
            this.writeUInt8(buf.length);
          } else if (buf.length < 65536) {
            this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16);
            this.writeUInt16BE(buf.length);
          } else {
            this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32);
            this.writeUInt32BE(buf.length);
          }
          if (buf.length > 0) {
            this.writeBytes(buf);
          }
        } else if (util.types.isDate(value)) {
          if (value.getUTCMilliseconds() === 0) {
            this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP7);
            this.writeOracleDate(value, types.DB_TYPE_DATE, false);
          } else {
            this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP);
            this.writeOracleDate(value, types.DB_TYPE_TIMESTAMP, false);
          }
        } else if (value instanceof types.IntervalYM) {
          this.writeUInt8(constants.TNS_JSON_TYPE_INTERVAL_YM);
          this.writeOracleIntervalYM(value, false);
        } else if (value instanceof types.IntervalDS) {
          this.writeUInt8(constants.TNS_JSON_TYPE_INTERVAL_DS);
          this.writeOracleIntervalDS(value, false);
        } else if (Buffer2.isBuffer(value)) {
          if (value.length < 65536) {
            this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16);
            this.writeUInt16BE(value.length);
          } else {
            this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32);
            this.writeUInt32BE(value.length);
          }
          this.writeBytes(value);
        } else if (Array.isArray(value)) {
          this._encodeArray(value, encoder);
        } else if (nodbUtil.isVectorValue(value)) {
          this.writeUInt8(constants.TNS_JSON_TYPE_EXTENDED);
          this.writeUInt8(constants.TNS_JSON_TYPE_VECTOR);
          const encoder2 = new vector.VectorEncoder();
          const buf = encoder2.encode(value);
          this.writeUInt32BE(buf.length);
          this.writeBytes(buf);
        } else if (value instanceof types.JsonId) {
          this.writeUInt8(constants.TNS_JSON_TYPE_ID);
          this.writeUInt8(value.length);
          this.writeBytes(Buffer2.from(value.buffer));
        } else {
          this._encodeObject(value, encoder);
        }
      }
    };
    var OsonEncoder = class extends GrowableBuffer {
      //---------------------------------------------------------------------------
      // _addFieldName()
      //
      // Add a field with the given name.
      //---------------------------------------------------------------------------
      _addFieldName(name) {
        const fieldName = new OsonFieldName(name, this.maxFieldNameSize);
        this.fieldNamesMap.set(name, fieldName);
        if (fieldName.nameBytes.length <= 255) {
          this.shortFieldNamesSeg.addName(fieldName);
        } else {
          if (!this.longFieldNamesSeg) {
            this.longFieldNamesSeg = new OsonFieldNamesSegment();
          }
          this.longFieldNamesSeg.addName(fieldName);
        }
      }
      //---------------------------------------------------------------------------
      // _examineNode()
      //
      // Examines the value. If it contains fields, unique names are retained. The
      // values are then examined to see if they also contain fields. Arrays are
      // examined to determine they contain elements that contain fields.
      //---------------------------------------------------------------------------
      _examineNode(value) {
        if (Array.isArray(value)) {
          for (const element of value) {
            this._examineNode(element);
          }
        } else if (value && Array.isArray(value.fields)) {
          for (let i = 0; i < value.fields.length; i++) {
            const name = value.fields[i];
            const element = value.values[i];
            if (!this.fieldNamesMap.has(name)) {
              this._addFieldName(name);
            }
            this._examineNode(element);
          }
        }
      }
      //---------------------------------------------------------------------------
      // _writeExtendedHeader()
      //
      // Write the extended header containing information about the short and long
      // field name segments.
      //---------------------------------------------------------------------------
      _writeExtendedHeader() {
        if (this.fieldIdSize === 1) {
          this.writeUInt8(this.shortFieldNamesSeg.fieldNames.length);
        } else if (this.fieldIdSize === 2) {
          this.writeUInt16BE(this.shortFieldNamesSeg.fieldNames.length);
        } else {
          this.writeUInt32BE(this.shortFieldNamesSeg.fieldNames.length);
        }
        if (this.shortFieldNamesSeg.pos < 65536) {
          this.writeUInt16BE(this.shortFieldNamesSeg.pos);
        } else {
          this.writeUInt32BE(this.shortFieldNamesSeg.pos);
        }
        if (this.longFieldNamesSeg) {
          let secondaryFlags = 0;
          if (this.longFieldNamesSeg.pos < 65536) {
            secondaryFlags = constants.TNS_JSON_FLAG_SEC_FNAMES_SEG_UINT16;
          }
          this.writeUInt16BE(secondaryFlags);
          this.writeUInt32BE(this.longFieldNamesSeg.fieldNames.length);
          this.writeUInt32BE(this.longFieldNamesSeg.pos);
        }
      }
      //---------------------------------------------------------------------------
      // _writeFieldNamesSeg()
      //
      // Write the contents of the field names segment to the buffer.
      //---------------------------------------------------------------------------
      _writeFieldNamesSeg(fieldNamesSeg) {
        for (const fieldName of fieldNamesSeg.fieldNames) {
          if (fieldName.nameBytes.length <= 255) {
            this.writeUInt8(fieldName.hashId);
          } else {
            this.writeUInt16BE(fieldName.hashId);
          }
        }
        for (const fieldName of fieldNamesSeg.fieldNames) {
          if (fieldNamesSeg.pos < 65536) {
            this.writeUInt16BE(fieldName.offset);
          } else {
            this.writeUInt32BE(fieldName.offset);
          }
        }
        if (fieldNamesSeg.pos > 0) {
          this.writeBytes(fieldNamesSeg.buf.subarray(0, fieldNamesSeg.pos));
        }
      }
      //---------------------------------------------------------------------------
      // encode()
      //
      // Encodes the value as OSON and returns a buffer containing the OSON bytes.
      //---------------------------------------------------------------------------
      encode(value, maxFieldNameSize) {
        this.maxFieldNameSize = maxFieldNameSize;
        let flags = constants.TNS_JSON_FLAG_INLINE_LEAF;
        if (Array.isArray(value) || value && Array.isArray(value.fields)) {
          this.fieldNamesMap = /* @__PURE__ */ new Map();
          this.shortFieldNamesSeg = new OsonFieldNamesSegment();
          this._examineNode(value);
          let totalNumFieldNames = 0;
          if (this.shortFieldNamesSeg) {
            this.shortFieldNamesSeg._processFieldNames(0);
            totalNumFieldNames += this.shortFieldNamesSeg.fieldNames.length;
          }
          if (this.longFieldNamesSeg) {
            this.longFieldNamesSeg._processFieldNames(totalNumFieldNames);
            totalNumFieldNames += this.longFieldNamesSeg.fieldNames.length;
          }
          flags |= constants.TNS_JSON_FLAG_HASH_ID_UINT8 | constants.TNS_JSON_FLAG_TINY_NODES_STAT;
          if (totalNumFieldNames > 65535) {
            flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32;
            this.fieldIdSize = 4;
          } else if (totalNumFieldNames > 255) {
            flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16;
            this.fieldIdSize = 2;
          } else {
            this.fieldIdSize = 1;
          }
          if (this.shortFieldNamesSeg.pos > 65535) {
            flags |= constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32;
          }
        } else {
          flags |= constants.TNS_JSON_FLAG_IS_SCALAR;
        }
        const treeSeg = new OsonTreeSegment();
        treeSeg.encodeNode(value, this);
        if (treeSeg.pos > 65535) {
          flags |= constants.TNS_JSON_FLAG_TREE_SEG_UINT32;
        }
        this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_1);
        this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_2);
        this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_3);
        if (this.longFieldNamesSeg) {
          this.writeUInt8(constants.TNS_JSON_VERSION_MAX_FNAME_65535);
        } else {
          this.writeUInt8(constants.TNS_JSON_VERSION_MAX_FNAME_255);
        }
        this.writeUInt16BE(flags);
        if (this.shortFieldNamesSeg) {
          this._writeExtendedHeader();
        }
        if (treeSeg.pos < 65536) {
          this.writeUInt16BE(treeSeg.pos);
        } else {
          this.writeUInt32BE(treeSeg.pos);
        }
        if (this.shortFieldNamesSeg) {
          this.writeUInt16BE(0);
          this._writeFieldNamesSeg(this.shortFieldNamesSeg);
          if (this.longFieldNamesSeg) {
            this._writeFieldNamesSeg(this.longFieldNamesSeg);
          }
        }
        this.writeBytes(treeSeg.buf.subarray(0, treeSeg.pos));
        return this.buf.subarray(0, this.pos);
      }
    };
    module2.exports = {
      OsonDecoder,
      OsonEncoder
    };
  }
});

// node_modules/oracledb/lib/impl/resultset.js
var require_resultset = __commonJS({
  "node_modules/oracledb/lib/impl/resultset.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var errors = require_errors();
    var nodbUtil = require_util();
    var settings = require_settings();
    var future = require_future();
    var types = require_types();
    var Lob = require_lob2();
    var oson = require_oson();
    var BaseImpl = require_base();
    var ResultSetImpl = class extends BaseImpl {
      //---------------------------------------------------------------------------
      // _determineFetchType()
      //
      // Determine the fetch type to use for the specified metadata.
      // Param rowsetMetaData includes metadata of all the columns fetched.
      //---------------------------------------------------------------------------
      _determineFetchType(metadata, options, rowsetMetaData) {
        delete metadata.fetchType;
        delete metadata.converter;
        if (options.fetchTypeHandler) {
          const result = options.fetchTypeHandler(metadata, rowsetMetaData);
          if (result !== void 0) {
            errors.assert(
              typeof result === "object",
              errors.ERR_FETCH_TYPE_HANDLER_RETURN_VALUE
            );
            if (result.type !== void 0) {
              errors.assert(
                result.type instanceof types.DbType,
                errors.ERR_FETCH_TYPE_HANDLER_TYPE
              );
            }
            if (result.converter !== void 0) {
              errors.assert(
                typeof result.converter === "function",
                errors.ERR_FETCH_TYPE_HANDLER_CONVERTER
              );
            }
            metadata.fetchType = result.type;
            metadata.converter = result.converter;
          }
        }
        if (!metadata.fetchType) {
          if (options.fetchTypeMap && options.fetchTypeMap.has(metadata.name)) {
            metadata.fetchType = options.fetchTypeMap.get(metadata.name);
            if (metadata.fetchType === constants.DEFAULT) {
              metadata.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(metadata.dbType);
            }
          } else {
            metadata.fetchType = settings.fetchTypeMap.get(metadata.dbType);
          }
        }
        if (metadata.fetchType !== metadata.dbType) {
          const map = types.DB_TYPE_CONVERSION_MAP.get(metadata.dbType);
          const actualFetchType = map && map.get(metadata.fetchType);
          if (!actualFetchType) {
            errors.throwErr(
              errors.ERR_UNSUPPORTED_CONVERSION,
              metadata.dbType.name,
              metadata.fetchType.name
            );
          }
          metadata.fetchType = actualFetchType;
        }
        let converter;
        const userConverter = metadata.converter;
        if (metadata.dbType !== types.DB_TYPE_JSON && future.oldJsonColumnAsObj && userConverter === void 0) {
          let outConverter;
          if (metadata.isOson) {
            outConverter = async function(val) {
              if (!val) {
                return val;
              }
              let result = val;
              if (val instanceof Lob) {
                result = await val.getData();
              }
              const decoder = new oson.OsonDecoder(result);
              return decoder.decode();
            };
            converter = outConverter;
          } else if (metadata.isJson) {
            outConverter = async function(val) {
              if (!val) {
                return val;
              }
              let result = val;
              if (val instanceof Lob) {
                result = await val.getData();
              }
              if (result instanceof Buffer) {
                result = result.toString();
              }
              result = JSON.parse(result);
              return result;
            };
            converter = outConverter;
          }
        }
        if (settings.thin) {
          if (metadata.dbType === types.DB_TYPE_NUMBER && metadata.fetchType === types.DB_TYPE_NUMBER) {
            converter = (v) => v === null ? null : parseFloat(v);
          } else if (metadata.fetchType === types.DB_TYPE_VARCHAR) {
            if (metadata.dbType === types.DB_TYPE_BINARY_DOUBLE || metadata.dbType === types.DB_TYPE_BINARY_FLOAT || metadata.dbType === types.DB_TYPE_DATE || metadata.dbType === types.DB_TYPE_TIMESTAMP || metadata.dbType === types.DB_TYPE_TIMESTAMP_LTZ || metadata.dbType === types.DB_TYPE_TIMESTAMP_TZ) {
              converter = (v) => v === null ? null : v.toString();
            } else if (metadata.dbType === types.DB_TYPE_RAW) {
              converter = (v) => v === null ? null : v.toString("hex").toUpperCase();
            }
          } else if (metadata.dbType === types.DB_TYPE_XMLTYPE) {
            const xmlConverter = async function(val) {
              if (!val) {
                return val;
              }
              if (typeof val === "string") {
                return val;
              }
              return await val.getData();
            };
            converter = xmlConverter;
          }
          if (userConverter && converter) {
            const internalConverter = converter;
            converter = (v) => userConverter(internalConverter(v));
          }
        }
        if (converter) {
          metadata.converter = converter;
        }
      }
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        return this._parentObj;
      }
      //---------------------------------------------------------------------------
      // _setup()
      //
      // Setup a result set. The metadata is examined to to determine if any
      // columns need to be manipulated before being returned to the caller. If the
      // rows fetched from the result set are expected to be objects, a unique set
      // of attribute names are also determined.
      //---------------------------------------------------------------------------
      _setup(options, metaData) {
        this._parentObj = options.connection._impl;
        this.metaData = metaData;
        this.lobIndices = [];
        this.dbObjectIndices = [];
        this.nestedCursorIndices = [];
        this.converterIndices = [];
        this.outFormat = options.outFormat;
        this.fetchArraySize = options.fetchArraySize;
        this.dbObjectAsPojo = options.dbObjectAsPojo;
        this.maxRows = options.maxRows;
        const names = /* @__PURE__ */ new Map();
        for (let i = 0; i < metaData.length; i++) {
          const name = metaData[i].name;
          if (!names.has(name)) {
            names.set(name, i);
          }
        }
        for (let i = 0; i < metaData.length; i++) {
          const info = metaData[i];
          if (info.dbTypeClass) {
            const cls = options.connection._getDbObjectClass(info.dbTypeClass);
            info.dbTypeClass = cls;
          }
          nodbUtil.addTypeProperties(info, "dbType");
          this._determineFetchType(info, options, metaData);
          if (info.fetchType === types.DB_TYPE_CURSOR) {
            this.nestedCursorIndices.push(i);
          } else if (info.fetchType === types.DB_TYPE_CLOB || info.fetchType === types.DB_TYPE_NCLOB || info.fetchType === types.DB_TYPE_BLOB || info.fetchType === types.DB_TYPE_BFILE) {
            this.lobIndices.push(i);
          } else if (info.fetchType === types.DB_TYPE_OBJECT) {
            this.dbObjectIndices.push(i);
          }
          if (info.converter) {
            this.converterIndices.push(i);
          }
          let name = info.name;
          if (names.get(name) !== i) {
            let seqNum = 0;
            while (names.has(name)) {
              seqNum = seqNum + 1;
              name = `${info.name}_${seqNum}`;
            }
            names.set(name, i);
            info.name = name;
          }
        }
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Closes the result set.
      //---------------------------------------------------------------------------
      close() {
        errors.throwNotImplemented("closing a result set");
      }
      //---------------------------------------------------------------------------
      // getRows()
      //
      // Returns rows from a result set.
      //---------------------------------------------------------------------------
      getRows() {
        errors.throwNotImplemented("getting rows");
      }
      //---------------------------------------------------------------------------
      // _getAllRows() [INTERNAL]
      //
      // Fetches all the rows from the database to use internally.
      //---------------------------------------------------------------------------
      async _getAllRows() {
        const fetchArraySize = 100;
        let rowsFetched = [];
        while (true) {
          const rows = await this.getRows(fetchArraySize, {});
          if (rows) {
            await this._processRows(rows, false);
            rowsFetched = rowsFetched.concat(rows);
          }
          if (rows.length < fetchArraySize) {
            break;
          }
        }
        return rowsFetched;
      }
    };
    module2.exports = ResultSetImpl;
  }
});

// node_modules/oracledb/lib/impl/sodaCollection.js
var require_sodaCollection = __commonJS({
  "node_modules/oracledb/lib/impl/sodaCollection.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var BaseImpl = require_base();
    var SodaCollectionImpl = class extends BaseImpl {
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        return this._database._connection;
      }
      //---------------------------------------------------------------------------
      // createIndex()
      //
      // Creates an index on a SODA collection.
      //---------------------------------------------------------------------------
      createIndex() {
        errors.throwNotImplemented("creating an index on a SODA collection");
      }
      //---------------------------------------------------------------------------
      // drop()
      //
      // Drops a SODA collection.
      //---------------------------------------------------------------------------
      drop() {
        errors.throwNotImplemented("dropping a SODA collection");
      }
      //---------------------------------------------------------------------------
      // dropIndex()
      //
      // Drops a SODA collection.
      //---------------------------------------------------------------------------
      dropIndex() {
        errors.throwNotImplemented("dropping an index on a SODA collection");
      }
      //---------------------------------------------------------------------------
      // find()
      //
      // Returns a SODA operation object associated with the collection.
      //---------------------------------------------------------------------------
      find() {
        errors.throwNotImplemented("creating a SODA operation");
      }
      //---------------------------------------------------------------------------
      // getDataGuide()
      //
      // Returns a SODA operation object associated with the collection.
      //---------------------------------------------------------------------------
      getDataGuide() {
        errors.throwNotImplemented("getting the data guide for the collection");
      }
      //---------------------------------------------------------------------------
      // getMetaData()
      //
      // Returns the metadata for the collection.
      //---------------------------------------------------------------------------
      getMetaData() {
        errors.throwNotImplemented("getting the metadata for the collection");
      }
      //---------------------------------------------------------------------------
      // getName()
      //
      // Returns the name of the collection.
      //---------------------------------------------------------------------------
      getName() {
        errors.throwNotImplemented("getting the name of the collection");
      }
      //---------------------------------------------------------------------------
      // insertMany()
      //
      // Inserts multiple documents into the collection at the same time.
      //---------------------------------------------------------------------------
      insertMany() {
        errors.throwNotImplemented("inserting multiple docs into a collection");
      }
      //---------------------------------------------------------------------------
      // insertManyAndGet()
      //
      // Inserts multiple documents into the collection at the same time and
      // returns an array of documents containing metadata.
      //---------------------------------------------------------------------------
      insertManyAndGet() {
        errors.throwNotImplemented("insert/return many docs in a collection");
      }
      //---------------------------------------------------------------------------
      // insertOne()
      //
      // Inserts a single document into the collection.
      //---------------------------------------------------------------------------
      insertOne() {
        errors.throwNotImplemented("inserting a single doc into a collection");
      }
      //---------------------------------------------------------------------------
      // insertOneAndGet()
      //
      // Inserts a single document into the collection and returns a document
      // containing metadata.
      //---------------------------------------------------------------------------
      insertOneAndGet() {
        errors.throwNotImplemented("insert/return a single doc in a collection");
      }
      //---------------------------------------------------------------------------
      // save()
      //
      // Saves a single document into the collection.
      //---------------------------------------------------------------------------
      save() {
        errors.throwNotImplemented("saving a single doc in a collection");
      }
      //---------------------------------------------------------------------------
      // saveAndGet()
      //
      // Saves a single document into the collection and returns a document
      // containing metadata.
      //---------------------------------------------------------------------------
      saveAndGet() {
        errors.throwNotImplemented("saving a single doc in a collection");
      }
      //---------------------------------------------------------------------------
      // truncate()
      //
      // Removes all of the documents from a collection.
      //---------------------------------------------------------------------------
      truncate() {
        errors.throwNotImplemented("removing all docs from a collection");
      }
    };
    module2.exports = SodaCollectionImpl;
  }
});

// node_modules/oracledb/lib/impl/sodaDatabase.js
var require_sodaDatabase = __commonJS({
  "node_modules/oracledb/lib/impl/sodaDatabase.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var BaseImpl = require_base();
    var SodaDatabaseImpl = class extends BaseImpl {
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        return this._connection;
      }
      //---------------------------------------------------------------------------
      // createCollection()
      //
      // Creates and returns a SODA collection.
      //---------------------------------------------------------------------------
      createCollection() {
        errors.throwNotImplemented("creating a SODA collection");
      }
      //---------------------------------------------------------------------------
      // createDocument()
      //
      // Creates and returns a SODA document.
      //---------------------------------------------------------------------------
      createDocument() {
        errors.throwNotImplemented("creating a SODA document");
      }
      //---------------------------------------------------------------------------
      // getCollectionNames()
      //
      // Returns a list of the collection names available in the database.
      //---------------------------------------------------------------------------
      getCollectionNames() {
        errors.throwNotImplemented("getting a list of SODA collection names");
      }
      //---------------------------------------------------------------------------
      // openCollection()
      //
      // Opens a SODA collection and returns it.
      //---------------------------------------------------------------------------
      openCollection() {
        errors.throwNotImplemented("getting a list of SODA collection names");
      }
    };
    module2.exports = SodaDatabaseImpl;
  }
});

// node_modules/oracledb/lib/impl/sodaDocCursor.js
var require_sodaDocCursor = __commonJS({
  "node_modules/oracledb/lib/impl/sodaDocCursor.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var BaseImpl = require_base();
    var SodaDocCursorImpl = class extends BaseImpl {
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        return this._operation._getConnImpl();
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Closes the cursor.
      //---------------------------------------------------------------------------
      close() {
        errors.throwNotImplemented("closing a SODA document cursor");
      }
      //---------------------------------------------------------------------------
      // getNext()
      //
      // Returns the next document from the cursor.
      //---------------------------------------------------------------------------
      getNext() {
        errors.throwNotImplemented("getting a document from a SODA doc cursor");
      }
    };
    module2.exports = SodaDocCursorImpl;
  }
});

// node_modules/oracledb/lib/impl/sodaDocument.js
var require_sodaDocument = __commonJS({
  "node_modules/oracledb/lib/impl/sodaDocument.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var SodaDocumentImpl = class {
      //---------------------------------------------------------------------------
      // getContent()
      //
      // Returns the document content.
      //---------------------------------------------------------------------------
      getContent() {
        errors.throwNotImplemented("getting doc content");
      }
      //---------------------------------------------------------------------------
      // getCreatedOn()
      //
      // Returns the date the document was created.
      //---------------------------------------------------------------------------
      getCreatedOn() {
        errors.throwNotImplemented("getting the created date of a document");
      }
      //---------------------------------------------------------------------------
      // getKey()
      //
      // Returns the key of the document.
      //---------------------------------------------------------------------------
      getKey() {
        errors.throwNotImplemented("getting the key of a document");
      }
      //---------------------------------------------------------------------------
      // getLastModified()
      //
      // Returns the date the document was last modified.
      //---------------------------------------------------------------------------
      getLastModified() {
        errors.throwNotImplemented("getting the last modified date of a doc");
      }
      //---------------------------------------------------------------------------
      // getMediaType()
      //
      // Returns the media type of the document.
      //---------------------------------------------------------------------------
      getMediaType() {
        errors.throwNotImplemented("getting the media type of a document");
      }
      //---------------------------------------------------------------------------
      // getVersion()
      //
      // Returns the version of the document.
      //---------------------------------------------------------------------------
      getVersion() {
        errors.throwNotImplemented("getting the version of a document");
      }
    };
    module2.exports = SodaDocumentImpl;
  }
});

// node_modules/oracledb/lib/impl/sodaOperation.js
var require_sodaOperation = __commonJS({
  "node_modules/oracledb/lib/impl/sodaOperation.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var BaseImpl = require_base();
    var SodaOperationImpl = class extends BaseImpl {
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        return this._collection._database._connection;
      }
      //---------------------------------------------------------------------------
      // count()
      //
      // Returns the number of documents matching the criteria.
      //---------------------------------------------------------------------------
      count() {
        errors.throwNotImplemented("getting a count of documents");
      }
      //---------------------------------------------------------------------------
      // getCursor()
      //
      // Returns a cursor for documents matching the criteria.
      //---------------------------------------------------------------------------
      getCursor() {
        errors.throwNotImplemented("getting a cursor for documents");
      }
      //---------------------------------------------------------------------------
      // getDocuments()
      //
      // Returns an array of documents matching the criteria.
      //---------------------------------------------------------------------------
      getDocuments() {
        errors.throwNotImplemented("getting a cursor for documents");
      }
      //---------------------------------------------------------------------------
      // getOne()
      //
      // Returns a single document matching the criteria.
      //---------------------------------------------------------------------------
      getOne() {
        errors.throwNotImplemented("getting a single document");
      }
      //---------------------------------------------------------------------------
      // remove()
      //
      // Removes all of the documents matching the criteria.
      //---------------------------------------------------------------------------
      remove() {
        errors.throwNotImplemented("removing documents from a collection");
      }
      //---------------------------------------------------------------------------
      // replaceOne()
      //
      // Replaces a single document matching the criteria.
      //---------------------------------------------------------------------------
      replaceOne() {
        errors.throwNotImplemented("replacing a single document");
      }
      //---------------------------------------------------------------------------
      // replaceOneAndGet()
      //
      // Replaces a single document matching the criteria and returns a document
      // containing metadata.
      //---------------------------------------------------------------------------
      replaceOneAndGet() {
        errors.throwNotImplemented("replacing/returning a single document");
      }
    };
    module2.exports = SodaOperationImpl;
  }
});

// node_modules/oracledb/lib/impl/index.js
var require_impl = __commonJS({
  "node_modules/oracledb/lib/impl/index.js"(exports2, module2) {
    "use strict";
    var AqDeqOptionsImpl = require_aqDeqOptions();
    var AqEnqOptionsImpl = require_aqEnqOptions();
    var AqMessageImpl = require_aqMessage();
    var AqQueueImpl = require_aqQueue();
    var DbObjectImpl = require_dbObject();
    var ConnectionImpl = require_connection();
    var LobImpl = require_lob();
    var PoolImpl = require_pool();
    var ResultSetImpl = require_resultset();
    var SodaCollectionImpl = require_sodaCollection();
    var SodaDatabaseImpl = require_sodaDatabase();
    var SodaDocCursorImpl = require_sodaDocCursor();
    var SodaDocumentImpl = require_sodaDocument();
    var SodaOperationImpl = require_sodaOperation();
    module2.exports = {
      AqDeqOptionsImpl,
      AqEnqOptionsImpl,
      AqMessageImpl,
      AqQueueImpl,
      DbObjectImpl,
      ConnectionImpl,
      LobImpl,
      PoolImpl,
      ResultSetImpl,
      SodaCollectionImpl,
      SodaDatabaseImpl,
      SodaDocCursorImpl,
      SodaDocumentImpl,
      SodaOperationImpl
    };
  }
});

// node_modules/oracledb/lib/aqDeqOptions.js
var require_aqDeqOptions2 = __commonJS({
  "node_modules/oracledb/lib/aqDeqOptions.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants();
    var errors = require_errors();
    var AqDeqOptions = class {
      //---------------------------------------------------------------------------
      // condition
      //
      // Property for the condition to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get condition() {
        return this._impl.getCondition();
      }
      set condition(value) {
        errors.assertPropValue(typeof value === "string", "condition");
        this._impl.setCondition(value);
      }
      //---------------------------------------------------------------------------
      // consumerName
      //
      // Property for the consumer name to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get consumerName() {
        return this._impl.getConsumerName();
      }
      set consumerName(value) {
        errors.assertPropValue(typeof value === "string", "consumerName");
        this._impl.setConsumerName(value);
      }
      //---------------------------------------------------------------------------
      // correlation
      //
      // Property for the correlation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get correlation() {
        return this._impl.getCorrelation();
      }
      set correlation(value) {
        errors.assertPropValue(typeof value === "string", "correlation");
        this._impl.setCorrelation(value);
      }
      //---------------------------------------------------------------------------
      // deliveryMode
      //
      // Property for the delivery mode to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get deliveryMode() {
        return null;
      }
      set deliveryMode(value) {
        errors.assertPropValue(
          value === constants.AQ_MSG_DELIV_MODE_PERSISTENT || value === constants.AQ_MSG_DELIV_MODE_BUFFERED || value === constants.AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED,
          "deliveryMode"
        );
        this._impl.setDeliveryMode(value);
      }
      //---------------------------------------------------------------------------
      // mode
      //
      // Property for the mode to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get mode() {
        return this._impl.getMode();
      }
      set mode(value) {
        errors.assertPropValue(value === constants.AQ_DEQ_MODE_BROWSE || value === constants.AQ_DEQ_MODE_LOCKED || value === constants.AQ_DEQ_MODE_REMOVE || value === constants.AQ_DEQ_MODE_REMOVE_NO_DATA, "mode");
        this._impl.setMode(value);
      }
      //---------------------------------------------------------------------------
      // msgId
      //
      // Property for the message id to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get msgId() {
        return this._impl.getMsgId();
      }
      set msgId(value) {
        errors.assertPropValue(Buffer2.isBuffer(value), "msgId");
        this._impl.setMsgId(value);
      }
      //---------------------------------------------------------------------------
      // navigation
      //
      // Property for the navigation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get navigation() {
        return this._impl.getNavigation();
      }
      set navigation(value) {
        errors.assertPropValue(value === constants.AQ_DEQ_NAV_FIRST_MSG || value === constants.AQ_DEQ_NAV_NEXT_TRANSACTION || value === constants.AQ_DEQ_NAV_NEXT_MSG, "navigation");
        this._impl.setNavigation(value);
      }
      //---------------------------------------------------------------------------
      // transformation
      //
      // Property for the transformation to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get transformation() {
        return this._impl.getTransformation();
      }
      set transformation(value) {
        errors.assertPropValue(typeof value === "string", "transformation");
        this._impl.setTransformation(value);
      }
      //---------------------------------------------------------------------------
      // visibility
      //
      // Property for the visibility to use for dequeuing messages.
      //---------------------------------------------------------------------------
      get visibility() {
        return this._impl.getVisibility();
      }
      set visibility(value) {
        errors.assertPropValue(value === constants.AQ_VISIBILITY_IMMEDIATE || value === constants.AQ_VISIBILITY_ON_COMMIT, "visibility");
        this._impl.setVisibility(value);
      }
      //---------------------------------------------------------------------------
      // wait
      //
      // Property for the time to wait for dequeuing messages.
      //---------------------------------------------------------------------------
      get wait() {
        return this._impl.getWait();
      }
      set wait(value) {
        errors.assertPropValue(Number.isInteger(value) && value >= 0, "wait");
        this._impl.setWait(value);
      }
    };
    module2.exports = AqDeqOptions;
  }
});

// node_modules/oracledb/lib/aqEnqOptions.js
var require_aqEnqOptions2 = __commonJS({
  "node_modules/oracledb/lib/aqEnqOptions.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var errors = require_errors();
    var AqEnqOptions = class {
      //---------------------------------------------------------------------------
      // deliveryMode
      //
      // Property for the delivery mode to use for enqueuing messages.
      //---------------------------------------------------------------------------
      get deliveryMode() {
        return this._impl.getDeliveryMode();
      }
      set deliveryMode(value) {
        errors.assertPropValue(value === constants.AQ_MSG_DELIV_MODE_PERSISTENT || value === constants.AQ_MSG_DELIV_MODE_BUFFERED || value === constants.AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED, "deliveryMode");
        this._impl.setDeliveryMode(value);
      }
      //---------------------------------------------------------------------------
      // transformation
      //
      // Property for the transformation to use for enqueuing messages.
      //---------------------------------------------------------------------------
      get transformation() {
        return this._impl.getTransformation();
      }
      set transformation(value) {
        errors.assertPropValue(typeof value === "string", "transformation");
        this._impl.setTransformation(value);
      }
      //---------------------------------------------------------------------------
      // visibility
      //
      // Property for the visibility to use for enqueuing messages.
      //---------------------------------------------------------------------------
      get visibility() {
        return this._impl.getVisibility();
      }
      set visibility(value) {
        errors.assertPropValue(value === constants.AQ_VISIBILITY_IMMEDIATE || value === constants.AQ_VISIBILITY_ON_COMMIT, "visibility");
        this._impl.setVisibility(value);
      }
    };
    module2.exports = AqEnqOptions;
  }
});

// node_modules/oracledb/lib/aqMessage.js
var require_aqMessage2 = __commonJS({
  "node_modules/oracledb/lib/aqMessage.js"(exports2, module2) {
    "use strict";
    var DbObjectImpl = require_dbObject();
    var AqMessage = class {
      //---------------------------------------------------------------------------
      // correlation
      //
      // Property for the correlation used for the message.
      //---------------------------------------------------------------------------
      get correlation() {
        return this._impl.getCorrelation();
      }
      //---------------------------------------------------------------------------
      // delay
      //
      // Property for the delay used for the message.
      //---------------------------------------------------------------------------
      get delay() {
        return this._impl.getDelay();
      }
      //---------------------------------------------------------------------------
      // enqTime
      //
      // Property to indicate the enqueue time for the message.
      //---------------------------------------------------------------------------
      get enqTime() {
        return this._impl.getEnqTime();
      }
      //---------------------------------------------------------------------------
      // deliveryMode
      //
      // Property for the delivery mode used for the message.
      //---------------------------------------------------------------------------
      get deliveryMode() {
        return this._impl.getDeliveryMode();
      }
      //---------------------------------------------------------------------------
      // exceptionQueue
      //
      // Property for the exception queue used for the message.
      //---------------------------------------------------------------------------
      get exceptionQueue() {
        return this._impl.getExceptionQueue();
      }
      //---------------------------------------------------------------------------
      // expiration
      //
      // Property for the expiration used for the message.
      //---------------------------------------------------------------------------
      get expiration() {
        return this._impl.getExpiration();
      }
      //---------------------------------------------------------------------------
      // msgId
      //
      // Property for the message id used for the message.
      //---------------------------------------------------------------------------
      get msgId() {
        return this._impl.getMsgId();
      }
      //---------------------------------------------------------------------------
      // numAttempts
      //
      // Property for the number of attempts used for the message.
      //---------------------------------------------------------------------------
      get numAttempts() {
        return this._impl.getNumAttempts();
      }
      //---------------------------------------------------------------------------
      // originalMsgId
      //
      // Property for the original message id used for the message.
      //---------------------------------------------------------------------------
      get originalMsgId() {
        return this._impl.getOriginalMsgId();
      }
      //---------------------------------------------------------------------------
      // payload
      //
      // Property for the payload used for the message.
      //---------------------------------------------------------------------------
      get payload() {
        const payload = this._impl.getPayload();
        if (payload instanceof DbObjectImpl) {
          const obj = Object.create(this._payloadTypeClass.prototype);
          obj._impl = payload;
          return obj;
        }
        return payload;
      }
      //---------------------------------------------------------------------------
      // priority
      //
      // Property for the priority used for the message.
      //---------------------------------------------------------------------------
      get priority() {
        return this._impl.getPriority();
      }
      //---------------------------------------------------------------------------
      // state
      //
      // Property for the state used for the message.
      //---------------------------------------------------------------------------
      get state() {
        return this._impl.getState();
      }
    };
    module2.exports = AqMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/constants.js
var require_constants3 = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/constants.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants();
    var dataHandlerConstants = require_constants2();
    module2.exports = {
      // constants from upper level exposed here in order to avoid having multiple
      // files containing constants
      BIND_IN: constants.BIND_IN,
      BIND_INOUT: constants.BIND_INOUT,
      BIND_OUT: constants.BIND_OUT,
      CLIENT_VERSION: constants.VERSION_MAJOR << 24 | constants.VERSION_MINOR << 20 | constants.VERSION_PATCH << 12,
      CSFRM_IMPLICIT: constants.CSFRM_IMPLICIT,
      CSFRM_NCHAR: constants.CSFRM_NCHAR,
      DRIVER_NAME: constants.DEFAULT_DRIVER_NAME + " thn",
      PURITY_DEFAULT: constants.PURITY_DEFAULT,
      PURITY_NEW: constants.PURITY_NEW,
      PURITY_SELF: constants.PURITY_SELF,
      SYSASM: constants.SYSASM,
      SYSBKP: constants.SYSBACKUP,
      SYSDBA: constants.SYSDBA,
      SYSDG: constants.SYSDG,
      SYSKM: constants.SYSKM,
      SYSOPER: constants.SYSOPER,
      SYSRAC: constants.SYSRAC,
      // authentication modes
      AUTH_MODE_DEFAULT: 0,
      AUTH_MODE_PRELIM: 8,
      AUTH_MODE_SYSASM: 32768,
      AUTH_MODE_SYSBKP: 131072,
      AUTH_MODE_SYSDBA: 2,
      AUTH_MODE_SYSDGD: 262144,
      AUTH_MODE_SYSKMT: 524288,
      AUTH_MODE_SYSOPER: 4,
      AUTH_MODE_SYSRAC: 1048576,
      // TTC authentication modes
      TNS_AUTH_MODE_LOGON: 1,
      TNS_AUTH_MODE_CHANGE_PASSWORD: 2,
      TNS_AUTH_MODE_SYSDBA: 32,
      TNS_AUTH_MODE_SYSOPER: 64,
      TNS_AUTH_MODE_PRELIM: 128,
      TNS_AUTH_MODE_WITH_PASSWORD: 256,
      TNS_AUTH_MODE_SYSASM: 4194304,
      TNS_AUTH_MODE_SYSBKP: 16777216,
      TNS_AUTH_MODE_SYSDGD: 33554432,
      TNS_AUTH_MODE_SYSKMT: 67108864,
      TNS_AUTH_MODE_SYSRAC: 134217728,
      TNS_AUTH_MODE_IAM_TOKEN: 536870912,
      // packet types
      TNS_PACKET_TYPE_CONNECT: 1,
      TNS_PACKET_TYPE_ACCEPT: 2,
      TNS_PACKET_TYPE_REFUSE: 4,
      TNS_PACKET_TYPE_REDIRECT: 5,
      TNS_PACKET_TYPE_DATA: 6,
      TNS_PACKET_TYPE_RESEND: 11,
      TNS_PACKET_TYPE_MARKER: 12,
      TNS_PACKET_TYPE_CONTROL: 14,
      // data types
      TNS_DATA_TYPE_DEFAULT: 0,
      TNS_DATA_TYPE_VARCHAR: 1,
      TNS_DATA_TYPE_NUMBER: 2,
      TNS_DATA_TYPE_BINARY_INTEGER: 3,
      TNS_DATA_TYPE_FLOAT: 4,
      TNS_DATA_TYPE_STR: 5,
      TNS_DATA_TYPE_VNU: 6,
      TNS_DATA_TYPE_PDN: 7,
      TNS_DATA_TYPE_LONG: 8,
      TNS_DATA_TYPE_VCS: 9,
      TNS_DATA_TYPE_TIDDEF: 10,
      TNS_DATA_TYPE_ROWID: 11,
      TNS_DATA_TYPE_DATE: 12,
      TNS_DATA_TYPE_VBI: 15,
      TNS_DATA_TYPE_RAW: 23,
      TNS_DATA_TYPE_LONG_RAW: 24,
      TNS_DATA_TYPE_UB2: 25,
      TNS_DATA_TYPE_UB4: 26,
      TNS_DATA_TYPE_SB1: 27,
      TNS_DATA_TYPE_SB2: 28,
      TNS_DATA_TYPE_SB4: 29,
      TNS_DATA_TYPE_SWORD: 30,
      TNS_DATA_TYPE_UWORD: 31,
      TNS_DATA_TYPE_PTRB: 32,
      TNS_DATA_TYPE_PTRW: 33,
      TNS_DATA_TYPE_OER8: 34 + 256,
      TNS_DATA_TYPE_FUN: 35 + 256,
      TNS_DATA_TYPE_AUA: 36 + 256,
      TNS_DATA_TYPE_RXH7: 37 + 256,
      TNS_DATA_TYPE_NA6: 38 + 256,
      TNS_DATA_TYPE_OAC9: 39,
      TNS_DATA_TYPE_AMS: 40,
      TNS_DATA_TYPE_BRN: 41,
      TNS_DATA_TYPE_BRP: 42 + 256,
      TNS_DATA_TYPE_BRV: 43 + 256,
      TNS_DATA_TYPE_KVA: 44 + 256,
      TNS_DATA_TYPE_CLS: 45 + 256,
      TNS_DATA_TYPE_CUI: 46 + 256,
      TNS_DATA_TYPE_DFN: 47 + 256,
      TNS_DATA_TYPE_DQR: 48 + 256,
      TNS_DATA_TYPE_DSC: 49 + 256,
      TNS_DATA_TYPE_EXE: 50 + 256,
      TNS_DATA_TYPE_FCH: 51 + 256,
      TNS_DATA_TYPE_GBV: 52 + 256,
      TNS_DATA_TYPE_GEM: 53 + 256,
      TNS_DATA_TYPE_GIV: 54 + 256,
      TNS_DATA_TYPE_OKG: 55 + 256,
      TNS_DATA_TYPE_HMI: 56 + 256,
      TNS_DATA_TYPE_INO: 57 + 256,
      TNS_DATA_TYPE_LNF: 59 + 256,
      TNS_DATA_TYPE_ONT: 60 + 256,
      TNS_DATA_TYPE_OPE: 61 + 256,
      TNS_DATA_TYPE_OSQ: 62 + 256,
      TNS_DATA_TYPE_SFE: 63 + 256,
      TNS_DATA_TYPE_SPF: 64 + 256,
      TNS_DATA_TYPE_VSN: 65 + 256,
      TNS_DATA_TYPE_UD7: 66 + 256,
      TNS_DATA_TYPE_DSA: 67 + 256,
      TNS_DATA_TYPE_UIN: 68,
      TNS_DATA_TYPE_PIN: 71 + 256,
      TNS_DATA_TYPE_PFN: 72 + 256,
      TNS_DATA_TYPE_PPT: 73 + 256,
      TNS_DATA_TYPE_STO: 75 + 256,
      TNS_DATA_TYPE_ARC: 77 + 256,
      TNS_DATA_TYPE_MRS: 78 + 256,
      TNS_DATA_TYPE_MRT: 79 + 256,
      TNS_DATA_TYPE_MRG: 80 + 256,
      TNS_DATA_TYPE_MRR: 81 + 256,
      TNS_DATA_TYPE_MRC: 82 + 256,
      TNS_DATA_TYPE_VER: 83 + 256,
      TNS_DATA_TYPE_LON2: 84 + 256,
      TNS_DATA_TYPE_INO2: 85 + 256,
      TNS_DATA_TYPE_ALL: 86 + 256,
      TNS_DATA_TYPE_UDB: 87 + 256,
      TNS_DATA_TYPE_AQI: 88 + 256,
      TNS_DATA_TYPE_ULB: 89 + 256,
      TNS_DATA_TYPE_ULD: 90 + 256,
      TNS_DATA_TYPE_SLS: 91,
      TNS_DATA_TYPE_SID: 92 + 256,
      TNS_DATA_TYPE_NA7: 93 + 256,
      TNS_DATA_TYPE_LVC: 94,
      TNS_DATA_TYPE_LVB: 95,
      TNS_DATA_TYPE_CHAR: 96,
      TNS_DATA_TYPE_AVC: 97,
      TNS_DATA_TYPE_AL7: 98 + 256,
      TNS_DATA_TYPE_K2RPC: 99 + 256,
      TNS_DATA_TYPE_BINARY_FLOAT: 100,
      TNS_DATA_TYPE_BINARY_DOUBLE: 101,
      TNS_DATA_TYPE_CURSOR: 102,
      TNS_DATA_TYPE_RDD: 104,
      TNS_DATA_TYPE_XDP: 103 + 256,
      TNS_DATA_TYPE_OSL: 106,
      TNS_DATA_TYPE_OKO8: 107 + 256,
      TNS_DATA_TYPE_EXT_NAMED: 108,
      TNS_DATA_TYPE_INT_NAMED: 109,
      TNS_DATA_TYPE_EXT_REF: 110,
      TNS_DATA_TYPE_INT_REF: 111,
      TNS_DATA_TYPE_CLOB: 112,
      TNS_DATA_TYPE_BLOB: 113,
      TNS_DATA_TYPE_BFILE: 114,
      TNS_DATA_TYPE_CFILE: 115,
      TNS_DATA_TYPE_RSET: 116,
      TNS_DATA_TYPE_CWD: 117,
      TNS_DATA_TYPE_JSON: 119,
      TNS_DATA_TYPE_OAC122: 120,
      TNS_DATA_TYPE_UD12: 124 + 256,
      TNS_DATA_TYPE_AL8: 125 + 256,
      TNS_DATA_TYPE_LFOP: 126 + 256,
      TNS_DATA_TYPE_VECTOR: 127,
      TNS_DATA_TYPE_FCRT: 127 + 256,
      TNS_DATA_TYPE_DNY: 128 + 256,
      TNS_DATA_TYPE_OPR: 129 + 256,
      TNS_DATA_TYPE_PLS: 130 + 256,
      TNS_DATA_TYPE_XID: 131 + 256,
      TNS_DATA_TYPE_TXN: 132 + 256,
      TNS_DATA_TYPE_DCB: 133 + 256,
      TNS_DATA_TYPE_CCA: 134 + 256,
      TNS_DATA_TYPE_WRN: 135 + 256,
      TNS_DATA_TYPE_TLH: 137 + 256,
      TNS_DATA_TYPE_TOH: 138 + 256,
      TNS_DATA_TYPE_FOI: 139 + 256,
      TNS_DATA_TYPE_SID2: 140 + 256,
      TNS_DATA_TYPE_TCH: 141 + 256,
      TNS_DATA_TYPE_PII: 142 + 256,
      TNS_DATA_TYPE_PFI: 143 + 256,
      TNS_DATA_TYPE_PPU: 144 + 256,
      TNS_DATA_TYPE_PTE: 145 + 256,
      TNS_DATA_TYPE_CLV: 146,
      TNS_DATA_TYPE_RXH8: 148 + 256,
      TNS_DATA_TYPE_N12: 149 + 256,
      TNS_DATA_TYPE_AUTH: 150 + 256,
      TNS_DATA_TYPE_KVAL: 151 + 256,
      TNS_DATA_TYPE_DTR: 152,
      TNS_DATA_TYPE_DUN: 153,
      TNS_DATA_TYPE_DOP: 154,
      TNS_DATA_TYPE_VST: 155,
      TNS_DATA_TYPE_ODT: 156,
      TNS_DATA_TYPE_FGI: 157 + 256,
      TNS_DATA_TYPE_DSY: 158 + 256,
      TNS_DATA_TYPE_DSYR8: 159 + 256,
      TNS_DATA_TYPE_DSYH8: 160 + 256,
      TNS_DATA_TYPE_DSYL: 161 + 256,
      TNS_DATA_TYPE_DSYT8: 162 + 256,
      TNS_DATA_TYPE_DSYV8: 163 + 256,
      TNS_DATA_TYPE_DSYP: 164 + 256,
      TNS_DATA_TYPE_DSYF: 165 + 256,
      TNS_DATA_TYPE_DSYK: 166 + 256,
      TNS_DATA_TYPE_DSYY: 167 + 256,
      TNS_DATA_TYPE_DSYQ: 168 + 256,
      TNS_DATA_TYPE_DSYC: 169 + 256,
      TNS_DATA_TYPE_DSYA: 170 + 256,
      TNS_DATA_TYPE_OT8: 171 + 256,
      TNS_DATA_TYPE_DOL: 172,
      TNS_DATA_TYPE_DSYTY: 173 + 256,
      TNS_DATA_TYPE_AQE: 174 + 256,
      TNS_DATA_TYPE_KV: 175 + 256,
      TNS_DATA_TYPE_AQD: 176 + 256,
      TNS_DATA_TYPE_AQ8: 177 + 256,
      TNS_DATA_TYPE_TIME: 178,
      TNS_DATA_TYPE_TIME_TZ: 179,
      TNS_DATA_TYPE_TIMESTAMP: 180,
      TNS_DATA_TYPE_TIMESTAMP_TZ: 181,
      TNS_DATA_TYPE_INTERVAL_YM: 182,
      TNS_DATA_TYPE_INTERVAL_DS: 183,
      TNS_DATA_TYPE_EDATE: 184,
      TNS_DATA_TYPE_ETIME: 185,
      TNS_DATA_TYPE_ETTZ: 186,
      TNS_DATA_TYPE_ESTAMP: 187,
      TNS_DATA_TYPE_ESTZ: 188,
      TNS_DATA_TYPE_EIYM: 189,
      TNS_DATA_TYPE_EIDS: 190,
      TNS_DATA_TYPE_RFS: 193 + 256,
      TNS_DATA_TYPE_RXH10: 194 + 256,
      TNS_DATA_TYPE_DCLOB: 195,
      TNS_DATA_TYPE_DBLOB: 196,
      TNS_DATA_TYPE_DBFILE: 197,
      TNS_DATA_TYPE_DJSON: 198,
      TNS_DATA_TYPE_KPN: 198 + 256,
      TNS_DATA_TYPE_KPDNR: 199 + 256,
      TNS_DATA_TYPE_DSYD: 200 + 256,
      TNS_DATA_TYPE_DSYS: 201 + 256,
      TNS_DATA_TYPE_DSYR: 202 + 256,
      TNS_DATA_TYPE_DSYH: 203 + 256,
      TNS_DATA_TYPE_DSYT: 204 + 256,
      TNS_DATA_TYPE_DSYV: 205 + 256,
      TNS_DATA_TYPE_AQM: 206 + 256,
      TNS_DATA_TYPE_OER11: 207 + 256,
      TNS_DATA_TYPE_UROWID: 208,
      TNS_DATA_TYPE_AQL: 210 + 256,
      TNS_DATA_TYPE_OTC: 211 + 256,
      TNS_DATA_TYPE_KFNO: 212 + 256,
      TNS_DATA_TYPE_KFNP: 213 + 256,
      TNS_DATA_TYPE_KGT8: 214 + 256,
      TNS_DATA_TYPE_RASB4: 215 + 256,
      TNS_DATA_TYPE_RAUB2: 216 + 256,
      TNS_DATA_TYPE_RAUB1: 217 + 256,
      TNS_DATA_TYPE_RATXT: 218 + 256,
      TNS_DATA_TYPE_RSSB4: 219 + 256,
      TNS_DATA_TYPE_RSUB2: 220 + 256,
      TNS_DATA_TYPE_RSUB1: 221 + 256,
      TNS_DATA_TYPE_RSTXT: 222 + 256,
      TNS_DATA_TYPE_RIDL: 223 + 256,
      TNS_DATA_TYPE_GLRDD: 224 + 256,
      TNS_DATA_TYPE_GLRDG: 225 + 256,
      TNS_DATA_TYPE_GLRDC: 226 + 256,
      TNS_DATA_TYPE_OKO: 227 + 256,
      TNS_DATA_TYPE_DPP: 228 + 256,
      TNS_DATA_TYPE_DPLS: 229 + 256,
      TNS_DATA_TYPE_DPMOP: 230 + 256,
      TNS_DATA_TYPE_TIMESTAMP_LTZ: 231,
      TNS_DATA_TYPE_ESITZ: 232,
      TNS_DATA_TYPE_UB8: 233,
      TNS_DATA_TYPE_STAT: 234 + 256,
      TNS_DATA_TYPE_RFX: 235 + 256,
      TNS_DATA_TYPE_FAL: 236 + 256,
      TNS_DATA_TYPE_CKV: 237 + 256,
      TNS_DATA_TYPE_DRCX: 238 + 256,
      TNS_DATA_TYPE_KGH: 239 + 256,
      TNS_DATA_TYPE_AQO: 240 + 256,
      TNS_DATA_TYPE_PNTY: 241,
      TNS_DATA_TYPE_OKGT: 242 + 256,
      TNS_DATA_TYPE_KPFC: 243 + 256,
      TNS_DATA_TYPE_FE2: 244 + 256,
      TNS_DATA_TYPE_SPFP: 245 + 256,
      TNS_DATA_TYPE_DPULS: 246 + 256,
      TNS_DATA_TYPE_BOOLEAN: 252,
      TNS_DATA_TYPE_AQA: 253 + 256,
      TNS_DATA_TYPE_KPBF: 254 + 256,
      TNS_DATA_TYPE_TSM: 513,
      TNS_DATA_TYPE_MSS: 514,
      TNS_DATA_TYPE_KPC: 516,
      TNS_DATA_TYPE_CRS: 517,
      TNS_DATA_TYPE_KKS: 518,
      TNS_DATA_TYPE_KSP: 519,
      TNS_DATA_TYPE_KSPTOP: 520,
      TNS_DATA_TYPE_KSPVAL: 521,
      TNS_DATA_TYPE_PSS: 522,
      TNS_DATA_TYPE_NLS: 523,
      TNS_DATA_TYPE_ALS: 524,
      TNS_DATA_TYPE_KSDEVTVAL: 525,
      TNS_DATA_TYPE_KSDEVTTOP: 526,
      TNS_DATA_TYPE_KPSPP: 527,
      TNS_DATA_TYPE_KOL: 528,
      TNS_DATA_TYPE_LST: 529,
      TNS_DATA_TYPE_ACX: 530,
      TNS_DATA_TYPE_SCS: 531,
      TNS_DATA_TYPE_RXH: 532,
      TNS_DATA_TYPE_KPDNS: 533,
      TNS_DATA_TYPE_KPDCN: 534,
      TNS_DATA_TYPE_KPNNS: 535,
      TNS_DATA_TYPE_KPNCN: 536,
      TNS_DATA_TYPE_KPS: 537,
      TNS_DATA_TYPE_APINF: 538,
      TNS_DATA_TYPE_TEN: 539,
      TNS_DATA_TYPE_XSSCS: 540,
      TNS_DATA_TYPE_XSSSO: 541,
      TNS_DATA_TYPE_XSSAO: 542,
      TNS_DATA_TYPE_KSRPC: 543,
      TNS_DATA_TYPE_KVL: 560,
      TNS_DATA_TYPE_SESSGET: 563,
      TNS_DATA_TYPE_SESSREL: 564,
      TNS_DATA_TYPE_XSSDEF: 565,
      TNS_DATA_TYPE_PDQCINV: 572,
      TNS_DATA_TYPE_PDQIDC: 573,
      TNS_DATA_TYPE_KPDQCSTA: 574,
      TNS_DATA_TYPE_KPRS: 575,
      TNS_DATA_TYPE_KPDQIDC: 576,
      TNS_DATA_TYPE_RTSTRM: 578,
      TNS_DATA_TYPE_SESSRET: 579,
      TNS_DATA_TYPE_SCN6: 580,
      TNS_DATA_TYPE_KECPA: 581,
      TNS_DATA_TYPE_KECPP: 582,
      TNS_DATA_TYPE_SXA: 583,
      TNS_DATA_TYPE_KVARR: 584,
      TNS_DATA_TYPE_KPNGN: 585,
      TNS_DATA_TYPE_XSNSOP: 590,
      TNS_DATA_TYPE_XSATTR: 591,
      TNS_DATA_TYPE_XSNS: 592,
      TNS_DATA_TYPE_TXT: 593,
      TNS_DATA_TYPE_XSSESSNS: 594,
      TNS_DATA_TYPE_XSATTOP: 595,
      TNS_DATA_TYPE_XSCREOP: 596,
      TNS_DATA_TYPE_XSDETOP: 597,
      TNS_DATA_TYPE_XSDESOP: 598,
      TNS_DATA_TYPE_XSSETSP: 599,
      TNS_DATA_TYPE_XSSIDP: 600,
      TNS_DATA_TYPE_XSPRIN: 601,
      TNS_DATA_TYPE_XSKVL: 602,
      TNS_DATA_TYPE_XSSSDEF2: 603,
      TNS_DATA_TYPE_XSNSOP2: 604,
      TNS_DATA_TYPE_XSNS2: 605,
      TNS_DATA_TYPE_IMPLRES: 611,
      TNS_DATA_TYPE_OER19: 612,
      TNS_DATA_TYPE_UB1ARRAY: 613,
      TNS_DATA_TYPE_SESSSTATE: 614,
      TNS_DATA_TYPE_AC_REPLAY: 615,
      TNS_DATA_TYPE_AC_CONT: 616,
      TNS_DATA_TYPE_KPDNREQ: 622,
      TNS_DATA_TYPE_KPDNRNF: 623,
      TNS_DATA_TYPE_KPNGNC: 624,
      TNS_DATA_TYPE_KPNRI: 625,
      TNS_DATA_TYPE_AQENQ: 626,
      TNS_DATA_TYPE_AQDEQ: 627,
      TNS_DATA_TYPE_AQJMS: 628,
      TNS_DATA_TYPE_KPDNRPAY: 629,
      TNS_DATA_TYPE_KPDNRACK: 630,
      TNS_DATA_TYPE_KPDNRMP: 631,
      TNS_DATA_TYPE_KPDNRDQ: 632,
      TNS_DATA_TYPE_CHUNKINFO: 636,
      TNS_DATA_TYPE_SCN: 637,
      TNS_DATA_TYPE_SCN8: 638,
      TNS_DATA_TYPE_UD21: 639,
      TNS_DATA_TYPE_TNP: 640,
      TNS_DATA_TYPE_OAC: 646,
      TNS_DATA_TYPE_SESSSIGN: 647,
      TNS_DATA_TYPE_OER: 652,
      TNS_DATA_TYPE_UDS: 663,
      // data type representations
      TNS_TYPE_REP_NATIVE: 0,
      TNS_TYPE_REP_UNIVERSAL: 1,
      TNS_TYPE_REP_ORACLE: 10,
      // message types
      TNS_MSG_TYPE_PROTOCOL: 1,
      TNS_MSG_TYPE_DATA_TYPES: 2,
      TNS_MSG_TYPE_FUNCTION: 3,
      TNS_MSG_TYPE_ERROR: 4,
      TNS_MSG_TYPE_ROW_HEADER: 6,
      TNS_MSG_TYPE_ROW_DATA: 7,
      TNS_MSG_TYPE_PARAMETER: 8,
      TNS_MSG_TYPE_STATUS: 9,
      TNS_MSG_TYPE_IO_VECTOR: 11,
      TNS_MSG_TYPE_LOB_DATA: 14,
      TNS_MSG_TYPE_WARNING: 15,
      TNS_MSG_TYPE_DESCRIBE_INFO: 16,
      TNS_MSG_TYPE_PIGGYBACK: 17,
      TNS_MSG_TYPE_FLUSH_OUT_BINDS: 19,
      TNS_MSG_TYPE_BIT_VECTOR: 21,
      TNS_MSG_TYPE_SERVER_SIDE_PIGGYBACK: 23,
      TNS_MSG_TYPE_ONEWAY_FN: 26,
      TNS_MSG_TYPE_IMPLICIT_RESULTSET: 27,
      TNS_MSG_TYPE_RENEGOTIATE: 28,
      TNS_MSG_TYPE_END_OF_REQUEST: 29,
      TNS_MSG_TYPE_FAST_AUTH: 34,
      // parameter keyword numbers,
      TNS_KEYWORD_NUM_CURRENT_SCHEMA: 168,
      TNS_KEYWORD_NUM_EDITION: 172,
      TNS_KEYWORD_NUM_TRANSACTION_ID: 201,
      // bind flags
      TNS_BIND_USE_INDICATORS: 1,
      TNS_BIND_USE_LENGTH: 2,
      TNS_BIND_ARRAY: 64,
      // bind directions
      TNS_BIND_DIR_OUTPUT: 16,
      TNS_BIND_DIR_INPUT: 32,
      TNS_BIND_DIR_INPUT_OUTPUT: 48,
      // execute options
      TNS_EXEC_OPTION_PARSE: 1,
      TNS_EXEC_OPTION_BIND: 8,
      TNS_EXEC_OPTION_DEFINE: 16,
      TNS_EXEC_OPTION_EXECUTE: 32,
      TNS_EXEC_OPTION_FETCH: 64,
      TNS_EXEC_OPTION_COMMIT: 256,
      TNS_EXEC_OPTION_COMMIT_REEXECUTE: 1,
      TNS_EXEC_OPTION_PLSQL_BIND: 1024,
      TNS_EXEC_OPTION_DML_ROWCOUNTS: 16384,
      TNS_EXEC_OPTION_NOT_PLSQL: 32768,
      TNS_EXEC_OPTION_IMPLICIT_RESULTSET: 32768,
      TNS_EXEC_OPTION_DESCRIBE: 131072,
      TNS_EXEC_OPTION_NO_COMPRESSED_FETCH: 262144,
      TNS_EXEC_OPTION_BATCH_ERRORS: 524288,
      TNS_EXEC_OPTION_NO_IMPL_REL: 2097152,
      // server side piggyback op codes
      TNS_SERVER_PIGGYBACK_QUERY_CACHE_INVALIDATION: 1,
      TNS_SERVER_PIGGYBACK_OS_PID_MTS: 2,
      TNS_SERVER_PIGGYBACK_TRACE_EVENT: 3,
      TNS_SERVER_PIGGYBACK_SESS_RET: 4,
      TNS_SERVER_PIGGYBACK_SYNC: 5,
      TNS_SERVER_PIGGYBACK_LTXID: 7,
      TNS_SERVER_PIGGYBACK_AC_REPLAY_CONTEXT: 8,
      TNS_SERVER_PIGGYBACK_EXT_SYNC: 9,
      TNS_SERVER_PIGGYBACK_SESS_SIGNATURE: 10,
      // session return constants
      TNS_SESSGET_SESSION_CHANGED: 4,
      // LOB operations
      TNS_LOB_OP_GET_LENGTH: 1,
      TNS_LOB_OP_READ: 2,
      TNS_LOB_OP_TRIM: 32,
      TNS_LOB_OP_WRITE: 64,
      TNS_LOB_OP_GET_CHUNK_SIZE: 16384,
      TNS_LOB_OP_CREATE_TEMP: 272,
      TNS_LOB_OP_FREE_TEMP: 273,
      TNS_LOB_OP_OPEN: 32768,
      TNS_LOB_OP_CLOSE: 65536,
      TNS_LOB_OP_IS_OPEN: 69632,
      TNS_LOB_OP_ARRAY: 524288,
      TNS_LOB_OP_FILE_OPEN: 256,
      TNS_LOB_OP_FILE_CLOSE: 512,
      TNS_LOB_OP_FILE_ISOPEN: 1024,
      TNS_LOB_OP_FILE_EXISTS: 2048,
      // LOB locator constants
      TNS_LOB_LOC_OFFSET_FLAG_1: 4,
      TNS_LOB_LOC_OFFSET_FLAG_3: 6,
      TNS_LOB_LOC_OFFSET_FLAG_4: 7,
      TNS_LOB_QLOCATOR_VERSION: 4,
      TNS_LOB_LOC_FIXED_OFFSET: 16,
      // LOB locator flags (byte 1)
      TNS_LOB_LOC_FLAGS_BLOB: 1,
      TNS_LOB_LOC_FLAGS_VALUE_BASED: 32,
      TNS_LOB_LOC_FLAGS_ABSTRACT: 64,
      // LOB locator flags (byte 2)
      TNS_LOB_LOC_FLAGS_INIT: 8,
      // LOB locator flags (byte 4)
      TNS_LOB_LOC_FLAGS_TEMP: 1,
      TNS_LOB_LOC_FLAGS_VAR_LENGTH_CHARSET: 128,
      // other LOB constants
      TNS_LOB_OPEN_READ_WRITE: 2,
      TNS_LOB_OPEN_READ_ONLY: 11,
      TNS_LOB_PREFETCH_FLAG: 33554432,
      // base JSON constants
      TNS_JSON_MAX_LENGTH: 32 * 1024 * 1024,
      // end-to-end metrics
      TNS_END_TO_END_ACTION: 16,
      TNS_END_TO_END_CLIENT_IDENTIFIER: 1,
      TNS_END_TO_END_CLIENT_INFO: 256,
      TNS_END_TO_END_DBOP: 512,
      TNS_END_TO_END_MODULE: 8,
      // versions
      TNS_VERSION_MIN_ACCEPTED: 315,
      TNS_VERSION_MIN_LARGE_SDU: 315,
      // TTC functions
      TNS_FUNC_AUTH_PHASE_ONE: 118,
      TNS_FUNC_AUTH_PHASE_TWO: 115,
      TNS_FUNC_CLOSE_CURSORS: 105,
      TNS_FUNC_COMMIT: 14,
      TNS_FUNC_EXECUTE: 94,
      TNS_FUNC_FETCH: 5,
      TNS_FUNC_LOB_OP: 96,
      TNS_FUNC_LOGOFF: 9,
      TNS_FUNC_PING: 147,
      TNS_FUNC_ROLLBACK: 15,
      TNS_FUNC_SET_END_TO_END_ATTR: 135,
      TNS_FUNC_REEXECUTE: 4,
      TNS_FUNC_REEXECUTE_AND_FETCH: 78,
      TNS_FUNC_SET_SCHEMA: 152,
      TNS_FUNC_SESSION_GET: 162,
      TNS_FUNC_SESSION_RELEASE: 163,
      TNS_FUNC_SESSION_STATE: 176,
      // piggyback fn
      TNS_FUNC_CANCEL_ALL: 120,
      // piggyback fn
      TNS_FUNC_TPC_TXN_SWITCH: 103,
      TNS_FUNC_TPC_TXN_CHANGE_STATE: 104,
      TNS_FUNC_AQ_ENQ: 121,
      TNS_FUNC_AQ_DEQ: 122,
      TNS_FUNC_ARRAY_AQ: 145,
      // character sets and encodings
      TNS_CHARSET_UTF8: 873,
      TNS_CHARSET_UTF16: 2e3,
      TNS_ENCODING_UTF8: "UTF-8",
      TNS_ENCODING_UTF16: "UTF-16LE",
      TNS_ENCODING_MULTI_BYTE: 1,
      TNS_ENCODING_CONV_LENGTH: 2,
      // compile time capability indices
      TNS_CCAP_SQL_VERSION: 0,
      TNS_CCAP_LOGON_TYPES: 4,
      TNS_CCAP_CTB_FEATURE_BACKPORT: 5,
      TNS_CCAP_FIELD_VERSION: 7,
      TNS_CCAP_SERVER_DEFINE_CONV: 8,
      TNS_CCAP_DEQUEUE_WITH_SELECTOR: 9,
      TNS_CCAP_TTC1: 15,
      TNS_CCAP_OCI1: 16,
      TNS_CCAP_TDS_VERSION: 17,
      TNS_CCAP_RPC_VERSION: 18,
      TNS_CCAP_RPC_SIG: 19,
      TNS_CCAP_DBF_VERSION: 21,
      TNS_CCAP_LOB: 23,
      TNS_CCAP_TTC2: 26,
      TNS_CCAP_UB2_DTY: 27,
      TNS_CCAP_OCI2: 31,
      TNS_CCAP_CLIENT_FN: 34,
      TNS_CCAP_OCI3: 35,
      TNS_CCAP_TTC3: 37,
      TNS_CCAP_SESS_SIGNATURE_VERSION: 39,
      TNS_CCAP_TTC4: 40,
      TNS_CCAP_LOB2: 42,
      TNS_CCAP_TTC5: 44,
      TNS_CCAP_VECTOR_FEATURES: 52,
      TNS_CCAP_MAX: 53,
      // compile time capability values
      TNS_CCAP_SQL_VERSION_MAX: 6,
      TNS_CCAP_FIELD_VERSION_11_2: 6,
      TNS_CCAP_FIELD_VERSION_12_1: 7,
      TNS_CCAP_FIELD_VERSION_12_2: 8,
      TNS_CCAP_FIELD_VERSION_12_2_EXT1: 9,
      TNS_CCAP_FIELD_VERSION_18_1: 10,
      TNS_CCAP_FIELD_VERSION_18_1_EXT_1: 11,
      TNS_CCAP_FIELD_VERSION_19_1: 12,
      TNS_CCAP_FIELD_VERSION_19_1_EXT_1: 13,
      TNS_CCAP_FIELD_VERSION_20_1: 14,
      TNS_CCAP_FIELD_VERSION_20_1_EXT_1: 15,
      TNS_CCAP_FIELD_VERSION_21_1: 16,
      TNS_CCAP_FIELD_VERSION_23_1: 17,
      TNS_CCAP_FIELD_VERSION_23_1_EXT_1: 18,
      TNS_CCAP_FIELD_VERSION_23_1_EXT_2: 19,
      TNS_CCAP_FIELD_VERSION_23_1_EXT_3: 20,
      TNS_CCAP_FIELD_VERSION_23_1_EXT_4: 21,
      TNS_CCAP_FIELD_VERSION_23_1_EXT_5: 22,
      TNS_CCAP_FIELD_VERSION_23_1_EXT_6: 23,
      TNS_CCAP_FIELD_VERSION_23_4: 24,
      TNS_CCAP_FIELD_VERSION_MAX: 24,
      TNS_CCAP_O5LOGON: 8,
      TNS_CCAP_O5LOGON_NP: 2,
      TNS_CCAP_O7LOGON: 32,
      TNS_CCAP_O8LOGON_LONG_IDENTIFIER: 64,
      TNS_CCAP_O9LOGON_LONG_PASSWORD: 128,
      TNS_CCAP_END_OF_CALL_STATUS: 1,
      TNS_CCAP_IND_RCD: 8,
      TNS_CCAP_FAST_BVEC: 32,
      TNS_CCAP_FAST_SESSION_PROPAGATE: 16,
      TNS_CCAP_APP_CTX_PIGGYBACK: 128,
      TNS_CCAP_TDS_VERSION_MAX: 3,
      TNS_CCAP_RPC_VERSION_MAX: 7,
      TNS_CCAP_RPC_SIG_VALUE: 3,
      TNS_CCAP_DBF_VERSION_MAX: 1,
      TNS_CCAP_LTXID: 8,
      TNS_CCAP_IMPLICIT_RESULTS: 16,
      TNS_CCAP_BIG_CHUNK_CLR: 32,
      TNS_CCAP_KEEP_OUT_ORDER: 128,
      TNS_CCAP_LOB_UB8_SIZE: 1,
      TNS_CCAP_LOB_ENCS: 2,
      TNS_CCAP_LOB_PREFETCH_DATA: 4,
      TNS_CCAP_LOB_TEMP_SIZE: 8,
      TNS_CCAP_LOB_PREFETCH: 64,
      TNS_CCAP_LOB_12C: 128,
      TNS_CCAP_DRCP: 16,
      TNS_CCAP_ZLNP: 4,
      TNS_CCAP_INBAND_NOTIFICATION: 4,
      TNS_CCAP_END_OF_REQUEST: 32,
      TNS_CCAP_CLIENT_FN_MAX: 12,
      TNS_CCAP_LOB2_QUASI: 1,
      TNS_CCAP_LOB2_2GB_PREFETCH: 4,
      TNS_CCAP_CTB_IMPLICIT_POOL: 8,
      TNS_CCAP_CTB_OAUTH_MSG_ON_ERR: 16,
      TNS_CCAP_VECTOR_SUPPORT: 8,
      TNS_CCAP_VECTOR_FEATURE_BINARY: 1,
      TNS_CCAP_VECTOR_FEATURE_SPARSE: 2,
      TNS_CCAP_TTC5_SESSIONLESS_TXNS: 32,
      TNS_CCAP_OCI3_OCSSYNC: 32,
      // runtime capability indices
      TNS_RCAP_COMPAT: 0,
      TNS_RCAP_TTC: 6,
      TNS_RCAP_MAX: 7,
      // runtime capability values
      TNS_RCAP_COMPAT_81: 2,
      TNS_RCAP_TTC_ZERO_COPY: 1,
      TNS_RCAP_TTC_32K: 4,
      /** Verifier types. */
      /**  SHA1 (salted). */
      TNS_VERIFIER_TYPE_11G_1: 45394,
      TNS_VERIFIER_TYPE_11G_2: 6949,
      /** MultiRound SHA-512. */
      TNS_VERIFIER_TYPE_12C: 18453,
      // UDS flags
      TNS_UDS_FLAGS_IS_JSON: 256,
      TNS_UDS_FLAGS_IS_OSON: 2048,
      // end of call status flags
      TNS_EOCS_FLAGS_TXN_IN_PROGRESS: 2,
      TNS_EOCS_FLAGS_SESS_RELEASE: 32768,
      // transaction switching op codes
      TNS_TPC_TXN_START: 1,
      TNS_TPC_TXN_DETACH: 2,
      TNS_TPC_TXN_POST_DETACH: 4,
      // transaction change state op codes
      TNS_TPC_TXN_COMMIT: 1,
      TNS_TPC_TXN_ABORT: 2,
      TNS_TPC_TXN_PREPARE: 3,
      TNS_TPC_TXN_FORGET: 4,
      // transaction states
      TNS_TPC_TXN_STATE_PREPARE: 0,
      TNS_TPC_TXN_STATE_REQUIRES_COMMIT: 1,
      TNS_TPC_TXN_STATE_COMMITTED: 2,
      TNS_TPC_TXN_STATE_ABORTED: 3,
      TNS_TPC_TXN_STATE_READ_ONLY: 4,
      TNS_TPC_TXN_STATE_FORGOTTEN: 5,
      // sessionless transaction flag
      TNS_TPC_TRANS_SESSIONLESS: 16,
      // sessionless transaction format
      TNS_TPC_TRANS_SESSIONLESS_FORMAT: 5135422,
      // sessionless sync version
      TNS_TPC_TRANS_TRANSACTION_ID_SYNC_VERSION_1: 1,
      // sessionless server states
      TNS_TPC_TRANS_TRANSACTION_ID_SYNC_SET: 64,
      TNS_TPC_TRANS_TRANSACTION_ID_SYNC_UNSET: 128,
      // sessionless state reason
      TNS_TPC_TRANS_TRANSACTION_ID_SYNC_SERVER: 1,
      TNS_TPC_TRANS_TRANSACTION_ID_SYNC_CLIENT: 2,
      TNS_TPC_TRANS_TRANSACTION_ID_SYNC_TXEND_XA: 3,
      // AQ Delivery modes
      TNS_AQ_MSG_PERSISTENT: constants.AQ_MSG_DELIV_MODE_PERSISTENT,
      TNS_AQ_MSG_BUFFERED: constants.AQ_MSG_DELIV_MODE_BUFFERED,
      TNS_AQ_MSG_PERSISTENT_OR_BUFFERED: constants.AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED,
      // AQ dequeue modes
      TNS_AQ_DEQ_BROWSE: 1,
      TNS_AQ_DEQ_LOCKED: 2,
      TNS_AQ_DEQ_REMOVE: 3,
      TNS_AQ_DEQ_REMOVE_NODATA: 4,
      // AQ dequeue navigation modes
      TNS_AQ_DEQ_FIRST_MSG: 1,
      TNS_AQ_DEQ_NEXT_MSG: 3,
      TNS_AQ_DEQ_NEXT_TRANSACTION: 2,
      // AQ dequeue visibility modes
      TNS_AQ_DEQ_IMMEDIATE: 1,
      TNS_AQ_DEQ_ON_COMMIT: 2,
      // AQ dequeue wait modes
      TNS_AQ_DEQ_NO_WAIT: 0,
      TNS_AQ_DEQ_WAIT_FOREVER: 4294967295,
      // AQ enqueue visibility modes
      TNS_AQ_ENQ_IMMEDIATE: 1,
      TNS_AQ_ENQ_ON_COMMIT: 2,
      // AQ message states
      TNS_AQ_MSG_EXPIRED: 3,
      TNS_AQ_MSG_PROCESSED: 2,
      TNS_AQ_MSG_READY: 0,
      TNS_AQ_MSG_WAITING: 1,
      // AQ other constants
      TNS_AQ_MSG_NO_DELAY: 0,
      TNS_AQ_MSG_NO_EXPIRATION: -1,
      TNS_AQ_ARRAY_ENQ: 1,
      TNS_AQ_ARRAY_DEQ: 2,
      TNS_AQ_ARRAY_FLAGS_RETURN_MESSAGE_ID: 1,
      TNS_TTC_ENQ_STREAMING_ENABLED: 1,
      TNS_TTC_ENQ_STREAMING_DISABLED: 0,
      // AQ flags
      TNS_KPD_AQ_BUFMSG: 2,
      TNS_KPD_AQ_EITHER: 16,
      TNS_AQ_MESSAGE_ID_LENGTH: 16,
      TNS_AQ_MESSAGE_VERSION: 1,
      TNS_AQ_EXT_KEYWORD_AGENT_NAME: 64,
      TNS_AQ_EXT_KEYWORD_AGENT_ADDRESS: 65,
      TNS_AQ_EXT_KEYWORD_AGENT_PROTOCOL: 66,
      TNS_AQ_EXT_KEYWORD_ORIGINAL_MSGID: 69,
      // other constants
      TNS_ESCAPE_CHAR: 253,
      TNS_LONG_LENGTH_INDICATOR: dataHandlerConstants.TNS_LONG_LENGTH_INDICATOR,
      TNS_NULL_LENGTH_INDICATOR: dataHandlerConstants.TNS_NULL_LENGTH_INDICATOR,
      TNS_MAX_ROWID_LENGTH: 18,
      TNS_DURATION_SESSION: 10,
      TNS_MAX_LONG_LENGTH: 2147483647,
      TNS_SDU: 8192,
      TNS_TDU: 65535,
      TNS_MAX_CONNECT_DATA: 230,
      TNS_MAX_UROWID_LENGTH: 3950,
      TNS_SERVER_CONVERTS_CHARS: 1,
      // server does charset conversion
      // drcp release mode
      DRCP_DEAUTHENTICATE: 2,
      // database object image flags
      TNS_OBJ_IS_VERSION_81: 128,
      TNS_OBJ_IS_DEGENERATE: 16,
      TNS_OBJ_IS_COLLECTION: 8,
      TNS_OBJ_NO_PREFIX_SEG: 4,
      TNS_OBJ_IMAGE_VERSION: 1,
      // database object flags
      TNS_OBJ_MAX_SHORT_LENGTH: 245,
      TNS_OBJ_ATOMIC_NULL: 253,
      TNS_OBJ_NON_NULL_OID: 2,
      TNS_OBJ_HAS_EXTENT_OID: 8,
      TNS_OBJ_TOP_LEVEL: 1,
      TNS_OBJ_HAS_INDEXES: 16,
      // database object collection types
      TNS_OBJ_PLSQL_INDEX_TABLE: 1,
      TNS_OBJ_NESTED_TABLE: 2,
      TNS_OBJ_VARRAY: 3,
      // database object TDS type codes
      TNS_OBJ_TDS_TYPE_CHAR: 1,
      TNS_OBJ_TDS_TYPE_DATE: 2,
      TNS_OBJ_TDS_TYPE_FLOAT: 5,
      TNS_OBJ_TDS_TYPE_NUMBER: 6,
      TNS_OBJ_TDS_TYPE_VARCHAR: 7,
      TNS_OBJ_TDS_TYPE_BOOLEAN: 8,
      TNS_OBJ_TDS_TYPE_RAW: 19,
      TNS_OBJ_TDS_TYPE_TIMESTAMP: 21,
      TNS_OBJ_TDS_TYPE_TIMESTAMP_TZ: 23,
      TNS_OBJ_TDS_TYPE_OBJ: 27,
      TNS_OBJ_TDS_TYPE_COLL: 28,
      TNS_OBJ_TDS_TYPE_CLOB: 29,
      TNS_OBJ_TDS_TYPE_BLOB: 30,
      TNS_OBJ_TDS_TYPE_TIMESTAMP_LTZ: 33,
      TNS_OBJ_TDS_TYPE_BINARY_FLOAT: 37,
      TNS_OBJ_TDS_TYPE_START_EMBED_ADT: 39,
      TNS_OBJ_TDS_TYPE_END_EMBED_ADT: 40,
      TNS_OBJ_TDS_TYPE_SUBTYPE_MARKER: 43,
      TNS_OBJ_TDS_TYPE_EMBED_ADT_INFO: 44,
      TNS_OBJ_TDS_TYPE_BINARY_DOUBLE: 45,
      // xml type constants
      TNS_XML_TYPE_LOB: 1,
      TNS_XML_TYPE_STRING: 4,
      TNS_XML_TYPE_FLAG_SKIP_NEXT_4: 1048576,
      // errors
      TNS_ERR_INCONSISTENT_DATA_TYPES: 932,
      TNS_ERR_VAR_NOT_IN_SELECT_LIST: 1007,
      TNS_ERR_INBAND_MESSAGE: 12573,
      TNS_ERR_INVALID_SERVICE_NAME: 12514,
      TNS_ERR_INVALID_SID: 12505,
      TNS_ERR_NO_DATA_FOUND: 1403,
      TNS_ERR_SESSION_SHUTDOWN: 12572,
      TNS_ERR_NO_MESSAGES_FOUND: 25228,
      // warnings
      TNS_WARN_COMPILATION_CREATE: 32,
      // vector constants
      TNS_VECTOR_MAX_LENGTH: 1048576,
      VECTOR_FORMAT_FLEX: 0,
      VECTOR_META_FLAG_FLEXIBLE_DIM: 1,
      VECTOR_META_FLAG_SPARSE: 2,
      // other constants
      PACKET_HEADER_SIZE: 8,
      NUMBER_AS_TEXT_CHARS: 172,
      CHUNKED_BYTES_CHUNK_SIZE: 65536,
      // Network Header flags for Data packet
      TNS_DATA_FLAGS_END_OF_REQUEST: 8192,
      TNS_BASE64_ALPHABET_ARRAY: Buffer2.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
      TNS_EXTENT_OID: Buffer2.from("00000000000000000000000000010001", "hex")
    };
  }
});

// node_modules/oracledb/lib/thin/protocol/utils.js
var require_utils = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/utils.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants3();
    var crypto = require("crypto");
    var OutOfPacketsError = class extends Error {
    };
    function _convertBase64(result, value, size, offset) {
      for (let i = 0; i < size; i++) {
        result[offset + size - i - 1] = constants.TNS_BASE64_ALPHABET_ARRAY[value & 63];
        value = value >> 6;
      }
      return offset + size;
    }
    function encodeRowID(rowID) {
      let offset = 0;
      if (rowID.rba !== 0 || rowID.partitionID !== 0 || rowID.blockNum !== 0 || rowID.slotNum != 0) {
        const result = Buffer2.allocUnsafe(constants.TNS_MAX_ROWID_LENGTH);
        offset = _convertBase64(result, rowID.rba, 6, offset);
        offset = _convertBase64(result, rowID.partitionID, 3, offset);
        offset = _convertBase64(result, rowID.blockNum, 6, offset);
        _convertBase64(result, rowID.slotNum, 3, offset);
        return result.toString("utf8");
      }
    }
    function setObfuscatedValue(value) {
      const valueBytes = Buffer2.from(value);
      const obfuscatedBytes = crypto.randomBytes(valueBytes.length);
      for (let i = 0; i < valueBytes.length; i++) {
        valueBytes[i] = obfuscatedBytes[i] ^ valueBytes[i];
      }
      return { obfuscatedValue: obfuscatedBytes, value: valueBytes };
    }
    function getDeobfuscatedValue(valueBytes, obfuscatedBytes) {
      const buf = Buffer2.from(valueBytes);
      for (let i = 0; i < valueBytes.length; i++) {
        buf[i] = valueBytes[i] ^ obfuscatedBytes[i];
      }
      const retVal = buf.toString();
      buf.fill(0);
      return retVal;
    }
    module2.exports = {
      encodeRowID,
      getDeobfuscatedValue,
      OutOfPacketsError,
      setObfuscatedValue
    };
  }
});

// node_modules/oracledb/lib/queryStream.js
var require_queryStream = __commonJS({
  "node_modules/oracledb/lib/queryStream.js"(exports2, module2) {
    "use strict";
    var process2 = require("process");
    var { Readable } = require("stream");
    var QueryStream = class extends Readable {
      constructor(rs) {
        super({ objectMode: true });
        this._fetching = false;
        this._numRows = 0;
        if (rs) {
          process2.nextTick(() => {
            this._open(rs);
          });
        }
      }
      // called by readable.destroy() and ensures that the result set is closed if
      // it has not already been closed (never called directly)
      async _destroy(err, cb) {
        if (this._resultSet) {
          const rs = this._resultSet;
          this._resultSet = null;
          if (this._fetching) {
            await new Promise((resolve3) => this.once("_doneFetching", resolve3));
          }
          try {
            await rs._impl.close();
          } catch (closeErr) {
            cb(closeErr);
            return;
          }
        }
        cb(err);
      }
      // called when the query stream is to be associated with a result set; this
      // takes place when the query stream if constructed (if a result set is known
      // at that point) or by Connection.execute() when the result set is ready
      _open(rs) {
        this._resultSet = rs;
        this.emit("open");
        this.emit("metadata", rs.metaData);
      }
      // called by readable.read() and pushes rows to the internal queue maintained
      // by the stream implementation (never called directly) appropriate
      async _read() {
        if (!this._resultSet) {
          this.once("open", this._read);
          return;
        }
        try {
          this._fetching = true;
          this._resultSet._allowGetRowCall = true;
          const row = await this._resultSet.getRow();
          if (row) {
            this.push(row);
          } else {
            this.push(null);
          }
        } catch (err) {
          this.destroy(err);
        } finally {
          this._fetching = false;
          if (this._resultSet) {
            this._resultSet._allowGetRowCall = false;
          } else {
            this.emit("_doneFetching");
          }
        }
      }
    };
    module2.exports = QueryStream;
  }
});

// node_modules/oracledb/lib/resultset.js
var require_resultset2 = __commonJS({
  "node_modules/oracledb/lib/resultset.js"(exports2, module2) {
    "use strict";
    var QueryStream = require_queryStream();
    var BaseDbObject = require_dbObject2();
    var nodbUtil = require_util();
    var constants = require_constants();
    var Lob = require_lob2();
    var errors = require_errors();
    var ResultSet = class _ResultSet {
      constructor() {
        this._rowCache = [];
        this._processingStarted = false;
        this._convertedToStream = false;
        this._allowGetRowCall = false;
        this._isActive = false;
      }
      //---------------------------------------------------------------------------
      // _getAllRows()
      //
      // Return all of the rows in the result set.
      //---------------------------------------------------------------------------
      async _getAllRows() {
        try {
          let maxRows = this._impl.maxRows;
          let fetchArraySize = this._impl.fetchArraySize;
          let rowsFetched = [];
          while (true) {
            if (maxRows > 0 && fetchArraySize >= maxRows) {
              fetchArraySize = maxRows;
            }
            const rows = await this._getRows(fetchArraySize);
            if (rows) {
              await this._processRows(rows, true);
              rowsFetched = rowsFetched.concat(rows);
            }
            if (rows.length == maxRows || rows.length < fetchArraySize) {
              break;
            }
            if (maxRows > 0) {
              maxRows -= rows.length;
            }
          }
          return rowsFetched;
        } finally {
          await this._impl.close();
          delete this._impl;
        }
      }
      //---------------------------------------------------------------------------
      // _getRows()
      //
      // Return up to the specified number of rows from the result set. If nested
      // cursors are possible, setup the execute options so that they can be
      // examined within the implementation's setup routine.
      //---------------------------------------------------------------------------
      async _getRows(numRows) {
        let options = {};
        if (this._impl.nestedCursorIndices.length > 0) {
          options = {
            connection: this._connection,
            outFormat: this._impl.outFormat,
            fetchArraySize: this._impl.fetchArraySize,
            dbObjectAsPojo: this._impl.dbObjectAsPojo,
            maxRows: this._impl.maxRows,
            fetchTypeMap: this._impl.fetchTypeMap
          };
        }
        return await this._impl.getRows(numRows, options);
      }
      //---------------------------------------------------------------------------
      // _processRows()
      //
      // Process rows returned by the implementation. This will transform result
      // set and LOB implementations into user facing objects. It will also perform
      // any fetched that are needed (if a result set is undesirable)
      //---------------------------------------------------------------------------
      async _processRows(rows, expandNestedCursors) {
        for (const i of this._impl.nestedCursorIndices) {
          for (let j = 0; j < rows.length; j++) {
            const val = rows[j][i];
            if (val) {
              const resultSet = new _ResultSet();
              resultSet._setup(this._connection, val);
              this._impl.metaData[i].metaData = val.metaData;
              if (expandNestedCursors) {
                rows[j][i] = await resultSet._getAllRows();
              } else {
                rows[j][i] = resultSet;
              }
            }
          }
        }
        for (const i of this._impl.lobIndices) {
          for (let j = 0; j < rows.length; j++) {
            const val = rows[j][i];
            if (val) {
              const lob = rows[j][i] = new Lob();
              lob._setup(val, true);
            }
          }
        }
        for (const i of this._impl.dbObjectIndices) {
          const dbObjectClass = this._impl.metaData[i].dbTypeClass;
          for (let j = 0; j < rows.length; j++) {
            const val = rows[j][i];
            if (val) {
              const obj = rows[j][i] = Object.create(dbObjectClass.prototype);
              obj._impl = val;
              if (this._impl.dbObjectAsPojo) {
                rows[j][i] = obj._toPojo();
              } else if (obj.isCollection) {
                rows[j][i] = new Proxy(obj, BaseDbObject._collectionProxyHandler);
              }
            }
          }
        }
        for (const i of this._impl.converterIndices) {
          const fn = this._impl.metaData[i].converter;
          this._connection._impl._inProgress = false;
          try {
            for (let j = 0; j < rows.length; j++) {
              let result = fn(rows[j][i]);
              if (result instanceof Promise) {
                result = await result;
              }
              rows[j][i] = result;
            }
          } finally {
            this._connection._impl._inProgress = true;
          }
        }
        if (this._impl.outFormat === constants.OUT_FORMAT_OBJECT) {
          for (let i = 0; i < rows.length; i++) {
            const origRow = rows[i];
            const newRow = rows[i] = {};
            const metaData = this._impl.metaData;
            for (let j = 0; j < metaData.length; j++) {
              newRow[metaData[j].name] = origRow[j];
            }
          }
        }
      }
      //---------------------------------------------------------------------------
      // _setup()
      //
      // Setup a result set.
      // ---------------------------------------------------------------------------
      _setup(connection, resultSetImpl) {
        this._connection = connection;
        this._impl = resultSetImpl;
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Close the result set and make it unusable for further operations.
      //---------------------------------------------------------------------------
      async close() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);
        if (this._convertedToStream) {
          errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);
        }
        this._processingStarted = true;
        const resultSetImpl = this._impl;
        delete this._impl;
        await resultSetImpl.close();
      }
      //---------------------------------------------------------------------------
      // getRow()
      //
      // Returns a single row to the caller from the result set, if one is
      // available. Rows are buffered in a JavaScript array in order to avoid trips
      // through the thread pool that would be required if implemented in C.
      //---------------------------------------------------------------------------
      async getRow() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);
        if (this._convertedToStream && !this._allowGetRowCall) {
          errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);
        }
        this._allowGetRowCall = false;
        this._processingStarted = true;
        if (this._rowCache.length == 0) {
          const rows = await this._getRows(this._impl.fetchArraySize);
          await this._processRows(rows, false);
          this._rowCache = rows;
        }
        return this._rowCache.shift();
      }
      //---------------------------------------------------------------------------
      // getRows()
      //
      // Check to see if any rows are in the JS buffer (which could result from
      // interspersed calls to getRow() and getRows()). If no rows are in the
      // buffer, the call is just proxied to the implementation layer. Otherwise,
      // rows are pulled from the buffer and potentially concatenated with rows
      // from calls to the implementation's getRows().
      //---------------------------------------------------------------------------
      async getRows(numRows) {
        let rowsNeeded;
        errors.assertArgCount(arguments, 0, 1);
        errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);
        if (arguments.length == 0) {
          numRows = 0;
        } else {
          errors.assertParamValue(Number.isInteger(numRows) && numRows >= 0, 1);
        }
        if (this._convertedToStream) {
          errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);
        }
        this._processingStarted = true;
        let requestedRows;
        if (numRows == 0) {
          requestedRows = this._rowCache;
          const fetchArraySize = this._impl.fetchArraySize;
          while (true) {
            const rows = await this._getRows(fetchArraySize);
            if (rows) {
              await this._processRows(rows, false);
              requestedRows = requestedRows.concat(rows);
            }
            if (rows.length < fetchArraySize)
              break;
          }
          return requestedRows;
        }
        if (this._rowCache.length === 0) {
          requestedRows = await this._getRows(numRows);
          await this._processRows(requestedRows, false);
        } else {
          rowsNeeded = numRows - this._rowCache.length;
          if (rowsNeeded <= 0) {
            requestedRows = this._rowCache.splice(0, numRows);
          } else {
            const rows = await this._getRows(rowsNeeded);
            await this._processRows(rows, false);
            requestedRows = this._rowCache.concat(rows);
            this._rowCache = [];
          }
        }
        return requestedRows;
      }
      //---------------------------------------------------------------------------
      // metaData()
      //
      // Property returning the metadata associated with the result set.
      //---------------------------------------------------------------------------
      get metaData() {
        if (this._impl) {
          return this._impl.metaData;
        }
        return void 0;
      }
      //---------------------------------------------------------------------------
      // toQueryStream()
      //
      // Converts a result set to a QueryStream object.
      //---------------------------------------------------------------------------
      toQueryStream() {
        errors.assertArgCount(arguments, 0, 0);
        if (this._processingStarted) {
          errors.throwErr(errors.ERR_CANNOT_CONVERT_RS_TO_STREAM);
        }
        if (this._convertedToStream) {
          errors.throwErr(errors.ERR_RS_ALREADY_CONVERTED);
        }
        this._convertedToStream = true;
        return new QueryStream(this);
      }
      [Symbol.asyncIterator]() {
        const resultSet = this;
        return {
          async next() {
            const row = await resultSet.getRow();
            return { value: row, done: row === void 0 };
          },
          return() {
            return { done: true };
          }
        };
      }
    };
    nodbUtil.wrapFns(
      ResultSet.prototype,
      errors.ERR_BUSY_RS,
      "close",
      "getRow",
      "getRows"
    );
    module2.exports = ResultSet;
  }
});

// node_modules/oracledb/lib/transformer.js
var require_transformer = __commonJS({
  "node_modules/oracledb/lib/transformer.js"(exports2, module2) {
    "use strict";
    var BaseDbObject = require_dbObject2();
    var { Buffer: Buffer2 } = require("buffer");
    var Lob = require_lob2();
    var ResultSet = require_resultset2();
    var constants = require_constants();
    var errors = require_errors();
    var util = require("util");
    var types = require_types();
    var nodbUtil = require_util();
    function checkType(info, options) {
      if (info.type === void 0 && arguments.length > 2) {
        info.type = arguments[2];
      } else {
        let matches = false;
        for (let i = 2; i < arguments.length; i++) {
          if (info.type === arguments[i]) {
            matches = true;
            break;
          }
        }
        if (!matches) {
          if (info.attrName) {
            errors.throwErr(
              errors.ERR_WRONG_VALUE_FOR_DBOBJECT_ATTR,
              info.attrName,
              info.fqn
            );
          } else if (info.fqn) {
            errors.throwErr(errors.ERR_WRONG_VALUE_FOR_DBOBJECT_ELEM, info.fqn);
          } else if (info.isArray && info.name) {
            errors.throwErr(
              errors.ERR_INCOMPATIBLE_TYPE_ARRAY_BIND,
              options.pos,
              info.name
            );
          } else if (info.isArray) {
            errors.throwErr(
              errors.ERR_INCOMPATIBLE_TYPE_ARRAY_INDEX_BIND,
              options.pos,
              info.pos
            );
          } else {
            errors.throwErr(errors.ERR_BIND_VALUE_AND_TYPE_MISMATCH);
          }
        }
      }
    }
    function transformJsonValue(value) {
      if (value === void 0 || value === null || typeof value === "number" || typeof value === "string" || typeof value === "boolean" || Buffer2.isBuffer(value) || util.types.isDate(value) || nodbUtil.isVectorValue(value) || value instanceof types.IntervalYM || value instanceof types.IntervalDS)
        return value;
      if (Array.isArray(value)) {
        const outValue2 = new Array(value.length);
        for (let i = 0; i < value.length; i++) {
          outValue2[i] = transformJsonValue(value[i]);
        }
        return outValue2;
      }
      if (value instanceof BaseDbObject)
        return { fields: [], values: [] };
      if (value instanceof types.JsonId) {
        return value;
      }
      const outValue = {};
      outValue.fields = Object.getOwnPropertyNames(value);
      outValue.values = new Array(outValue.fields.length);
      for (let i = 0; i < outValue.fields.length; i++) {
        outValue.values[i] = transformJsonValue(value[outValue.fields[i]]);
      }
      return outValue;
    }
    function transformValueIn(info, value, options) {
      if (value === void 0 || value === null)
        return void 0;
      if (info.type === types.DB_TYPE_OBJECT) {
        let obj = value;
        if (!(value instanceof BaseDbObject)) {
          obj = new info.typeClass(value);
        }
        return obj._impl;
      } else if (info.type === types.DB_TYPE_JSON) {
        return transformJsonValue(value);
      } else if (typeof value === "string") {
        checkType(
          info,
          options,
          types.DB_TYPE_VARCHAR,
          types.DB_TYPE_NVARCHAR,
          types.DB_TYPE_CHAR,
          types.DB_TYPE_NCHAR,
          types.DB_TYPE_CLOB,
          types.DB_TYPE_NCLOB
        );
        if (info.type !== types.DB_TYPE_CLOB && info.type !== types.DB_TYPE_NCLOB) {
          const valueLen = Buffer2.byteLength(value);
          if (info.maxSize === void 0 || valueLen > info.maxSize) {
            if (info.checkSize) {
              errors.throwErr(
                errors.ERR_MAX_SIZE_TOO_SMALL,
                info.maxSize,
                valueLen,
                options.pos
              );
            }
            info.maxSize = valueLen;
          }
        }
        return value;
      } else if (typeof value === "number" || typeof value === "bigint") {
        checkType(
          info,
          options,
          types.DB_TYPE_NUMBER,
          types.DB_TYPE_BINARY_INTEGER,
          types.DB_TYPE_BINARY_FLOAT,
          types.DB_TYPE_BINARY_DOUBLE
        );
        if (Number.isNaN(value) && info.type === types.DB_TYPE_NUMBER) {
          errors.throwErr(errors.ERR_NAN_VALUE);
        }
        return value;
      } else if (typeof value === "boolean") {
        checkType(info, options, types.DB_TYPE_BOOLEAN);
        return value;
      } else if (util.types.isDate(value)) {
        checkType(
          info,
          options,
          types.DB_TYPE_TIMESTAMP,
          types.DB_TYPE_TIMESTAMP_TZ,
          types.DB_TYPE_TIMESTAMP_LTZ,
          types.DB_TYPE_DATE
        );
        return value;
      } else if (value instanceof types.IntervalYM) {
        checkType(
          info,
          options,
          types.DB_TYPE_INTERVAL_YM
        );
        return value;
      } else if (value instanceof types.IntervalDS) {
        checkType(
          info,
          options,
          types.DB_TYPE_INTERVAL_DS
        );
        return value;
      } else if (Buffer2.isBuffer(value)) {
        checkType(
          info,
          options,
          types.DB_TYPE_RAW,
          types.DB_TYPE_BLOB
        );
        if (info.type === types.DB_TYPE_RAW && (info.maxSize === void 0 || value.length > info.maxSize)) {
          if (info.checkSize) {
            errors.throwErr(
              errors.ERR_MAX_SIZE_TOO_SMALL,
              info.maxSize,
              value.length,
              options.pos
            );
          }
          info.maxSize = value.length;
        }
        return value;
      } else if (value instanceof ResultSet) {
        checkType(info, options, types.DB_TYPE_CURSOR);
        return value._impl;
      } else if (value instanceof Lob) {
        checkType(info, options, value.type);
        return value._impl;
      } else if (value instanceof BaseDbObject) {
        checkType(info, options, types.DB_TYPE_OBJECT);
        return value._impl;
      } else if (nodbUtil.isVectorValue(value)) {
        checkType(info, options, types.DB_TYPE_VECTOR);
        return value;
      } else if (info.type === types.DB_TYPE_VECTOR && Array.isArray(value)) {
        return new Float64Array(value);
      } else if (options.allowArray && Array.isArray(value)) {
        info.isArray = true;
        if (info.dir === constants.BIND_IN) {
          info.maxArraySize = value.length || 1;
        } else if (info.maxArraySize === void 0) {
          errors.throwErr(errors.ERR_REQUIRED_MAX_ARRAY_SIZE);
        } else if (value.length > info.maxArraySize) {
          errors.throwErr(errors.ERR_INVALID_ARRAY_SIZE);
        }
        options.allowArray = false;
        const transformed = new Array(value.length);
        for (let i = 0; i < value.length; i++) {
          options.pos = i;
          transformed[i] = transformValueIn(info, value[i], options);
        }
        return transformed;
      }
      if (info.type === void 0)
        errors.throwErr(errors.ERR_INVALID_BIND_DATA_TYPE, 2);
      checkType(info, options);
    }
    module2.exports = {
      transformJsonValue,
      transformValueIn
    };
  }
});

// node_modules/oracledb/lib/dbObject.js
var require_dbObject2 = __commonJS({
  "node_modules/oracledb/lib/dbObject.js"(exports2, module2) {
    "use strict";
    var Lob = require_lob2();
    var impl = require_impl();
    var errors = require_errors();
    var types = require_types();
    var util = require("util");
    function validatePropertyValue(objType, metaData, value, index) {
      let valueLen, lengthErr = false;
      if (value) {
        switch (metaData.type) {
          case types.DB_TYPE_VARCHAR:
          case types.DB_TYPE_NVARCHAR:
          case types.DB_TYPE_NCHAR:
          case types.DB_TYPE_CHAR:
            valueLen = Buffer.byteLength(value);
            if (valueLen > metaData.maxSize) {
              lengthErr = true;
            }
            break;
          case types.DB_TYPE_RAW:
            valueLen = value.length;
            if (valueLen > metaData.maxSize) {
              lengthErr = true;
            }
            break;
          default:
            break;
        }
        if (lengthErr) {
          if (index !== void 0) {
            errors.throwErr(
              errors.ERR_WRONG_LENGTH_FOR_DBOBJECT_ELEM,
              index,
              objType.fqn,
              valueLen,
              metaData.maxSize
            );
          } else {
            errors.throwErr(
              errors.ERR_WRONG_LENGTH_FOR_DBOBJECT_ATTR,
              metaData.name,
              objType.fqn,
              valueLen,
              metaData.maxSize
            );
          }
        }
      }
    }
    var BaseDbObject = class _BaseDbObject {
      //---------------------------------------------------------------------------
      // _ensureCollection()
      //
      // Ensures that the object is a collection.
      //---------------------------------------------------------------------------
      _ensureCollection() {
        if (!this.isCollection) {
          errors.throwErr(
            errors.ERR_OBJECT_IS_NOT_A_COLLECTION,
            this.name
          );
        }
      }
      //---------------------------------------------------------------------------
      // _getAttrValue()
      //
      // Returns the value of the given attribute on the object.
      //---------------------------------------------------------------------------
      _getAttrValue(attr) {
        const value = this._impl.getAttrValue(attr);
        return this._transformValueOut(value, attr.typeClass, attr);
      }
      //---------------------------------------------------------------------------
      // _setAttrValue()
      //
      // Sets the value of the attribute on the object to the given value.
      //---------------------------------------------------------------------------
      _setAttrValue(attr, value) {
        const info = {
          fqn: this._objType.fqn,
          attrName: attr.name,
          type: attr.type,
          typeClass: attr.typeClass
        };
        const options = { allowArray: false };
        value = transformer.transformValueIn(info, value, options);
        validatePropertyValue(this._objType, attr, value);
        this._impl.setAttrValue(attr, value);
      }
      //---------------------------------------------------------------------------
      // _toPojo()
      //
      // Returns the database object as a plain Javascript object.
      //---------------------------------------------------------------------------
      _toPojo() {
        if (this.isCollection) {
          const result2 = this.getValues();
          if (this.elementType === types.DB_TYPE_OBJECT) {
            for (let i = 0; i < result2.length; i++) {
              result2[i] = result2[i]._toPojo();
            }
          }
          return result2;
        }
        const result = {};
        for (const name in this.attributes) {
          let value = this[name];
          if (value instanceof _BaseDbObject) {
            value = value._toPojo();
          }
          result[name] = value;
        }
        return result;
      }
      //---------------------------------------------------------------------------
      // _transformValueOut()
      //
      // Transforms a value going out to the caller from the implementation.
      //---------------------------------------------------------------------------
      _transformValueOut(value, cls, metaData) {
        let outValue = value;
        if (value instanceof impl.LobImpl) {
          outValue = new Lob();
          outValue._setup(value, true);
        } else {
          if (value instanceof impl.DbObjectImpl) {
            outValue = Object.create(cls.prototype);
            outValue._impl = value;
            if (outValue.isCollection) {
              outValue = new Proxy(outValue, _BaseDbObject._collectionProxyHandler);
            }
          }
          if (metaData.converter) {
            outValue = metaData.converter(outValue);
          }
        }
        return outValue;
      }
      //---------------------------------------------------------------------------
      // append()
      //
      // Appends an element to the collection.
      //---------------------------------------------------------------------------
      append(value) {
        errors.assertArgCount(arguments, 1, 1);
        this._ensureCollection();
        const info = {
          fqn: this._objType.fqn,
          type: this._objType.elementType,
          typeClass: this._objType.elementTypeClass
        };
        const options = { allowArray: false };
        value = transformer.transformValueIn(info, value, options);
        let index = this._impl.getLastIndex();
        if (index) {
          index = index + 1;
        } else {
          index = 0;
        }
        validatePropertyValue(this._objType, this._objType.elementTypeInfo, value, index);
        this._impl.append(value);
      }
      //---------------------------------------------------------------------------
      // attributes
      //
      // Property for the attributes stored on the object type.
      //---------------------------------------------------------------------------
      get attributes() {
        if (!this._attributes) {
          const implAttrs = this._objType.attributes || [];
          const attrs = {};
          for (let i = 0; i < implAttrs.length; i++) {
            const implAttr = implAttrs[i];
            const attr = {
              type: implAttr.type,
              typeName: implAttr.typeName
            };
            if (implAttr.typeClass) {
              attr.typeClass = implAttr.typeClass;
            }
            if (implAttr.precision != null) {
              attr.precision = implAttr.precision;
            }
            if (implAttr.scale != null) {
              attr.scale = implAttr.scale;
            }
            if (implAttr.maxSize != null) {
              attr.maxSize = implAttr.maxSize;
            }
            attrs[implAttr.name] = attr;
          }
          this._attributes = attrs;
        }
        return this._attributes;
      }
      //---------------------------------------------------------------------------
      // copy
      //
      // Creates and returns a copy of the object. The copy is independent of
      // the original object that was copied.
      //---------------------------------------------------------------------------
      copy() {
        errors.assertArgCount(arguments, 0, 0);
        const newObj = Object.create(this);
        newObj._impl = this._impl.copy();
        if (this.isCollection)
          return new Proxy(newObj, _BaseDbObject._collectionProxyHandler);
        return newObj;
      }
      //---------------------------------------------------------------------------
      // deleteElement()
      //
      // Deletes the element in a collection at the specified index.
      //---------------------------------------------------------------------------
      deleteElement(index) {
        errors.assertArgCount(arguments, 1, 1);
        this._ensureCollection();
        errors.assertParamValue(Number.isInteger(index), 1);
        return this._impl.deleteElement(index);
      }
      //---------------------------------------------------------------------------
      // elementType
      //
      // Property for the element type, if the database object type is a
      // collection. It will be one of the DB_TYPE_ constants.
      //---------------------------------------------------------------------------
      get elementType() {
        return this._objType.elementType;
      }
      //---------------------------------------------------------------------------
      // elementTypeClass
      //
      // Property for the element type class, if the database object type is a
      // collection and the elements in the collection refer to database objects.
      //---------------------------------------------------------------------------
      get elementTypeClass() {
        return this._objType.elementTypeClass;
      }
      //---------------------------------------------------------------------------
      // elementTypeName
      //
      // Property for the element type name, if the database object type is a
      // collection.
      //---------------------------------------------------------------------------
      get elementTypeName() {
        return this._objType.elementTypeName;
      }
      //---------------------------------------------------------------------------
      // fqn
      //
      // Property for the fully qualified name of the database object type in the
      // form: <schema>.<name>.
      //---------------------------------------------------------------------------
      get fqn() {
        return this._objType.fqn;
      }
      //---------------------------------------------------------------------------
      // length
      //
      // Length of the database object type, if it is a collection. Else it
      // returns undefined.
      //---------------------------------------------------------------------------
      get length() {
        if (this.isCollection)
          return this._impl.getLength();
        return void 0;
      }
      //---------------------------------------------------------------------------
      // getElement()
      //
      // Returns the element in a collection at the specified index.
      //---------------------------------------------------------------------------
      getElement(index) {
        errors.assertArgCount(arguments, 1, 1);
        this._ensureCollection();
        errors.assertParamValue(Number.isInteger(index), 1);
        const value = this._impl.getElement(index);
        return this._transformValueOut(value, this.elementTypeClass, this._objType.elementTypeInfo);
      }
      //---------------------------------------------------------------------------
      // getKeys()
      //
      // Returns an array of the keys of the collection.
      //---------------------------------------------------------------------------
      getKeys() {
        errors.assertArgCount(arguments, 0, 0);
        this._ensureCollection();
        return this._impl.getKeys();
      }
      //---------------------------------------------------------------------------
      // getFirstIndex()
      //
      // Returns the first index in the collection.
      //---------------------------------------------------------------------------
      getFirstIndex() {
        errors.assertArgCount(arguments, 0, 0);
        this._ensureCollection();
        return this._impl.getFirstIndex();
      }
      //---------------------------------------------------------------------------
      // getLastIndex()
      //
      // Returns the last index in the collection.
      //---------------------------------------------------------------------------
      getLastIndex() {
        errors.assertArgCount(arguments, 0, 0);
        this._ensureCollection();
        return this._impl.getLastIndex();
      }
      //---------------------------------------------------------------------------
      // getNextIndex()
      //
      // Returns the next index in the collection.
      //---------------------------------------------------------------------------
      getNextIndex(index) {
        errors.assertArgCount(arguments, 1, 1);
        this._ensureCollection();
        errors.assertParamValue(Number.isInteger(index), 1);
        return this._impl.getNextIndex(index);
      }
      //---------------------------------------------------------------------------
      // getPrevIndex()
      //
      // Returns the previous index in the collection.
      //---------------------------------------------------------------------------
      getPrevIndex(index) {
        errors.assertArgCount(arguments, 1, 1);
        this._ensureCollection();
        errors.assertParamValue(Number.isInteger(index), 1);
        return this._impl.getPrevIndex(index);
      }
      //---------------------------------------------------------------------------
      // getValues()
      //
      // Returns the elements in a collection.
      //---------------------------------------------------------------------------
      getValues() {
        errors.assertArgCount(arguments, 0, 0);
        this._ensureCollection();
        const values = this._impl.getValues();
        for (let i = 0; i < values.length; i++) {
          values[i] = this._transformValueOut(values[i], this.elementTypeClass, this._objType.elementTypeInfo);
        }
        return values;
      }
      //---------------------------------------------------------------------------
      // hasElement()
      //
      // Returns a boolean indicating if an element exists at the specified index.
      //---------------------------------------------------------------------------
      hasElement(index) {
        errors.assertArgCount(arguments, 1, 1);
        this._ensureCollection();
        errors.assertParamValue(Number.isInteger(index), 1);
        return this._impl.hasElement(index);
      }
      //---------------------------------------------------------------------------
      // isCollection
      //
      // Property indicating if the object is a collection or not.
      //---------------------------------------------------------------------------
      get isCollection() {
        return this._objType.isCollection;
      }
      //---------------------------------------------------------------------------
      // name
      //
      // Property for the name of the database object type.
      //---------------------------------------------------------------------------
      get name() {
        return this._objType.name;
      }
      //---------------------------------------------------------------------------
      // schema
      //
      // Property for the schema of the database object type.
      //---------------------------------------------------------------------------
      get schema() {
        return this._objType.schema;
      }
      //---------------------------------------------------------------------------
      // packageName
      //
      // Property for the packageName of the database object type.
      //---------------------------------------------------------------------------
      get packageName() {
        return this._objType.packageName;
      }
      //---------------------------------------------------------------------------
      // setElement()
      //
      // Sets the element in the collection at the specified index to the given
      // value.
      //---------------------------------------------------------------------------
      setElement(index, value) {
        errors.assertArgCount(arguments, 2, 2);
        this._ensureCollection();
        errors.assertParamValue(Number.isInteger(index), 1);
        const info = {
          fqn: this._objType.fqn,
          type: this._objType.elementType,
          typeClass: this._objType.elementTypeClass
        };
        const options = { allowArray: false };
        value = transformer.transformValueIn(info, value, options);
        validatePropertyValue(this._objType, this._objType.elementTypeInfo, value, index);
        this._impl.setElement(index, value);
      }
      //---------------------------------------------------------------------------
      // trim()
      //
      // Trims the specified number of elements from the end of the collection.
      //---------------------------------------------------------------------------
      trim(numToTrim) {
        errors.assertArgCount(arguments, 1, 1);
        this._ensureCollection();
        errors.assertParamValue(Number.isInteger(numToTrim) && numToTrim >= 0, 1);
        this._impl.trim(numToTrim);
      }
      // custom inspection routine
      [util.inspect.custom](depth, options) {
        return "[" + this.fqn + "] " + util.inspect(this._toPojo(), options);
      }
      [Symbol.iterator]() {
        if (this.isCollection) {
          const values = this.getValues();
          return values[Symbol.iterator]();
        }
        throw TypeError("obj is not iterable");
      }
      [Symbol.toPrimitive](hint) {
        switch (hint) {
          case "number":
            return NaN;
          default:
            return "[" + this.fqn + "] " + util.inspect(this._toPojo(), {});
        }
      }
      get [Symbol.toStringTag]() {
        return this.fqn;
      }
      toJSON() {
        return this._toPojo();
      }
      //---------------------------------------------------------------------------
      // toMap()
      //
      // Returns the Map object where the collections indexes are the keys and
      // the elements are its values.
      //---------------------------------------------------------------------------
      toMap() {
        errors.assertArgCount(arguments, 0, 0);
        this._ensureCollection();
        const result = /* @__PURE__ */ new Map();
        this.getKeys().forEach((element) => {
          result.set(element, this.getElement(element));
        });
        return result;
      }
    };
    function transformErr(func) {
      return function() {
        try {
          return func.apply(this, arguments);
        } catch (err) {
          throw errors.transformErr(err, errors.transformErr);
        }
      };
    }
    function wrapFns(proto) {
      for (let i = 1; i < arguments.length; i++) {
        const name = arguments[i];
        proto[name] = transformErr(proto[name]);
      }
    }
    wrapFns(
      BaseDbObject.prototype,
      "_getAttrValue",
      "_setAttrValue",
      "append",
      "copy",
      "deleteElement",
      "getElement",
      "getKeys",
      "getFirstIndex",
      "getLastIndex",
      "getNextIndex",
      "getPrevIndex",
      "getValues",
      "toMap",
      "hasElement",
      "setElement",
      "trim"
    );
    BaseDbObject._collectionProxyHandler = {
      deleteProperty(target, prop) {
        if (typeof prop === "string") {
          const index = +prop;
          if (!isNaN(index)) {
            return target.deleteElement(index);
          }
        }
        return delete target[prop];
      },
      get(target, prop) {
        if (typeof prop === "string") {
          const index = +prop;
          if (!isNaN(index)) {
            return target.getElement(index);
          }
        }
        const value = target[prop];
        if (typeof value === "function") {
          return value.bind(target);
        }
        return value;
      },
      set(target, prop, value) {
        if (typeof prop === "string") {
          const index = +prop;
          if (!isNaN(index)) {
            target.setElement(index, value);
            return true;
          }
        }
        target[prop] = value;
        return true;
      }
    };
    module2.exports = BaseDbObject;
    var transformer = require_transformer();
  }
});

// node_modules/oracledb/lib/aqQueue.js
var require_aqQueue2 = __commonJS({
  "node_modules/oracledb/lib/aqQueue.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var errors = require_errors();
    var nodbUtil = require_util();
    var AqDeqOptions = require_aqDeqOptions2();
    var AqEnqOptions = require_aqEnqOptions2();
    var AqMessage = require_aqMessage2();
    var BaseDbObject = require_dbObject2();
    var transformer = require_transformer();
    var types = require_types();
    var AqQueue = class {
      //---------------------------------------------------------------------------
      // _isPayload()
      //
      // Returns a boolean indicating if the value is a valid payload.
      //---------------------------------------------------------------------------
      _isPayload(value) {
        return typeof value === "string" || Buffer2.isBuffer(value) || value instanceof BaseDbObject;
      }
      //---------------------------------------------------------------------------
      // _makeMessage()
      //
      // For enqOne()/deqOne()/enqMany()/deqMany(), wrap the return value with JS
      // layer object.
      //---------------------------------------------------------------------------
      _makeMessage(msgImpl) {
        const msg = new AqMessage();
        msg._impl = msgImpl;
        msg._payloadTypeClass = this._payloadTypeClass;
        return msg;
      }
      //---------------------------------------------------------------------------
      // _verifyMessage()
      //
      // Messages that can be enqueued must be a string, Buffer or database object
      // (in which case all message properties are defaulted) or an object
      // containing a "payload" property along with the other properties to use
      // during the enqueue. A normalized object is returned.
      //---------------------------------------------------------------------------
      _verifyMessage(message) {
        let payload;
        if (this._isPayload(message)) {
          payload = message;
          message = {};
        } else {
          message = { ...message };
          if (this._isJson || this._isPayload(message.payload)) {
            payload = message.payload;
          } else if (this._payloadTypeClass) {
            payload = new this._payloadTypeClass(message.payload);
          } else {
            errors.throwErr(errors.ERR_INVALID_AQ_MESSAGE);
          }
        }
        if (this._isJson) {
          message.payload = transformer.transformJsonValue(payload);
        } else if (typeof payload === "string" || Buffer2.isBuffer(payload)) {
          message.payload = Buffer2.from(payload);
        } else if (this._payloadType == types.DB_TYPE_OBJECT) {
          if (!(payload instanceof BaseDbObject) || this._payloadTypeName !== payload._impl._objType.name)
            errors.throwErr(errors.ERR_PAYLOAD_CANNOT_BE_ENQUEUED);
          message.payload = payload._impl;
        } else {
          errors.throwErr(errors.ERR_PAYLOAD_CANNOT_BE_ENQUEUED);
        }
        if (message.correlation !== void 0) {
          errors.assertParamPropValue(
            typeof message.correlation === "string",
            1,
            "correlation"
          );
        }
        if (message.delay !== void 0) {
          errors.assertParamPropValue(Number.isInteger(message.delay), 1, "delay");
        }
        if (message.exceptionQueue !== void 0) {
          errors.assertParamPropValue(
            typeof message.exceptionQueue === "string",
            1,
            "exceptionQueue"
          );
        }
        if (message.expiration !== void 0) {
          errors.assertParamPropValue(
            Number.isInteger(message.expiration),
            1,
            "expiration"
          );
        }
        if (message.priority !== void 0) {
          errors.assertParamPropValue(
            Number.isInteger(message.priority),
            1,
            "priority"
          );
        }
        if (message.recipients !== void 0) {
          errors.assertParamPropValue(
            nodbUtil.isArrayOfStrings(message.recipients),
            1,
            "recipients"
          );
        }
        return message;
      }
      //---------------------------------------------------------------------------
      // create()
      //
      // Creates the queue and populates some internal attributes.
      //---------------------------------------------------------------------------
      async create(conn, name, options) {
        if (options.payloadType === types.DB_TYPE_JSON) {
          this._isJson = true;
          this._payloadType = types.DB_TYPE_JSON;
          this._payloadTypeName = "JSON";
        } else if (options.payloadType === void 0 || options.payloadType === types.DB_TYPE_RAW) {
          this._payloadType = types.DB_TYPE_RAW;
          this._payloadTypeName = "RAW";
        } else {
          if (typeof options.payloadType === "string") {
            const cls = await conn._getDbObjectClassForName(options.payloadType);
            this._payloadTypeClass = cls;
            options.payloadType = cls;
          } else {
            errors.assertParamPropValue(nodbUtil.isObject(options.payloadType) && options.payloadType.prototype instanceof BaseDbObject, 2, "payloadType");
            this._payloadTypeClass = options.payloadType;
          }
          this._payloadType = types.DB_TYPE_OBJECT;
          this._payloadTypeName = this._payloadTypeClass.prototype.name;
        }
        this._name = name;
        this._impl = await conn._impl.getQueue(
          name,
          this._payloadTypeClass,
          this._payloadType
        );
      }
      //---------------------------------------------------------------------------
      // deqMany()
      //
      // Returns an array of messages from the queue, up to the maximum specified,
      // if any are available.
      //---------------------------------------------------------------------------
      async deqMany(maxMessages) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(
          Number.isInteger(maxMessages) && maxMessages > 0,
          1
        );
        const msgImpls = await this._impl.deq(maxMessages);
        return msgImpls.map((i) => this._makeMessage(i));
      }
      //---------------------------------------------------------------------------
      // deqOne()
      //
      // Returns a single message from the queue, if one is available.
      //---------------------------------------------------------------------------
      async deqOne() {
        errors.assertArgCount(arguments, 0, 0);
        const msgImpls = await this._impl.deq(1);
        if (msgImpls.length > 0)
          return this._makeMessage(msgImpls[0]);
      }
      //---------------------------------------------------------------------------
      // deqOptions
      //
      // Property for the dequeue options associated with the queue.
      //---------------------------------------------------------------------------
      get deqOptions() {
        if (!this._deqOptions) {
          const deqOptions = new AqDeqOptions();
          deqOptions._impl = this._impl.deqOptions;
          this._deqOptions = deqOptions;
        }
        return this._deqOptions;
      }
      //---------------------------------------------------------------------------
      // enqMany()
      //
      // Enqueues multiple messages into the queue at the same time, avoiding
      // multiple round-trips.
      //---------------------------------------------------------------------------
      async enqMany(messages) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(Array.isArray(messages) && messages.length > 0, 1);
        const verifiedMessages = new Array(messages.length);
        for (let i = 0; i < messages.length; i++) {
          verifiedMessages[i] = this._verifyMessage(messages[i]);
        }
        const msgImpls = await this._impl.enq(verifiedMessages);
        return msgImpls.map((i) => this._makeMessage(i));
      }
      //---------------------------------------------------------------------------
      // enqOne()
      //
      // Enqueues a single message into the queue.
      //---------------------------------------------------------------------------
      async enqOne(message) {
        errors.assertArgCount(arguments, 1, 1);
        message = this._verifyMessage(message);
        const msgImpls = await this._impl.enq([message]);
        return this._makeMessage(msgImpls[0]);
      }
      //---------------------------------------------------------------------------
      // enqOptions
      //
      // Property for the enqueue options associated with the queue.
      //---------------------------------------------------------------------------
      get enqOptions() {
        if (!this._enqOptions) {
          const enqOptions = new AqEnqOptions();
          enqOptions._impl = this._impl.enqOptions;
          this._enqOptions = enqOptions;
        }
        return this._enqOptions;
      }
      //---------------------------------------------------------------------------
      // name
      //
      // Property for the name of the queue.
      //---------------------------------------------------------------------------
      get name() {
        return this._name;
      }
      //---------------------------------------------------------------------------
      // payloadType
      //
      // Property for the payload type.
      //---------------------------------------------------------------------------
      get payloadType() {
        return this._payloadType;
      }
      //---------------------------------------------------------------------------
      // payloadTypeName
      //
      // Property for the payload type name.
      //---------------------------------------------------------------------------
      get payloadTypeName() {
        return this._payloadTypeName;
      }
      //---------------------------------------------------------------------------
      // payloadTypeClass
      //
      // Property for the payload type class.
      //---------------------------------------------------------------------------
      get payloadTypeClass() {
        return this._payloadTypeClass;
      }
    };
    nodbUtil.wrapFns(
      AqQueue.prototype,
      "deqOne",
      "deqMany",
      "enqOne",
      "enqMany"
    );
    module2.exports = AqQueue;
  }
});

// node_modules/oracledb/lib/sodaDocument.js
var require_sodaDocument2 = __commonJS({
  "node_modules/oracledb/lib/sodaDocument.js"(exports2, module2) {
    "use strict";
    var SodaDocument = class {
      //---------------------------------------------------------------------------
      // createdOn
      //
      // Property for the created date of the document.
      //---------------------------------------------------------------------------
      get createdOn() {
        return this._impl.getCreatedOn();
      }
      //---------------------------------------------------------------------------
      // getContent()
      //
      // Returns the document content in native JavaScript format.
      // Non-JSON content is returned as a JavaScript Buffer.
      //---------------------------------------------------------------------------
      getContent() {
        const content = this._impl.getContent();
        if (typeof content === "string" && this.mediaType === "application/json")
          return JSON.parse(content);
        return content;
      }
      //---------------------------------------------------------------------------
      // getContentAsBuffer()
      //
      // Returns the document content as a buffer.
      //---------------------------------------------------------------------------
      getContentAsBuffer() {
        const content = this._impl.getContent();
        if (Buffer.isBuffer(content))
          return content;
        else if (typeof content == "string")
          return Buffer.from(content);
        return Buffer.from(JSON.stringify(content));
      }
      //---------------------------------------------------------------------------
      // getContentAsString()
      //
      // Returns the document content as a string.
      //---------------------------------------------------------------------------
      getContentAsString() {
        const content = this._impl.getContent();
        if (typeof content === "string")
          return content;
        else if (Buffer.isBuffer(content))
          return content.toString();
        return JSON.stringify(content);
      }
      //---------------------------------------------------------------------------
      // key
      //
      // Property for the key of the document.
      //---------------------------------------------------------------------------
      get key() {
        return this._impl.getKey();
      }
      //---------------------------------------------------------------------------
      // lastModified
      //
      // Property for the last modified date of the document.
      //---------------------------------------------------------------------------
      get lastModified() {
        return this._impl.getLastModified();
      }
      //---------------------------------------------------------------------------
      // mediaType
      //
      // Property for the media type of the document.
      //---------------------------------------------------------------------------
      get mediaType() {
        return this._impl.getMediaType();
      }
      //---------------------------------------------------------------------------
      // version
      //
      // Property for the version of the document.
      //---------------------------------------------------------------------------
      get version() {
        return this._impl.getVersion();
      }
    };
    SodaDocument.prototype._sodaDocumentMarker = true;
    module2.exports = SodaDocument;
  }
});

// node_modules/oracledb/lib/sodaDocCursor.js
var require_sodaDocCursor2 = __commonJS({
  "node_modules/oracledb/lib/sodaDocCursor.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var nodbUtil = require_util();
    var SodaDocument = require_sodaDocument2();
    var SodaDocCursor = class {
      //---------------------------------------------------------------------------
      // close()
      //
      // Close the cursor and make it unusable for further operations.
      //--------------------------------------------------------------------------
      async close() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl, errors.ERR_INVALID_SODA_DOC_CURSOR);
        await this._impl.close();
        delete this._impl;
      }
      //---------------------------------------------------------------------------
      // getNext()
      //
      // Return the next document available from the cursor.
      //---------------------------------------------------------------------------
      async getNext() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl, errors.ERR_INVALID_SODA_DOC_CURSOR);
        const docImpl = await this._impl.getNext();
        if (docImpl) {
          const doc = new SodaDocument();
          doc._impl = docImpl;
          return doc;
        }
      }
      [Symbol.asyncIterator]() {
        const cursor = this;
        return {
          async next() {
            const doc = await cursor.getNext();
            return { value: doc, done: doc === void 0 };
          },
          return() {
            return { done: true };
          }
        };
      }
    };
    nodbUtil.wrapFns(
      SodaDocCursor.prototype,
      "close",
      "getNext"
    );
    module2.exports = SodaDocCursor;
  }
});

// node_modules/oracledb/lib/sodaOperation.js
var require_sodaOperation2 = __commonJS({
  "node_modules/oracledb/lib/sodaOperation.js"(exports2, module2) {
    "use strict";
    var SodaDocCursor = require_sodaDocCursor2();
    var SodaDocument = require_sodaDocument2();
    var errors = require_errors();
    var nodbUtil = require_util();
    var settings = require_settings();
    var SodaOperation = class {
      constructor(sodaDb) {
        this._options = {
          autoCommit: settings.autoCommit,
          fetchArraySize: settings.fetchArraySize
        };
        this._sodaDb = sodaDb;
      }
      //---------------------------------------------------------------------------
      // count()
      //
      // Return a count of the number of documents that match the search criteria.
      //---------------------------------------------------------------------------
      async count() {
        errors.assertArgCount(arguments, 0, 0);
        return await this._impl.count(this._options);
      }
      //---------------------------------------------------------------------------
      // getCursor()
      //
      // Return a cursor which will return the documents that match the search
      // criteria.
      //---------------------------------------------------------------------------
      async getCursor() {
        errors.assertArgCount(arguments, 0, 0);
        const cursor = new SodaDocCursor();
        cursor._impl = await this._impl.getCursor(this._options);
        return cursor;
      }
      //---------------------------------------------------------------------------
      // getDocuments()
      //   Return an array of documents that match the search criteria.
      //---------------------------------------------------------------------------
      async getDocuments() {
        errors.assertArgCount(arguments, 0, 0);
        const docImpls = await this._impl.getDocuments(this._options);
        const returnVal = new Array(docImpls.length);
        for (let i = 0; i < docImpls.length; i++) {
          returnVal[i] = new SodaDocument();
          returnVal[i]._impl = docImpls[i];
        }
        return returnVal;
      }
      //---------------------------------------------------------------------------
      // getOne()
      //
      // Return the first document that matches the search criteria.
      //---------------------------------------------------------------------------
      async getOne() {
        errors.assertArgCount(arguments, 0, 0);
        const docImpl = await this._impl.getOne(this._options);
        if (docImpl) {
          const doc = new SodaDocument();
          doc._impl = docImpl;
          return doc;
        }
      }
      //---------------------------------------------------------------------------
      // lock()
      //
      //  Pessimistic locking - similar to SELECT FOR UPDATE, these documents
      //  cannot be updated by other threads until an explicit commit/rollback is
      //  called.  With autoCommit set to true is applicable only for one immediate
      //  operation and is not recommended in this context
      //---------------------------------------------------------------------------
      lock() {
        errors.assertArgCount(arguments, 0, 0);
        this._options.lock = true;
        return this;
      }
      //---------------------------------------------------------------------------
      // replaceOne()
      //
      // Replace the first document that matches the search criteria with the
      // specified document.
      //---------------------------------------------------------------------------
      async replaceOne(content) {
        errors.assertArgCount(arguments, 1, 1);
        content = this._sodaDb._verifySodaDoc(content);
        return await this._impl.replaceOne(this._options, content);
      }
      //---------------------------------------------------------------------------
      // replaceOneAndGet()
      //
      // Replace the first document that matches the search criteria with the
      // specified document and then return a result document containing metadata.
      //---------------------------------------------------------------------------
      async replaceOneAndGet(content) {
        errors.assertArgCount(arguments, 1, 1);
        content = this._sodaDb._verifySodaDoc(content);
        const docImpl = await this._impl.replaceOneAndGet(this._options, content);
        if (docImpl) {
          const doc = new SodaDocument();
          doc._impl = docImpl;
          return doc;
        }
      }
      //---------------------------------------------------------------------------
      // remove()
      //
      // Remove the documents that match the search criteria from the collection
      // and return information about the operation to the caller.
      //---------------------------------------------------------------------------
      async remove() {
        errors.assertArgCount(arguments, 0, 0);
        return await this._impl.remove(this._options);
      }
      // fetchArraySize - a non-terminal function that can chain further
      fetchArraySize(n) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(Number.isInteger(n) && n >= 0, 1);
        this._options.fetchArraySize = n;
        return this;
      }
      // filter property - a non-terminal function and can chain further
      filter(f) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(nodbUtil.isObject(f), 1);
        this._options.filter = JSON.stringify(f);
        return this;
      }
      // hint - a non-terminal function and can chain further
      hint(val) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(typeof val === "string", 1);
        this._options.hint = val;
        return this;
      }
      // key - a non-terminal function and can chain further
      key(k) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(typeof k === "string", 1);
        this._options.key = k;
        this._options.keys = void 0;
        return this;
      }
      // keys - a non-terminal function and can chain further
      keys(arr) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(Array.isArray(arr), 1);
        for (let i = 0; i < arr.length; i++) {
          errors.assertParamValue(typeof arr[i] === "string", 1);
        }
        this._options.keys = arr;
        this._options.key = void 0;
        return this;
      }
      // limit property - a non-terminal function and can chain further
      limit(n) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(Number.isInteger(n) && n > 0, 1);
        this._options.limit = n;
        return this;
      }
      // skip property - a non-terminal function and can chain further
      skip(n) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(Number.isInteger(n) && n >= 0, 1);
        this._options.skip = n;
        return this;
      }
      // version property - a non-terminal function and can chain further
      version(v) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(typeof v === "string", 1);
        this._options.version = v;
        return this;
      }
    };
    nodbUtil.wrapFns(
      SodaOperation.prototype,
      "count",
      "getCursor",
      "getDocuments",
      "getOne",
      "remove",
      "replaceOne",
      "replaceOneAndGet"
    );
    module2.exports = SodaOperation;
  }
});

// node_modules/oracledb/lib/sodaCollection.js
var require_sodaCollection2 = __commonJS({
  "node_modules/oracledb/lib/sodaCollection.js"(exports2, module2) {
    "use strict";
    var SodaDocument = require_sodaDocument2();
    var SodaOperation = require_sodaOperation2();
    var errors = require_errors();
    var nodbUtil = require_util();
    var settings = require_settings();
    var SodaCollection = class {
      constructor(sodaDb) {
        this._sodaDb = sodaDb;
      }
      //---------------------------------------------------------------------------
      // createIndex()
      //
      // Create an index on the collection.
      //---------------------------------------------------------------------------
      async createIndex(spec) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(nodbUtil.isObject(spec), 1);
        const options = { autoCommit: settings.autoCommit };
        return await this._impl.createIndex(JSON.stringify(spec), options);
      }
      //---------------------------------------------------------------------------
      // drop()
      //
      // Drop the collection.
      //---------------------------------------------------------------------------
      async drop() {
        errors.assertArgCount(arguments, 0, 0);
        const options = { autoCommit: settings.autoCommit };
        return await this._impl.drop(options);
      }
      //---------------------------------------------------------------------------
      // dropIndex()
      //
      // Drop an index on the collection.
      //---------------------------------------------------------------------------
      async dropIndex(indexName, a2) {
        const options = { autoCommit: settings.autoCommit };
        errors.assertArgCount(arguments, 1, 2);
        errors.assertParamValue(typeof indexName === "string", 1);
        if (arguments.length == 2) {
          errors.assertParamValue(typeof a2 === "object", 2);
          if (a2.force !== void 0) {
            errors.assertParamPropValue(typeof a2.force === "boolean", 2, "force");
            options.force = a2.force;
          }
        }
        return await this._impl.dropIndex(indexName, options);
      }
      //---------------------------------------------------------------------------
      // find()
      //
      // Returns a SODA operation associated with the collection.
      //---------------------------------------------------------------------------
      find() {
        errors.assertArgCount(arguments, 0, 0);
        const op = new SodaOperation(this._sodaDb);
        op._impl = this._impl.find();
        return op;
      }
      //---------------------------------------------------------------------------
      // getDataGuide()
      //   Return the data guide for the collection.
      //---------------------------------------------------------------------------
      async getDataGuide() {
        errors.assertArgCount(arguments, 0, 0);
        const doc = new SodaDocument();
        doc._impl = await this._impl.getDataGuide();
        return doc;
      }
      //---------------------------------------------------------------------------
      // insertMany()
      //
      // Insert an array of documents into the collection in a single round-trip.
      //---------------------------------------------------------------------------
      async insertMany(docs) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(Array.isArray(docs) && docs.length > 0, 1);
        const actualDocs = Array(docs.length);
        for (let i = 0; i < docs.length; i++) {
          actualDocs[i] = this._sodaDb._verifySodaDoc(docs[i]);
        }
        const options = { autoCommit: settings.autoCommit };
        await this._impl.insertMany(actualDocs, options);
      }
      //---------------------------------------------------------------------------
      // insertManyAndGet()
      //
      // Insert an array of documents into the collection in a single round-trip
      // and return a set of result documents containing metadata.
      //---------------------------------------------------------------------------
      async insertManyAndGet(docs, a2) {
        const options = { autoCommit: settings.autoCommit };
        errors.assertArgCount(arguments, 1, 2);
        errors.assertParamValue(Array.isArray(docs) && docs.length > 0, 1);
        if (arguments.length == 2) {
          errors.assertParamValue(nodbUtil.isObject(a2), 2);
          if (a2.hint !== void 0) {
            errors.assertParamPropValue(typeof a2.hint === "string", 2, "hint");
            options.hint = a2.hint;
          }
        }
        const actualDocs = Array(docs.length);
        for (let i = 0; i < docs.length; i++) {
          actualDocs[i] = this._sodaDb._verifySodaDoc(docs[i]);
        }
        const docImpls = await this._impl.insertManyAndGet(actualDocs, options);
        for (let i = 0; i < docs.length; i++) {
          const doc = actualDocs[i] = new SodaDocument();
          doc._impl = docImpls[i];
        }
        return actualDocs;
      }
      //---------------------------------------------------------------------------
      // insertOne()
      //
      // Inserts a single document into the collection.
      //---------------------------------------------------------------------------
      async insertOne(content) {
        errors.assertArgCount(arguments, 1, 1);
        content = this._sodaDb._verifySodaDoc(content);
        const options = { autoCommit: settings.autoCommit };
        await this._impl.insertOne(content, options);
      }
      //---------------------------------------------------------------------------
      // insertOneAndGet()
      //
      // Inserts a single document into the collection and returns a result
      // document containing metadata.
      //---------------------------------------------------------------------------
      async insertOneAndGet(content, a2) {
        const options = { autoCommit: settings.autoCommit };
        errors.assertArgCount(arguments, 1, 2);
        content = this._sodaDb._verifySodaDoc(content);
        if (arguments.length == 2) {
          errors.assertParamValue(nodbUtil.isObject(a2), 2);
          if (a2.hint !== void 0) {
            errors.assertParamPropValue(typeof a2.hint === "string", 2, "hint");
            options.hint = a2.hint;
          }
        }
        const doc = new SodaDocument();
        doc._impl = await this._impl.insertOneAndGet(content, options);
        return doc;
      }
      //---------------------------------------------------------------------------
      // listIndexes()
      //
      //   To obtain all indices from the collection
      //---------------------------------------------------------------------------
      async listIndexes() {
        const arr = await this._impl.listIndexes();
        return arr.map((i) => JSON.parse(i));
      }
      //---------------------------------------------------------------------------
      // metaData()
      //
      // Property for the metadata associated with the collection.
      //---------------------------------------------------------------------------
      get metaData() {
        return JSON.parse(this._impl.getMetaData());
      }
      //---------------------------------------------------------------------------
      // name()
      //
      // Property for the name of the collection.
      //---------------------------------------------------------------------------
      get name() {
        return this._impl.getName();
      }
      //---------------------------------------------------------------------------
      // save()
      //
      // Saves a single document into the collection.
      //---------------------------------------------------------------------------
      async save(content) {
        errors.assertArgCount(arguments, 1, 1);
        content = this._sodaDb._verifySodaDoc(content);
        const options = { autoCommit: settings.autoCommit };
        await this._impl.save(content, options);
      }
      //---------------------------------------------------------------------------
      // saveAndGet()
      //
      // Saves a single document into the collection and returns a result document
      // containing metadata.
      //---------------------------------------------------------------------------
      async saveAndGet(content, a2) {
        errors.assertArgCount(arguments, 1, 2);
        content = this._sodaDb._verifySodaDoc(content);
        const options = { autoCommit: settings.autoCommit };
        if (arguments.length == 2) {
          errors.assertParamValue(nodbUtil.isObject(a2), 2);
          if (a2.hint !== void 0) {
            errors.assertParamPropValue(typeof a2.hint === "string", 2, "hint");
            options.hint = a2.hint;
          }
        }
        const doc = new SodaDocument();
        doc._impl = await this._impl.saveAndGet(content, options);
        return doc;
      }
      //---------------------------------------------------------------------------
      // truncate()
      //
      // Remove all of the documents from a collection.
      //---------------------------------------------------------------------------
      async truncate() {
        errors.assertArgCount(arguments, 0, 0);
        await this._impl.truncate();
      }
    };
    nodbUtil.wrapFns(
      SodaCollection.prototype,
      "createIndex",
      "drop",
      "dropIndex",
      "getDataGuide",
      "insertMany",
      "insertManyAndGet",
      "insertOne",
      "insertOneAndGet",
      "listIndexes",
      "save",
      "saveAndGet",
      "truncate"
    );
    module2.exports = SodaCollection;
  }
});

// node_modules/oracledb/lib/sodaDatabase.js
var require_sodaDatabase2 = __commonJS({
  "node_modules/oracledb/lib/sodaDatabase.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var SodaCollection = require_sodaCollection2();
    var SodaDocument = require_sodaDocument2();
    var errors = require_errors();
    var nodbUtil = require_util();
    var settings = require_settings();
    var transformer = require_transformer();
    var SodaDatabase = class {
      _getConnection() {
        return this._connection;
      }
      //---------------------------------------------------------------------------
      // createCollection()
      //
      // Creates a SODA collection.
      //---------------------------------------------------------------------------
      async createCollection(name, a2) {
        const options = { autoCommit: settings.autoCommit };
        errors.assertArgCount(arguments, 1, 2);
        errors.assertParamValue(typeof name === "string", 1);
        if (arguments.length == 2) {
          errors.assertParamValue(nodbUtil.isObject(a2), 2);
          if (a2.mode !== void 0) {
            errors.assertParamPropValue(
              Number.isInteger(a2.mode) && a2.mode > 0,
              2,
              "mode"
            );
            options.mode = a2.mode;
          }
          if (a2.metaData !== void 0) {
            errors.assertParamPropValue(
              nodbUtil.isObject(a2.metaData),
              2,
              "metaData"
            );
            options.metaData = JSON.stringify(a2.metaData);
          }
        }
        const coll = new SodaCollection(this);
        coll._impl = await this._impl.createCollection(name, options);
        return coll;
      }
      //---------------------------------------------------------------------------
      // createDocument()
      //
      // Creates a SODA document.
      //---------------------------------------------------------------------------
      createDocument(content, a2) {
        let options = {};
        let inContent;
        errors.assertArgCount(arguments, 1, 2);
        errors.assertParamValue(Buffer2.isBuffer(content) || typeof content === "string" || nodbUtil.isObject(content), 1);
        if (arguments.length > 1) {
          errors.assertParamValue(nodbUtil.isObject(a2), 2);
          options = a2;
          errors.assertParamPropString(options, 2, "key");
          errors.assertParamPropString(options, 2, "mediaType");
        }
        if (this._impl.supportsJson && (!options.mediaType || options.mediaType === "application/json")) {
          inContent = transformer.transformJsonValue(content);
        } else if (Buffer2.isBuffer(content)) {
          inContent = content;
        } else if (typeof content === "string") {
          inContent = Buffer2.from(content);
        } else {
          inContent = Buffer2.from(JSON.stringify(content));
        }
        const doc = new SodaDocument();
        doc._impl = this._impl.createDocument(inContent, options);
        return doc;
      }
      //---------------------------------------------------------------------------
      // getCollectionNames()
      //
      // Return an array of the names of the collections in the database.
      //---------------------------------------------------------------------------
      async getCollectionNames(a1) {
        let options = {};
        errors.assertArgCount(arguments, 0, 1);
        if (arguments.length == 1) {
          errors.assertParamValue(nodbUtil.isObject(a1), 1);
          options = a1;
          if (options.startsWith !== void 0) {
            errors.assertParamPropValue(
              typeof options.startsWith === "string",
              1,
              "startsWith"
            );
          }
          if (options.limit !== void 0) {
            errors.assertParamPropValue(
              Number.isInteger(options.limit),
              1,
              "limit"
            );
          }
        }
        return await this._impl.getCollectionNames(options);
      }
      //---------------------------------------------------------------------------
      // openCollection()
      //
      // Open an existing SODA collection and return it to the caller.
      //---------------------------------------------------------------------------
      async openCollection(name) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(typeof name === "string", 1);
        const options = { autoCommit: settings.autoCommit };
        const collImpl = await this._impl.openCollection(name, options);
        if (collImpl) {
          const coll = new SodaCollection(this);
          coll._impl = collImpl;
          return coll;
        }
      }
      //---------------------------------------------------------------------------
      // _verifySodaDoc()
      //
      // Verifies the content passed is valid for a SodaDocument object.
      //---------------------------------------------------------------------------
      _verifySodaDoc(content) {
        if (content != null && content._sodaDocumentMarker)
          return content._impl;
        errors.assertParamValue(nodbUtil.isObject(content), 1);
        if (this._impl._supportsJson)
          return transformer.transformJsonValue(content);
        return Buffer2.from(JSON.stringify(content));
      }
    };
    nodbUtil.wrapFns(
      SodaDatabase.prototype,
      "createCollection",
      "getCollectionNames",
      "openCollection"
    );
    module2.exports = SodaDatabase;
  }
});

// node_modules/oracledb/lib/connection.js
var require_connection2 = __commonJS({
  "node_modules/oracledb/lib/connection.js"(exports2, module2) {
    "use strict";
    var AqQueue = require_aqQueue2();
    var BaseDbObject = require_dbObject2();
    var { Buffer: Buffer2 } = require("buffer");
    var Lob = require_lob2();
    var ResultSet = require_resultset2();
    var SodaDatabase = require_sodaDatabase2();
    var EventEmitter = require("events");
    var QueryStream = require_queryStream();
    var errors = require_errors();
    var nodbUtil = require_util();
    var impl = require_impl();
    var process2 = require("process");
    var util = require("util");
    var constants = require_constants();
    var settings = require_settings();
    var transformer = require_transformer();
    var types = require_types();
    var oson = require_oson();
    var _subscriptions = /* @__PURE__ */ new Map();
    var defaultNumberConverter = (v) => v === null ? null : parseFloat(v);
    function _determineDbObjTypeConverter(metadata, options) {
      delete metadata.converter;
      if (options.dbObjectTypeHandler) {
        const result = options.dbObjectTypeHandler(metadata);
        if (result !== void 0) {
          errors.assert(
            typeof result === "object",
            errors.ERR_DB_FETCH_TYPE_HANDLER_RETURN_VALUE
          );
          if (result.converter !== void 0) {
            errors.assert(
              typeof result.converter === "function",
              errors.ERR_DB_FETCH_TYPE_HANDLER_CONVERTER
            );
          }
          if ([
            types.DB_TYPE_CLOB,
            types.DB_TYPE_NCLOB,
            types.DB_TYPE_BLOB,
            types.DB_TYPE_BFILE
          ].includes(metadata.type)) {
            return errors.throwErr(
              errors.ERR_NOT_IMPLEMENTED,
              "DbObjConverter for LOBs"
            );
          }
          metadata.converter = result.converter;
        }
      }
      if (metadata.type === types.DB_TYPE_NUMBER && !metadata.converter) {
        metadata.converter = defaultNumberConverter;
      }
    }
    var Connection = class extends EventEmitter {
      constructor() {
        super();
        this._dbObjectClasses = /* @__PURE__ */ new Map();
        this._closing = false;
      }
      //---------------------------------------------------------------------------
      // _addDefaultsToExecOpts()
      //
      // Add values to the execute options from the global settings, if needed.
      //---------------------------------------------------------------------------
      _addDefaultsToExecOpts(options) {
        options.connection = this;
        if (options.keepInStmtCache === void 0)
          options.keepInStmtCache = true;
        if (options.suspendOnSuccess === void 0)
          options.suspendOnSuccess = false;
        settings.addToOptions(
          options,
          "autoCommit",
          "dbObjectAsPojo",
          "fetchArraySize",
          "fetchTypeHandler",
          "maxRows",
          "outFormat",
          "prefetchRows"
        );
      }
      //---------------------------------------------------------------------------
      // _buildDbObjectClass()
      //
      // Builds and returns a database object class given the object type
      // information supplied by the implementation.
      //---------------------------------------------------------------------------
      _buildDbObjectClass(objType) {
        const DbObject = function(initialValue) {
          this._impl = new impl.DbObjectImpl(objType);
          if (this.isCollection) {
            const proxy = new Proxy(this, BaseDbObject._collectionProxyHandler);
            if (initialValue !== void 0) {
              for (let i = 0; i < initialValue.length; i++) {
                this.append(initialValue[i]);
              }
            }
            return proxy;
          } else if (initialValue !== void 0) {
            for (const attr of objType.attributes) {
              const value = initialValue[attr.name];
              if (value !== void 0) {
                this._setAttrValue(attr, value);
              }
            }
          }
        };
        DbObject.prototype = Object.create(BaseDbObject.prototype);
        DbObject.prototype.constructor = DbObject;
        DbObject.prototype._objType = objType;
        if (objType.elementTypeClass) {
          const cls = this._getDbObjectClass(objType.elementTypeClass);
          objType.elementTypeClass = cls;
        }
        const options = { dbObjectTypeHandler: settings.dbObjectTypeHandler };
        if (objType.isCollection) {
          nodbUtil.addTypeProperties(objType, "elementType");
          objType.elementTypeInfo.type = objType.elementType;
          _determineDbObjTypeConverter(objType.elementTypeInfo, options);
        }
        if (objType.attributes) {
          const props = {};
          for (const attr of objType.attributes) {
            if (attr.typeClass) {
              attr.typeClass = this._getDbObjectClass(attr.typeClass);
            }
            nodbUtil.addTypeProperties(attr, "type");
            const prop = {
              get() {
                return this._getAttrValue(attr);
              },
              set(value) {
                this._setAttrValue(attr, value);
              }
            };
            props[attr.name] = prop;
            _determineDbObjTypeConverter(attr, options);
          }
          Object.defineProperties(DbObject.prototype, props);
        }
        DbObject.toString = function() {
          return "DbObjectClass [" + objType.fqn + "]";
        };
        return DbObject;
      }
      //---------------------------------------------------------------------------
      // _getDbObjectClass()
      //
      // Returns the database object class given the object type information
      // supplied by the implementation. The cache is searched first to see if an
      // object class has already been built.
      //---------------------------------------------------------------------------
      _getDbObjectClass(objType) {
        if (objType.prototype instanceof BaseDbObject)
          return objType;
        let cls = this._dbObjectClasses.get(objType);
        if (!cls) {
          cls = this._buildDbObjectClass(objType);
          cls._connection = this;
          cls._objType = objType;
          objType._connection = this._impl;
          this._dbObjectClasses.set(objType, cls);
        }
        return cls;
      }
      //---------------------------------------------------------------------------
      // _getDbObjectClassForName()
      //
      // Returns the database object class given the name of the database object
      // type. The cache is searched first to see if an object class has already
      // been built.
      //---------------------------------------------------------------------------
      async _getDbObjectClassForName(name) {
        let cls = this._dbObjectClasses.get(name);
        if (!cls) {
          const objType = await this._impl.getDbObjectClass(name);
          cls = this._getDbObjectClass(objType);
          this._dbObjectClasses.set(name, cls);
        }
        return cls;
      }
      //---------------------------------------------------------------------------
      // _isBindDir()
      //
      // Returns a boolean indicating if the supplied value is a valid bind
      // direction.
      //---------------------------------------------------------------------------
      _isBindDir(value) {
        return value === constants.BIND_IN || value === constants.BIND_OUT || value === constants.BIND_INOUT;
      }
      //---------------------------------------------------------------------------
      // _isBindValue()
      //
      // Returns a boolean indicating if the supplied value is one that can be
      // bound.
      //---------------------------------------------------------------------------
      _isBindValue(value) {
        return value === null || value === void 0 || typeof value === "number" || typeof value === "string" || typeof value === "boolean" || typeof value === "bigint" || Array.isArray(value) || nodbUtil.isVectorValue(value) || Buffer2.isBuffer(value) || util.types.isDate(value) || value instanceof Lob || value instanceof ResultSet || value instanceof BaseDbObject;
      }
      //---------------------------------------------------------------------------
      // _processBindUnit()
      //
      // Processes a bind unit (object) supplied by the user and returns the value
      // stored in it (if one is).
      //---------------------------------------------------------------------------
      async _processBindUnit(bindInfo, bindUnit, inExecuteMany) {
        let okBindUnit = false;
        if (bindUnit.dir === void 0) {
          bindInfo.dir = constants.BIND_IN;
        } else {
          errors.assert(
            this._isBindDir(bindUnit.dir),
            errors.ERR_INVALID_BIND_DIRECTION
          );
          bindInfo.dir = bindUnit.dir;
          okBindUnit = true;
        }
        if (bindUnit.type !== void 0) {
          if (typeof bindUnit.type === "string") {
            bindInfo.type = types.DB_TYPE_OBJECT;
            bindInfo.typeClass = await this._getDbObjectClassForName(bindUnit.type);
            bindInfo.objType = bindInfo.typeClass._objType;
          } else if (bindUnit.type.prototype instanceof BaseDbObject) {
            bindInfo.type = types.DB_TYPE_OBJECT;
            bindInfo.typeClass = bindUnit.type;
            bindInfo.objType = bindInfo.typeClass._objType;
          } else {
            errors.assert(
              bindUnit.type instanceof types.DbType,
              errors.ERR_INVALID_BIND_DATA_TYPE,
              2
            );
            bindInfo.type = bindUnit.type;
          }
          okBindUnit = true;
        } else if (inExecuteMany) {
          if (bindInfo.name)
            errors.throwErr(errors.ERR_MISSING_TYPE_BY_NAME, bindInfo.name);
          errors.throwErr(errors.ERR_MISSING_TYPE_BY_POS, bindInfo.pos);
        }
        if (bindInfo.dir !== constants.BIND_IN || inExecuteMany) {
          if (bindUnit.maxSize !== void 0) {
            errors.assertParamPropValue(Number.isInteger(bindUnit.maxSize) && bindUnit.maxSize > 0, 2, "maxSize");
            bindInfo.maxSize = bindUnit.maxSize;
            bindInfo.checkSize = true;
            okBindUnit = true;
          } else if (inExecuteMany) {
            if (bindInfo.type === types.DB_TYPE_VARCHAR || bindInfo.type === types.DB_TYPE_RAW) {
              if (bindInfo.name)
                errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_NAME, bindInfo.name);
              errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_POS, bindInfo.pos);
            }
          } else {
            bindInfo.maxSize = constants.DEFAULT_MAX_SIZE_FOR_OUT_BINDS;
          }
        }
        bindInfo.isArray = false;
        if (!inExecuteMany) {
          if (bindUnit.maxArraySize !== void 0) {
            errors.assertParamPropValue(Number.isInteger(bindUnit.maxArraySize) && bindUnit.maxArraySize > 0, 2, "maxArraySize");
            bindInfo.maxArraySize = bindUnit.maxArraySize;
            bindInfo.isArray = true;
          }
        }
        if (!inExecuteMany && bindUnit.val !== void 0) {
          return bindUnit.val;
        }
        if (!okBindUnit)
          errors.throwErr(errors.ERR_INVALID_BIND_UNIT);
      }
      //---------------------------------------------------------------------------
      // _processBindValue()
      //
      // Processes the bind value supplied by the caller. This performs all checks
      // on the value and normalizes it for use by the implementation class. If no
      // bind info has been defined yet, the value defines that.
      //---------------------------------------------------------------------------
      async _processBindValue(bindInfo, value, options) {
        const transformed = transformer.transformValueIn(bindInfo, value, options);
        if (bindInfo.isArray) {
          bindInfo.values = transformed.concat(bindInfo.values.slice(transformed.length));
        } else {
          bindInfo.values[options.pos] = transformed;
        }
        if (bindInfo.type === types.DB_TYPE_OBJECT && bindInfo.typeClass === void 0) {
          bindInfo.typeClass = await this._getDbObjectClass(value._objType);
          bindInfo.objType = bindInfo.typeClass._objType;
        }
      }
      //---------------------------------------------------------------------------
      // _processExecuteBind()
      //
      // Processes a single execute bind supplied by the caller. This performs all
      // checks on the bind and normalizes it for use by the implementation class.
      //---------------------------------------------------------------------------
      async _processExecuteBind(bindInfo, bindData) {
        bindInfo.isArray = false;
        let bindValue;
        if (this._isBindValue(bindData)) {
          bindInfo.dir = constants.BIND_IN;
          bindValue = bindData;
        } else {
          bindValue = await this._processBindUnit(bindInfo, bindData, false);
        }
        if (bindInfo.dir !== constants.BIND_OUT) {
          const options = { pos: 0, allowArray: true };
          await this._processBindValue(bindInfo, bindValue, options);
        }
        if (bindInfo.type === void 0) {
          bindInfo.type = types.DB_TYPE_VARCHAR;
          if (bindInfo.maxSize === void 0)
            bindInfo.maxSize = 1;
        }
        if (bindInfo.isArray && bindInfo.type !== types.DB_TYPE_VARCHAR && bindInfo.type !== types.DB_TYPE_NVARCHAR && bindInfo.type !== types.DB_TYPE_CHAR && bindInfo.type !== types.DB_TYPE_NCHAR && bindInfo.type !== types.DB_TYPE_NUMBER && bindInfo.type !== types.DB_TYPE_BINARY_FLOAT && bindInfo.type !== types.DB_TYPE_BINARY_DOUBLE && bindInfo.type !== types.DB_TYPE_DATE && bindInfo.type !== types.DB_TYPE_TIMESTAMP && bindInfo.type !== types.DB_TYPE_TIMESTAMP_LTZ && bindInfo.type !== types.DB_TYPE_TIMESTAMP_TZ && bindInfo.type !== types.DB_TYPE_RAW && bindInfo.type !== types.DB_TYPE_INTERVAL_YM && bindInfo.type !== types.DB_TYPE_INTERVAL_DS) {
          errors.throwErr(errors.ERR_INVALID_TYPE_FOR_ARRAY_BIND);
        }
      }
      //---------------------------------------------------------------------------
      // _processExecuteBinds()
      //
      // Processes the binds supplied by the caller. This performs all checks on
      // the binds and normalizes them for use by the implementation class.
      //---------------------------------------------------------------------------
      async _processExecuteBinds(binds) {
        const normBinds = [];
        if (Array.isArray(binds)) {
          for (let i = 0; i < binds.length; i++) {
            const bindInfo = normBinds[i] = { pos: i + 1, values: [] };
            await this._processExecuteBind(bindInfo, binds[i]);
          }
        } else {
          errors.assertParamValue(nodbUtil.isObject(binds), 2);
          const bindNames = Object.getOwnPropertyNames(binds);
          for (let i = 0; i < bindNames.length; i++) {
            const bindInfo = normBinds[i] = { name: bindNames[i], values: [] };
            await this._processExecuteBind(bindInfo, binds[bindNames[i]]);
          }
        }
        return normBinds;
      }
      //---------------------------------------------------------------------------
      // _processExecuteManyBinds()
      //
      // Processes the binds supplied by the caller. This performs all checks on
      // the binds and normalizes them for use by the implementation class.
      //---------------------------------------------------------------------------
      async _processExecuteManyBinds(binds, bindDefs) {
        const normBinds = [];
        let byPosition;
        if (bindDefs !== void 0) {
          if (Array.isArray(bindDefs)) {
            byPosition = true;
            for (let i = 0; i < bindDefs.length; i++) {
              const bindInfo = normBinds[i] = { pos: i + 1, values: [] };
              await this._processBindUnit(bindInfo, bindDefs[i], true);
            }
          } else {
            byPosition = false;
            const bindNames = Object.getOwnPropertyNames(bindDefs);
            for (let i = 0; i < bindNames.length; i++) {
              const bindInfo = normBinds[i] = { name: bindNames[i], values: [] };
              await this._processBindUnit(bindInfo, bindDefs[bindNames[i]], true);
            }
          }
        } else {
          const row = binds[0];
          errors.assertParamValue(nodbUtil.isObjectOrArray(row), 2);
          if (Array.isArray(row)) {
            byPosition = true;
            for (let i = 0; i < row.length; i++) {
              normBinds[i] = { pos: i + 1 };
            }
          } else {
            byPosition = false;
            const bindNames = Object.getOwnPropertyNames(row);
            for (let i = 0; i < bindNames.length; i++) {
              normBinds[i] = { name: bindNames[i] };
            }
          }
          for (let i = 0; i < normBinds.length; i++) {
            normBinds[i].dir = constants.BIND_IN;
            normBinds[i].isArray = false;
            normBinds[i].values = [];
          }
        }
        for (let i = 0; i < binds.length; i++) {
          const row = binds[i];
          const options = { pos: i, allowArray: false };
          errors.assert(byPosition && Array.isArray(row) || !byPosition && nodbUtil.isObject(row), errors.ERR_MIXED_BIND);
          for (let j = 0; j < normBinds.length; j++) {
            const bindInfo = normBinds[j];
            const value = byPosition ? row[j] : row[bindInfo.name];
            await this._processBindValue(bindInfo, value, options);
          }
        }
        for (let i = 0; i < normBinds.length; i++) {
          const bindInfo = normBinds[i];
          if (bindInfo.type === void 0) {
            bindInfo.type = types.DB_TYPE_VARCHAR;
            bindInfo.maxSize = 1;
          }
        }
        return normBinds;
      }
      //---------------------------------------------------------------------------
      // _transformOutBind()
      //
      // Transform an output bind value from an implementation value to a user
      // facing value (for result sets and LOBs). DML returning output variables
      // are always an array of values.
      //---------------------------------------------------------------------------
      _transformOutBind(val, options) {
        let outVal = val;
        if (Array.isArray(val)) {
          outVal = [];
          for (let i = 0; i < val.length; i++)
            outVal.push(this._transformOutBind(val[i], options));
        } else if (val instanceof impl.ResultSetImpl) {
          outVal = new ResultSet();
          outVal._setup(this, val);
        } else if (val instanceof impl.LobImpl) {
          outVal = new Lob();
          outVal._setup(val, true);
        } else if (val instanceof impl.DbObjectImpl) {
          const cls = this._dbObjectClasses.get(val._objType);
          outVal = Object.create(cls.prototype);
          outVal._impl = val;
          if (options.dbObjectAsPojo) {
            outVal = outVal._toPojo();
          } else if (outVal.isCollection) {
            outVal = new Proxy(outVal, BaseDbObject._collectionProxyHandler);
          }
        }
        return outVal;
      }
      //---------------------------------------------------------------------------
      // _verifyExecOpts
      //
      // Verify that the value passed by the user for binds is acceptable. Perform
      // any transformations necessary.
      //---------------------------------------------------------------------------
      _verifyExecOpts(options, inExecuteMany) {
        const outOptions = {};
        errors.assertParamValue(nodbUtil.isObject(options), 3);
        if (options.autoCommit !== void 0) {
          errors.assertParamPropValue(
            typeof options.autoCommit === "boolean",
            3,
            "autoCommit"
          );
          outOptions.autoCommit = options.autoCommit;
        }
        if (options.dbObjectAsPojo !== void 0) {
          errors.assertParamPropValue(
            typeof options.dbObjectAsPojo === "boolean",
            3,
            "dbObjectAsPojo"
          );
          outOptions.dbObjectAsPojo = options.dbObjectAsPojo;
        }
        if (options.keepInStmtCache !== void 0) {
          errors.assertParamPropValue(
            typeof options.keepInStmtCache === "boolean",
            3,
            "keepInStmtCache"
          );
          outOptions.keepInStmtCache = options.keepInStmtCache;
        }
        if (options.suspendOnSuccess !== void 0) {
          errors.assertParamPropBool(options, 2, "suspendOnSucess");
          outOptions.suspendOnSuccess = options.suspendOnSuccess;
        }
        if (inExecuteMany) {
          if (options.bindDefs !== void 0) {
            errors.assertParamPropValue(
              nodbUtil.isObjectOrArray(options.bindDefs),
              3,
              "bindDefs"
            );
            outOptions.bindDefs = options.bindDefs;
          }
          if (options.batchErrors !== void 0) {
            errors.assertParamPropValue(
              typeof options.batchErrors === "boolean",
              3,
              "batchErrors"
            );
            outOptions.batchErrors = options.batchErrors;
          }
          if (options.dmlRowCounts !== void 0) {
            errors.assertParamPropValue(
              typeof options.dmlRowCounts === "boolean",
              3,
              "dmlRowCounts"
            );
            outOptions.dmlRowCounts = options.dmlRowCounts;
          }
        } else {
          errors.assertParamPropUnsignedIntNonZero(options, 3, "fetchArraySize");
          outOptions.fetchArraySize = options.fetchArraySize;
          if (options.fetchInfo !== void 0) {
            errors.assertParamPropValue(
              nodbUtil.isObject(options.fetchInfo),
              3,
              "fetchInfo"
            );
            const names = Object.getOwnPropertyNames(options.fetchInfo);
            const map = new Map(settings.fetchTypeMap);
            for (const name of names) {
              const info = options.fetchInfo[name];
              if (info.type === void 0)
                errors.throwErr(errors.ERR_NO_TYPE_FOR_CONVERSION);
              if (info.type !== constants.DEFAULT && info.type !== types.DB_TYPE_VARCHAR && info.type !== types.DB_TYPE_RAW) {
                errors.throwErr(errors.ERR_INVALID_TYPE_FOR_CONVERSION);
              }
              map.set(name, info.type);
            }
            outOptions.fetchTypeMap = map;
          }
          if (options.fetchTypeHandler !== void 0) {
            const type = typeof options.fetchTypeHandler;
            errors.assertParamPropValue(type === "function", 3, "fetchTypeHandler");
            outOptions.fetchTypeHandler = options.fetchTypeHandler;
          }
          if (options.maxRows !== void 0) {
            errors.assertParamPropValue(Number.isInteger(options.maxRows) && options.maxRows >= 0, 3, "maxRows");
            outOptions.maxRows = options.maxRows;
          }
          if (options.outFormat !== void 0) {
            errors.assertParamPropValue(
              options.outFormat === constants.OUT_FORMAT_ARRAY || options.outFormat === constants.OUT_FORMAT_OBJECT,
              3,
              "outFormat"
            );
            outOptions.outFormat = options.outFormat;
          }
          if (options.prefetchRows !== void 0) {
            errors.assertParamPropValue(Number.isInteger(options.prefetchRows) && options.prefetchRows >= 0, 3, "prefetchRows");
            outOptions.prefetchRows = options.prefetchRows;
          }
          if (options.resultSet !== void 0) {
            errors.assertParamPropValue(
              typeof options.resultSet === "boolean",
              3,
              "resultSet"
            );
            outOptions.resultSet = options.resultSet;
          }
        }
        return outOptions;
      }
      //---------------------------------------------------------------------------
      // action
      //
      // Property for end-to-end tracing attribute.
      //---------------------------------------------------------------------------
      get action() {
        return null;
      }
      set action(value) {
        errors.assertPropValue(typeof value === "string", "action");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setAction(value);
      }
      //---------------------------------------------------------------------------
      // beginSessionlessTransaction()
      //
      // Begin a new sessionless transaction with provided transactionId.
      // If transactionId wasn't provided a random-generated transactionId will be
      // used and returned.
      //---------------------------------------------------------------------------
      async beginSessionlessTransaction(options = {}) {
        errors.assertArgCount(arguments, 0, 1);
        errors.assertParamValue(nodbUtil.isObject(options), 1);
        if (options.transactionId !== void 0)
          errors.assertParamPropValue(
            nodbUtil.isTransactionId(options.transactionId),
            1,
            "transactionId"
          );
        errors.assertParamPropUnsignedIntNonZero(options, 1, "timeout");
        errors.assertParamPropBool(options, 1, "deferRoundTrip");
        const normalizedTransactionId = nodbUtil.normalizeTransactionId(options.transactionId);
        const { timeout = 60, deferRoundTrip = false } = options;
        await this._impl.startSessionlessTransaction(
          normalizedTransactionId,
          timeout,
          constants.TPC_BEGIN_NEW,
          deferRoundTrip
        );
        return normalizedTransactionId;
      }
      //---------------------------------------------------------------------------
      // breakExecution()
      //
      // Breaks execution of a running statement.
      //---------------------------------------------------------------------------
      async breakExecution() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.breakExecution();
      }
      //---------------------------------------------------------------------------
      // callTimeout
      //
      // Property for round-trip timeouts.
      //---------------------------------------------------------------------------
      get callTimeout() {
        if (this._impl)
          return this._impl.getCallTimeout();
        return void 0;
      }
      set callTimeout(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "callTimeout"
        );
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setCallTimeout(value);
      }
      //---------------------------------------------------------------------------
      // changePassword()
      //
      // Changes the password of the specified user.
      //---------------------------------------------------------------------------
      async changePassword(user, password, newPassword) {
        errors.assertArgCount(arguments, 3, 3);
        errors.assertParamValue(typeof user === "string", 1);
        errors.assertParamValue(typeof password === "string", 2);
        errors.assertParamValue(typeof newPassword === "string", 3);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.changePassword(user, password, newPassword);
      }
      //---------------------------------------------------------------------------
      // clientId
      //
      // Property for end-to-end tracing attribute.
      //---------------------------------------------------------------------------
      get clientId() {
        return null;
      }
      set clientId(value) {
        errors.assertPropValue(typeof value === "string", "clientId");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setClientId(value);
      }
      //---------------------------------------------------------------------------
      // clientInfo
      //
      // Property for end-to-end tracing attribute.
      //---------------------------------------------------------------------------
      get clientInfo() {
        return null;
      }
      set clientInfo(value) {
        errors.assertPropValue(typeof value === "string", "clientInfo");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setClientInfo(value);
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Closes the connection and makes it unusable for further work.
      //---------------------------------------------------------------------------
      async close(a1) {
        let options = {};
        errors.assertArgCount(arguments, 0, 1);
        if (arguments.length == 1) {
          errors.assertParamValue(nodbUtil.isObject(a1), 1);
          options = a1;
          errors.assertParamPropBool(options, 1, "drop");
        }
        errors.assert(this._impl && !this._closing, errors.ERR_INVALID_CONNECTION);
        this._closing = true;
        try {
          if (this._pool) {
            await this._pool._release(this._impl, options);
          } else {
            await this._impl.close(options);
          }
        } finally {
          this._closing = false;
        }
        delete this._impl;
        if (!this.thin) {
          for (const cls of this._dbObjectClasses.values()) {
            cls._objType.refCleanup();
          }
        }
        this._dbObjectClasses.clear();
      }
      //---------------------------------------------------------------------------
      // commit()
      //
      // Commits the current transaction.
      //---------------------------------------------------------------------------
      async commit() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.commit();
      }
      //---------------------------------------------------------------------------
      // createLob()
      //
      // Creates a temporary LOB and returns it to the caller.
      //---------------------------------------------------------------------------
      async createLob(type) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(type === types.DB_TYPE_CLOB || type === types.DB_TYPE_BLOB || type === types.DB_TYPE_NCLOB, 1);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        const lob = new Lob();
        lob._setup(await this._impl.createLob(type), false);
        return lob;
      }
      //---------------------------------------------------------------------------
      // currentSchema
      //
      // Property for identifying the current schema to use in the database.
      //---------------------------------------------------------------------------
      get currentSchema() {
        if (this._impl)
          return this._impl.getCurrentSchema();
        return void 0;
      }
      set currentSchema(value) {
        errors.assertPropValue(typeof value === "string", "currentSchema");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setCurrentSchema(value);
      }
      //---------------------------------------------------------------------------
      // dbOp
      //
      // Property for end-to-end tracing attribute.
      //---------------------------------------------------------------------------
      get dbOp() {
        return null;
      }
      set dbOp(value) {
        errors.assertPropValue(typeof value === "string", "dbOp");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setDbOp(value);
      }
      //---------------------------------------------------------------------------
      // thin()
      //
      // return true, if driver mode is thin while acquiring connection
      // return false, if driver mode is thick while acquiring connection
      //---------------------------------------------------------------------------
      get thin() {
        return settings.thin;
      }
      //---------------------------------------------------------------------------
      // ecid
      //
      // Property for end-to-end tracing attribute.
      //---------------------------------------------------------------------------
      get ecid() {
        return null;
      }
      set ecid(value) {
        errors.assertPropValue(typeof value === "string", "ecid");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setECID(value);
      }
      //---------------------------------------------------------------------------
      // decode()
      //
      // Decodes OSON Buffer to JS data type.
      //---------------------------------------------------------------------------
      decodeOSON(buf) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(Buffer2.isBuffer(buf), 1);
        const decoder = new oson.OsonDecoder(buf);
        return decoder.decode();
      }
      //---------------------------------------------------------------------------
      // encode()
      //
      // Encodes the JS value into OSON bytes.
      //---------------------------------------------------------------------------
      encodeOSON(value) {
        const encoder = new oson.OsonEncoder();
        return encoder.encode(transformer.transformJsonValue(value), this._impl._osonMaxFieldNameSize);
      }
      //---------------------------------------------------------------------------
      // execute()
      //
      // Executes a SQL statement and returns the results.
      //---------------------------------------------------------------------------
      async execute(sql, a2, a3) {
        const numIters = 1;
        let binds = [];
        let options = {};
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        if (nodbUtil.isObject(sql) && typeof sql.statement === "string") {
          errors.assertArgCount(arguments, 1, 2);
          if (sql.values) {
            if (this._impl._callLevelTraceData) {
              this._impl._callLevelTraceData.values = sql.values;
            }
            binds = await this._processExecuteBinds(sql.values);
          }
          sql = sql.statement;
          if (arguments.length == 2) {
            options = this._verifyExecOpts(a2, false);
          }
        } else {
          errors.assertArgCount(arguments, 1, 3);
          errors.assertParamValue(typeof sql === "string", 1);
          if (arguments.length >= 2) {
            if (this._impl._callLevelTraceData) {
              this._impl._callLevelTraceData.values = a2;
            }
            binds = await this._processExecuteBinds(a2);
          }
          if (arguments.length == 3) {
            options = this._verifyExecOpts(a3, false);
          }
        }
        this._addDefaultsToExecOpts(options);
        let result;
        try {
          if (this._impl._callLevelTraceData) {
            this._impl._callLevelTraceData.statement = sql;
          }
          result = await this._impl.execute(sql, numIters, binds, options, false);
        } catch (err) {
          if (err.errorNum === 1406)
            errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);
          throw err;
        }
        if (result.warning) {
          result.warning = errors.transformErr(result.warning);
        }
        if (result.resultSet !== void 0) {
          const resultSet = new ResultSet();
          resultSet._setup(this, result.resultSet);
          result.metaData = resultSet._impl.metaData;
          if (options.resultSet) {
            result.resultSet = resultSet;
          } else {
            result.rows = await resultSet._getAllRows();
            delete result.resultSet;
          }
        }
        if (result.outBinds !== void 0) {
          for (const [key, value] of Object.entries(result.outBinds)) {
            const val = this._transformOutBind(value, options);
            result.outBinds[key] = val;
          }
        }
        if (result.implicitResults) {
          for (const [key, impl2] of Object.entries(result.implicitResults)) {
            const resultSet = new ResultSet();
            resultSet._setup(this, impl2);
            if (options.resultSet) {
              result.implicitResults[key] = resultSet;
            } else {
              result.implicitResults[key] = await resultSet._getAllRows();
            }
          }
        }
        return result;
      }
      //---------------------------------------------------------------------------
      // executeMany()
      //
      // Executes a SQL statement multiple times and returns the results.
      //---------------------------------------------------------------------------
      async executeMany(sql, bindsOrNumIters, a3) {
        let options = {};
        let binds = [];
        let numIters;
        errors.assertArgCount(arguments, 2, 3);
        errors.assertParamValue(typeof sql === "string", 1);
        if (arguments.length == 3) {
          options = this._verifyExecOpts(a3, true);
        }
        this._addDefaultsToExecOpts(options);
        if (typeof bindsOrNumIters === "number") {
          errors.assertParamValue(Number.isInteger(bindsOrNumIters) && bindsOrNumIters > 0, 2);
          numIters = bindsOrNumIters;
          if (options.bindDefs !== void 0) {
            binds = await this._processExecuteManyBinds([], options.bindDefs);
          }
        } else {
          errors.assertParamValue(Array.isArray(bindsOrNumIters) && bindsOrNumIters.length > 0, 2);
          numIters = bindsOrNumIters.length;
          binds = await this._processExecuteManyBinds(
            bindsOrNumIters,
            options.bindDefs
          );
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        const result = await this._impl.execute(
          sql,
          numIters,
          binds,
          options,
          true
        );
        if (result.warning) {
          result.warning = errors.transformErr(result.warning);
        }
        if (result.outBinds !== void 0) {
          for (let i = 0; i < result.outBinds.length; i++) {
            const outBind = result.outBinds[i];
            for (const [key, value] of Object.entries(outBind)) {
              outBind[key] = this._transformOutBind(value, options);
            }
          }
        }
        return result;
      }
      //---------------------------------------------------------------------------
      // externalName
      //
      // Property for identifying the external name to use in TPC logging.
      //---------------------------------------------------------------------------
      get externalName() {
        if (this._impl)
          return this._impl.getExternalName();
        return void 0;
      }
      set externalName(value) {
        errors.assertPropValue(typeof value === "string", "externalName");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setExternalName(value);
      }
      //---------------------------------------------------------------------------
      // dbDomain (READONLY)
      //
      // Property for identifying the dbDomain of the Oracle Database.
      //---------------------------------------------------------------------------
      get dbDomain() {
        return this._impl && this._impl.getDbDomain();
      }
      //---------------------------------------------------------------------------
      // dbName (READONLY)
      //
      // Property for identifying the dbName of the Oracle Database.
      //---------------------------------------------------------------------------
      get dbName() {
        return this._impl && this._impl.getDbName();
      }
      //---------------------------------------------------------------------------
      // hostName (READONLY)
      //
      // Property for identifying the hostName of the Oracle Database.
      //---------------------------------------------------------------------------
      get hostName() {
        return this._impl && this._impl.getHostName();
      }
      //---------------------------------------------------------------------------
      // port (READONLY)
      //
      // Property for identifying the port to which client is connected.
      //---------------------------------------------------------------------------
      get port() {
        return this._impl && this._impl.getPort();
      }
      //---------------------------------------------------------------------------
      // protocol (READONLY)
      //
      // Property for identifying the protocol used to connect to Oracle Database.
      //---------------------------------------------------------------------------
      get protocol() {
        return this._impl && this._impl.getProtocol();
      }
      //---------------------------------------------------------------------------
      // connectString (READONLY)
      //
      // User provided connectString to connect to Oracle Database.
      //---------------------------------------------------------------------------
      get connectString() {
        return this._impl && this._impl._connectString;
      }
      //---------------------------------------------------------------------------
      // user
      //
      // User property provided to connect to Oracle Database.
      //---------------------------------------------------------------------------
      get user() {
        if (this.currentSchema.length) {
          return this.currentSchema;
        }
        return this._impl && this._impl._user;
      }
      //---------------------------------------------------------------------------
      // connectTraceConfig
      //
      // Property for getting the connection related config.
      //---------------------------------------------------------------------------
      get connectTraceConfig() {
        return this._impl && this._impl._getConnectTraceConfig();
      }
      //---------------------------------------------------------------------------
      // getDbObjectClass()
      //
      // Returns a database object class given its name. The cache is searched
      // first, but if not found, the database is queried and the result is cached
      // using the type information (as well as the name for easier lookup later).
      //---------------------------------------------------------------------------
      async getDbObjectClass(name) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(typeof name === "string", 1);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        return await this._getDbObjectClassForName(name);
      }
      //---------------------------------------------------------------------------
      // getQueue()
      //
      // Returns a queue with the specified name.
      //---------------------------------------------------------------------------
      async getQueue(name, a2) {
        let options = {};
        errors.assertArgCount(arguments, 1, 2);
        errors.assertParamValue(typeof name === "string", 1);
        if (arguments.length == 2) {
          errors.assertParamValue(nodbUtil.isObject(a2), 2);
          options = { ...a2 };
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        const queue = new AqQueue();
        await queue.create(this, name, options);
        return queue;
      }
      //---------------------------------------------------------------------------
      // getSodaDatabase()
      //
      // Returns a SodaDatabase object (high-level SODA object associated with
      // the current connection).
      //---------------------------------------------------------------------------
      getSodaDatabase() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        const sodaDb = new SodaDatabase();
        sodaDb._impl = this._impl.getSodaDatabase();
        return sodaDb;
      }
      //---------------------------------------------------------------------------
      // getStatementInfo()
      //
      // Returns information about the statement.
      //---------------------------------------------------------------------------
      async getStatementInfo(sql) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(typeof sql === "string", 1);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        const info = await this._impl.getStatementInfo(sql);
        if (info.metaData) {
          for (let i = 0; i < info.metaData.length; i++) {
            const m = info.metaData[i];
            nodbUtil.addTypeProperties(m, "dbType");
            m.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(m.dbType);
          }
        }
        return info;
      }
      //---------------------------------------------------------------------------
      // instanceName
      //
      // Returns the Oracle Database instance name associated with the connection.
      // This is the equivalent of the SQL expression:
      // sys_context('userenv', 'instance_name')
      //---------------------------------------------------------------------------
      get instanceName() {
        if (this._impl)
          return this._impl.getInstanceName();
        return void 0;
      }
      //---------------------------------------------------------------------------
      // internalName
      //
      // Property for identifying the internal name to use in TPC logging.
      //---------------------------------------------------------------------------
      get internalName() {
        if (this._impl)
          return this._impl.getInternalName();
        return void 0;
      }
      set internalName(value) {
        errors.assertPropValue(typeof value === "string", "internalName");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setInternalName(value);
      }
      //---------------------------------------------------------------------------
      // ltxid
      //
      // Property for identifying the logical transaction ID to avoid duplicate
      // transactions. Used with Oracle Transaction Guard.
      //---------------------------------------------------------------------------
      get ltxid() {
        if (this._impl)
          return this._impl.getLTXID();
        return void 0;
      }
      //--------------------------------------------------------------------------
      // isHealthy()
      //
      // Returns the health status of the connection. If this function returns
      // false, the caller should close the connection.
      //---------------------------------------------------------------------------
      isHealthy() {
        return this._impl !== void 0 && !this._closing && this._impl.isHealthy();
      }
      isCompressionEnabled() {
        return this._impl && this._impl.isCompressionEnabled();
      }
      //---------------------------------------------------------------------------
      // maxIdentifierLength
      //
      // Returns the maximum length of identifiers supported by the database to
      // which this connection has been established.
      //---------------------------------------------------------------------------
      get maxIdentifierLength() {
        return this._impl && this._impl.getMaxIdentifierLength();
      }
      //---------------------------------------------------------------------------
      // maxOpenCursors
      //
      // Returns maximum number of cursors that can be opened in one session.
      //---------------------------------------------------------------------------
      get maxOpenCursors() {
        return this._impl && this._impl.getMaxOpenCursors();
      }
      //---------------------------------------------------------------------------
      // warning
      //
      // Returns warningInfo.
      //---------------------------------------------------------------------------
      get warning() {
        let warning = this._impl.getWarning();
        if (warning) {
          warning = errors.transformErr(warning);
        }
        return this._impl && warning;
      }
      //---------------------------------------------------------------------------
      // module
      //
      // Property for end-to-end tracing attribute.
      //---------------------------------------------------------------------------
      get module() {
        return null;
      }
      set module(value) {
        errors.assertPropValue(typeof value === "string", "module");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setModule(value);
      }
      //---------------------------------------------------------------------------
      // oracleServerVersion
      //
      // Returns an integer identifying the Oracle Server version.
      //---------------------------------------------------------------------------
      get oracleServerVersion() {
        if (this._impl)
          return this._impl.getOracleServerVersion();
        return void 0;
      }
      //---------------------------------------------------------------------------
      // oracleServerVersionString
      //
      // Returns a string identifying the Oracle Server version.
      //---------------------------------------------------------------------------
      get oracleServerVersionString() {
        if (this._impl)
          return this._impl.getOracleServerVersionString();
        return void 0;
      }
      //---------------------------------------------------------------------------
      // serviceName
      //
      // Returns the Oracle Database service name associated with the connection.
      //---------------------------------------------------------------------------
      get serviceName() {
        return this._impl && this._impl.getServiceName();
      }
      //---------------------------------------------------------------------------
      // transactionInProgress
      //
      // Returns a boolean value based on the presence of an active transaction
      // on the connection
      //---------------------------------------------------------------------------
      get transactionInProgress() {
        return this._impl && this._impl.getTransactionInProgress();
      }
      //---------------------------------------------------------------------------
      // ping()
      //
      // Sends a "ping" to the database to see if it is "alive".
      //---------------------------------------------------------------------------
      async ping() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.ping();
      }
      //--------------------------------------------------------------------------
      // queryStream()
      //
      // Similar to execute() except that it immediately returns a QueryStream
      // object.
      // ---------------------------------------------------------------------------
      queryStream(sql, binds, options) {
        errors.assertArgCount(arguments, 1, 3);
        errors.assertParamValue(typeof sql === "string", 1);
        if (arguments.length == 3) {
          errors.assertParamValue(nodbUtil.isObject(options), 3);
          options = { ...options };
        } else {
          options = {};
        }
        options.resultSet = true;
        const stream = new QueryStream();
        process2.nextTick(async () => {
          try {
            const result = await this.execute(sql, binds || [], options);
            if (!result.resultSet)
              errors.throwErr(errors.ERR_NOT_A_QUERY);
            stream._open(result.resultSet);
          } catch (err) {
            stream.destroy(err);
            return;
          }
        });
        return stream;
      }
      //---------------------------------------------------------------------------
      // resumeSessionlessTransaction()
      //
      // Resume an existing sessionlesss transaction using given transactionId
      //---------------------------------------------------------------------------
      async resumeSessionlessTransaction(transactionId, options = {}) {
        errors.assertArgCount(arguments, 1, 2);
        errors.assertParamValue(nodbUtil.isTransactionId(transactionId), 1);
        errors.assertParamValue(nodbUtil.isObject(options), 2);
        errors.assertParamPropUnsignedInt(options, 2, "timeout");
        errors.assertParamPropBool(options, 2, "deferRoundTrip");
        const normalizedTransactionId = nodbUtil.normalizeTransactionId(transactionId);
        const { timeout = 60, deferRoundTrip = false } = options;
        await this._impl.startSessionlessTransaction(
          normalizedTransactionId,
          timeout,
          constants.TPC_BEGIN_RESUME,
          deferRoundTrip
        );
        return normalizedTransactionId;
      }
      //---------------------------------------------------------------------------
      // rollback()
      //
      // Rolls back the current transaction.
      //---------------------------------------------------------------------------
      async rollback() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.rollback();
      }
      //---------------------------------------------------------------------------
      // shutdown()
      //   Shuts down the database instance.
      //---------------------------------------------------------------------------
      async shutdown(a1) {
        let mode = constants.SHUTDOWN_MODE_DEFAULT;
        errors.assertArgCount(arguments, 0, 1);
        if (a1 !== void 0) {
          errors.assertParamValue(typeof mode === "number", 1);
          mode = a1;
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.shutdown(mode);
      }
      //---------------------------------------------------------------------------
      // startup()
      //   Starts up the database instance.
      //---------------------------------------------------------------------------
      async startup(a1) {
        let options = {};
        errors.assertArgCount(arguments, 0, 1);
        if (arguments.length == 1) {
          errors.assertParamValue(typeof options === "object", 1);
          options = a1;
          errors.assertParamPropBool(options, 1, "force");
          errors.assertParamPropBool(options, 1, "restrict");
          errors.assertParamPropString(options, 1, "pfile");
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.startup(options);
      }
      //---------------------------------------------------------------------------
      // stmtCacheSize
      //
      // Property for statement cache size.
      //---------------------------------------------------------------------------
      get stmtCacheSize() {
        if (this._impl)
          return this._impl.getStmtCacheSize();
        return void 0;
      }
      set stmtCacheSize(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "stmtCacheSize"
        );
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setStmtCacheSize(value);
      }
      //---------------------------------------------------------------------------
      // subscribe()
      //
      // Creates a subscription which can be used to get notifications of database
      // changes or of AQ messages available to dequeue.
      //---------------------------------------------------------------------------
      async subscribe(name, options) {
        errors.assertArgCount(arguments, 2, 2);
        errors.assertParamValue(typeof name === "string", 1);
        errors.assertParamValue(nodbUtil.isObject(options), 2);
        options = { name, ...options };
        errors.assertParamPropUnsignedInt(options, 2, "namespace");
        if (options.namespace === void 0)
          options.namespace = constants.SUBSCR_NAMESPACE_DBCHANGE;
        errors.assertParamPropString(options, 2, "ipAddress");
        errors.assertParamPropUnsignedInt(options, 2, "port");
        errors.assertParamPropUnsignedInt(options, 2, "timeout");
        errors.assertParamPropUnsignedInt(options, 2, "operations");
        errors.assertParamPropUnsignedInt(options, 2, "qos");
        errors.assertParamPropUnsignedInt(options, 2, "groupingClass");
        errors.assertParamPropUnsignedInt(options, 2, "groupingValue");
        errors.assertParamPropUnsignedInt(options, 2, "groupingType");
        errors.assertParamPropBool(options, 2, "clientInitiated");
        errors.assertParamPropFunction(options, 2, "callback");
        errors.assert(options.callback, errors.ERR_MISSING_SUBSCR_CALLBACK);
        if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {
          errors.assertParamPropString(options, 2, "sql");
          errors.assert(
            options.sql && options.sql.length > 0,
            errors.ERR_MISSING_SUBSCR_SQL
          );
          if (options.binds !== void 0) {
            options.binds = await this._processExecuteBinds(options.binds);
          }
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        const inSubscr = _subscriptions.get(name);
        const outValue = await this._impl.subscribe(inSubscr, options);
        let subscription;
        if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {
          subscription = outValue.subscription;
          delete outValue.subscription;
        } else {
          subscription = outValue;
        }
        _subscriptions.set(name, subscription);
        return outValue;
      }
      //---------------------------------------------------------------------------
      // suspendSessionlessTransaction()
      //
      // Suspend any active sessionless transaction immediately
      //---------------------------------------------------------------------------
      async suspendSessionlessTransaction() {
        errors.assertArgCount(arguments, 0, 0);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.suspendSessionlessTransaction();
      }
      //---------------------------------------------------------------------------
      // tag
      //
      // Property for tag to associate with the connection.
      //---------------------------------------------------------------------------
      get tag() {
        if (this._impl)
          return this._impl.getTag();
        return void 0;
      }
      set tag(value) {
        errors.assertPropValue(typeof value === "string", "tag");
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        this._impl.setTag(value);
      }
      //---------------------------------------------------------------------------
      // tpcBegin()
      //
      // Starts a two-phase-commit transaction.
      //--------------------------------------------------------------------------
      async tpcBegin(xid, flag, timeout) {
        errors.assertArgCount(arguments, 1, 3);
        errors.assertParamValue(nodbUtil.isXid(xid), 1);
        const normalizedXid = nodbUtil.normalizeXid(xid);
        if (arguments.length < 3) {
          timeout = 60;
        } else {
          errors.assertParamValue(typeof timeout === "number", 3);
        }
        if (arguments.length < 2) {
          flag = constants.TPC_BEGIN_NEW;
        } else {
          errors.assertParamValue(typeof flag === "number", 2);
          const options = [
            constants.TPC_BEGIN_NEW,
            constants.TPC_BEGIN_JOIN,
            constants.TPC_BEGIN_RESUME,
            constants.TPC_BEGIN_PROMOTE
          ];
          if (options.indexOf(flag) < 0) {
            errors.throwErr(errors.ERR_INVALID_TPC_BEGIN_FLAGS);
          }
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.tpcBegin(normalizedXid, flag, timeout);
      }
      //---------------------------------------------------------------------------
      // tpcCommit()
      //
      // Commits a two-phase-commit transaction.
      //---------------------------------------------------------------------------
      async tpcCommit(xid, onePhase) {
        errors.assertArgCount(arguments, 0, 2);
        if (arguments.length < 2) {
          onePhase = false;
        } else {
          errors.assertParamValue(typeof onePhase === "boolean", 2);
        }
        let normalizedXid;
        if (arguments.length >= 1) {
          errors.assertParamValue(nodbUtil.isXid(xid), 1);
          normalizedXid = nodbUtil.normalizeXid(xid);
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.tpcCommit(normalizedXid, onePhase);
      }
      //---------------------------------------------------------------------------
      // tpcEnd()
      //
      // Ends a two-phase-commit transaction.
      //---------------------------------------------------------------------------
      async tpcEnd(xid, flag) {
        errors.assertArgCount(arguments, 0, 2);
        if (arguments.length < 2) {
          flag = constants.TPC_END_NORMAL;
        } else {
          errors.assertParamValue(typeof flag === "number", 2);
          const options = [constants.TPC_END_NORMAL, constants.TPC_END_SUSPEND];
          if (!options.includes(flag)) {
            errors.throwErr(errors.ERR_INVALID_TPC_END_FLAGS);
          }
        }
        let normalizedXid;
        if (arguments.length >= 1) {
          errors.assertParamValue(nodbUtil.isXid(xid), 1);
          normalizedXid = nodbUtil.normalizeXid(xid);
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.tpcEnd(normalizedXid, flag);
      }
      //---------------------------------------------------------------------------
      // tpcForget()
      //
      // Causes the server to forget a heuristically completed two-phase-commit
      // transaction.
      // ---------------------------------------------------------------------------
      async tpcForget(xid) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(nodbUtil.isXid(xid), 1);
        const normalizedXid = nodbUtil.normalizeXid(xid);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.tpcForget(normalizedXid);
      }
      //---------------------------------------------------------------------------
      // tpcPrepare()
      //
      // Prepares a two-phase-commit transaction for commit.
      //---------------------------------------------------------------------------
      async tpcPrepare(xid) {
        errors.assertArgCount(arguments, 0, 1);
        let normalizedXid;
        if (arguments.length >= 1) {
          errors.assertParamValue(nodbUtil.isXid(xid), 1);
          normalizedXid = nodbUtil.normalizeXid(xid);
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        return await this._impl.tpcPrepare(normalizedXid);
      }
      //---------------------------------------------------------------------------
      // tpcRecover()
      //
      // Returns a list of pending two-phase-commit transactions.
      //---------------------------------------------------------------------------
      async tpcRecover(asString) {
        errors.assertArgCount(arguments, 0, 1);
        if (arguments.length == 1) {
          errors.assertParamValue(typeof asString === "boolean", 1);
        } else {
          asString = true;
        }
        const sqlStr = `
      SELECT
          formatid as "formatId",
          UTL_RAW.CAST_TO_VARCHAR2(globalid) as "globalTransactionId",
          UTL_RAW.CAST_TO_VARCHAR2(branchid) as "branchQualifier"
      FROM DBA_PENDING_TRANSACTIONS`;
        const sqlBuf = `
      SELECT
          formatid as "formatId",
          globalid as "globalTransactionId",
          branchid as "branchQualifier"
      FROM DBA_PENDING_TRANSACTIONS`;
        const options = {
          outFormat: constants.OUT_FORMAT_OBJECT,
          resultSet: false
        };
        const result = await this.execute(asString ? sqlStr : sqlBuf, {}, options);
        return result.rows;
      }
      //---------------------------------------------------------------------------
      // tpcRollback()
      //
      // Rolls back the current changes in a two-phase-commit transaction.
      //---------------------------------------------------------------------------
      async tpcRollback(xid) {
        errors.assertArgCount(arguments, 0, 1);
        let normalizedXid;
        if (arguments.length == 1) {
          errors.assertParamValue(nodbUtil.isXid(xid), 1);
          normalizedXid = nodbUtil.normalizeXid(xid);
        }
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        await this._impl.tpcRollback(normalizedXid);
      }
      //---------------------------------------------------------------------------
      // unsubscribe()
      //
      // Destroy a subscription which was earlier created using subscribe().
      //---------------------------------------------------------------------------
      async unsubscribe(name) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(typeof name === "string", 1);
        errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);
        errors.assert(_subscriptions.has(name), errors.ERR_INVALID_SUBSCR);
        await this._impl.unsubscribe(_subscriptions.get(name));
        setTimeout(() => {
          _subscriptions.delete(name);
        }, 0);
      }
    };
    Connection.prototype.break = nodbUtil.callbackify(nodbUtil.wrapFn(Connection.prototype.breakExecution));
    Connection.prototype.tpcRecover = nodbUtil.callbackify(nodbUtil.wrapFn(Connection.prototype.tpcRecover));
    nodbUtil.wrapFns(
      Connection.prototype,
      "beginSessionlessTransaction",
      "changePassword",
      "close",
      "commit",
      "createLob",
      "execute",
      "executeMany",
      "getDbObjectClass",
      "getQueue",
      "getStatementInfo",
      "ping",
      "resumeSessionlessTransaction",
      "rollback",
      "shutdown",
      "startup",
      "subscribe",
      "suspendSessionlessTransaction",
      "tpcBegin",
      "tpcCommit",
      "tpcEnd",
      "tpcForget",
      "tpcPrepare",
      "tpcRollback",
      "unsubscribe"
    );
    Connection.prototype.release = Connection.prototype.close;
    module2.exports = Connection;
  }
});

// node_modules/oracledb/lib/poolStatistics.js
var require_poolStatistics = __commonJS({
  "node_modules/oracledb/lib/poolStatistics.js"(exports2, module2) {
    "use strict";
    var process2 = require("process");
    var settings = require_settings();
    var PoolStatistics = class {
      constructor(pool) {
        let averageTimeInQueue = 0;
        if (pool._totalRequestsEnqueued !== 0) {
          averageTimeInQueue = Math.round(pool._totalTimeInQueue / pool._totalRequestsEnqueued);
        }
        this.gatheredDate = Date.now();
        this.upTime = this.gatheredDate - pool._createdDate;
        this.upTimeSinceReset = this.gatheredDate - pool._timeOfReset;
        this.connectionRequests = pool._totalConnectionRequests;
        this.requestsEnqueued = pool._totalRequestsEnqueued;
        this.requestsDequeued = pool._totalRequestsDequeued;
        this.failedRequests = pool._totalFailedRequests;
        this.rejectedRequests = pool._totalRequestsRejected;
        this.requestTimeouts = pool._totalRequestTimeouts;
        this.maximumQueueLength = pool._maximumQueueLength;
        this.currentQueueLength = pool._pendingRequestQueue.size;
        this.timeInQueue = pool._totalTimeInQueue;
        this.minimumTimeInQueue = pool._minTimeInQueue;
        this.maximumTimeInQueue = pool._maxTimeInQueue;
        this.averageTimeInQueue = averageTimeInQueue;
        this.connectionsInUse = pool.connectionsInUse;
        this.connectionsOpen = pool.connectionsOpen;
        this.connectString = pool.connectString;
        this.edition = pool.edition;
        this.events = pool.events;
        this.externalAuth = pool.externalAuth;
        this.homogeneous = pool.homogeneous;
        this.poolAlias = pool.poolAlias;
        this.poolIncrement = pool.poolIncrement;
        this.poolMax = pool.poolMax;
        this.poolMaxPerShard = pool.poolMaxPerShard;
        this.poolMin = pool.poolMin;
        this.poolPingInterval = pool.poolPingInterval;
        this.poolPingTimeout = pool.poolPingTimeout;
        this.poolTimeout = pool.poolTimeout;
        this.maxLifetimeSession = pool.maxLifetimeSession;
        this.queueMax = pool.queueMax;
        this.queueTimeout = pool.queueTimeout;
        this.sodaMetaDataCache = pool.sodaMetaDataCache;
        this.stmtCacheSize = pool.stmtCacheSize;
        this.user = pool.user;
        this.threadPoolSize = process2.env.UV_THREADPOOL_SIZE;
        this.thin = settings.thin;
      }
      //---------------------------------------------------------------------------
      // logStatistics()
      //
      // To print the statistics metrics of the pool
      //---------------------------------------------------------------------------
      logStatistics() {
        console.log("\nDriver:");
        console.log("...thin mode:", this.thin);
        console.log("Pool statistics:");
        console.log("...gathered at:", new Date(this.gatheredDate).toISOString());
        console.log("...up time (milliseconds):", this.upTime);
        console.log(
          "...up time from last reset (milliseconds)",
          this.upTimeSinceReset
        );
        console.log("...connection requests:", this.connectionRequests);
        console.log("...requests enqueued:", this.requestsEnqueued);
        console.log("...requests dequeued:", this.requestsDequeued);
        console.log("...requests failed:", this.failedRequests);
        console.log("...requests exceeding queueMax:", this.rejectedRequests);
        console.log("...requests exceeding queueTimeout:", this.requestTimeouts);
        console.log("...current queue length:", this.currentQueueLength);
        console.log("...maximum queue length:", this.maximumQueueLength);
        console.log("...sum of time in queue (milliseconds):", this.timeInQueue);
        console.log(
          "...minimum time in queue (milliseconds):",
          this.minimumTimeInQueue
        );
        console.log(
          "...maximum time in queue (milliseconds):",
          this.maximumTimeInQueue
        );
        console.log(
          "...average time in queue (milliseconds):",
          this.averageTimeInQueue
        );
        console.log("...pool connections in use:", this.connectionsInUse);
        console.log("...pool connections open:", this.connectionsOpen);
        console.log("Pool attributes:");
        console.log("...connectString:", this.connectString);
        console.log("...edition:", this.edition);
        console.log("...events:", this.events);
        console.log("...externalAuth:", this.externalAuth);
        console.log("...homogeneous:", this.homogeneous);
        console.log("...poolAlias:", this.poolAlias);
        console.log("...poolIncrement:", this.poolIncrement);
        console.log("...poolMax:", this.poolMax);
        console.log("...poolMaxPerShard:", this.poolMaxPerShard);
        console.log("...poolMin:", this.poolMin);
        console.log("...poolPingInterval (seconds):", this.poolPingInterval);
        console.log("...poolPingTimeout (milliseconds):", this.poolPingTimeout);
        console.log("...poolTimeout (seconds):", this.poolTimeout);
        console.log("...maxLifetimeSession (seconds):", this.maxLifetimeSession);
        console.log("...queueMax:", this.queueMax);
        console.log("...queueTimeout (milliseconds):", this.queueTimeout);
        console.log("...sessionCallback:", this.sessionCallback);
        console.log("...sodaMetaDataCache:", this.sodaMetaDataCache);
        console.log("...stmtCacheSize:", this.stmtCacheSize);
        console.log("...user:", this.user);
        console.log("Related environment variables:");
        console.log("...UV_THREADPOOL_SIZE:", this.threadPoolSize);
      }
    };
    module2.exports = PoolStatistics;
  }
});

// node_modules/oracledb/lib/pool.js
var require_pool2 = __commonJS({
  "node_modules/oracledb/lib/pool.js"(exports2, module2) {
    "use strict";
    var Connection = require_connection2();
    var EventEmitter = require("events");
    var constants = require_constants();
    var errors = require_errors();
    var settings = require_settings();
    var nodbUtil = require_util();
    var impl = require_impl();
    var PoolStatistics = require_poolStatistics();
    var Pool = class extends EventEmitter {
      constructor() {
        super();
        this._impl = new impl.PoolImpl();
        this._queueMax = 0;
        this._queueTimeout = 0;
        this._enableStatistics = false;
        this._timeOfReset = this._createdDate = Date.now();
        this._sessionCallback = void 0;
        this._pendingRequestQueue = /* @__PURE__ */ new Set();
        this._connectionClass = settings.connectionClass;
        this._bgRequestWaiter = null;
        this._bgRequestId = 0;
        this._processing = 0;
        this._ensureNoPendingRequests = null;
      }
      //---------------------------------------------------------------------------
      // _checkPoolOpen()
      //
      // Check if the pool is open (not draining/reconfiguring/closed) and throw an
      // appropriate exception if not.
      //---------------------------------------------------------------------------
      _checkPoolOpen(ignoreReconfiguring) {
        if (this.status === constants.POOL_STATUS_DRAINING) {
          errors.throwErr(errors.ERR_POOL_CLOSING);
        } else if (this.status === constants.POOL_STATUS_CLOSED) {
          errors.throwErr(errors.ERR_POOL_CLOSED);
        } else if (!ignoreReconfiguring) {
          if (this.status === constants.POOL_STATUS_RECONFIGURING) {
            errors.throwErr(errors.ERR_POOL_RECONFIGURING);
          }
        }
      }
      // _enableStats (DEPRECATED)
      //
      // Property for whether statistics are enabled on the pool.
      //---------------------------------------------------------------------------
      get _enableStats() {
        return this._enableStatistics;
      }
      //---------------------------------------------------------------------------
      // _resetStatistics()
      //  To initialize the counters/timers
      //---------------------------------------------------------------------------
      _resetStatistics() {
        this._timeOfReset = Date.now();
        this._totalConnectionRequests = 0;
        this._totalRequestsEnqueued = 0;
        this._totalRequestsDequeued = 0;
        this._totalFailedRequests = 0;
        this._totalRequestsRejected = 0;
        this._totalRequestTimeouts = 0;
        this._maximumQueueLength = this._pendingRequestQueue.size;
        this._totalTimeInQueue = 0;
        this._minTimeInQueue = 0;
        this._maxTimeInQueue = 0;
      }
      //---------------------------------------------------------------------------
      // _setup()
      //
      // Sets up the pool instance with additional attributes used for logging
      // statistics and managing the connection queue.
      //---------------------------------------------------------------------------
      _setup(options, poolAlias) {
        this._queueTimeout = options.queueTimeout;
        this._queueMax = options.queueMax;
        this._enableStatistics = options.enableStatistics;
        this._edition = options.edition;
        this._eventsFlag = options.events;
        this._externalAuth = options.externalAuth;
        this._homogeneous = options.homogeneous;
        this._user = options.user;
        this._connectString = options.connectString;
        this._status = constants.POOL_STATUS_OPEN;
        this._connectionsOut = 0;
        this._poolAlias = poolAlias;
        this._bgRequestHandler();
        this._resetStatistics();
      }
      //---------------------------------------------------------------------------
      // _updateWaitStatistics()
      //
      // Update pool wait statistics after a connect request has spent some time in
      // the queue.
      //---------------------------------------------------------------------------
      _updateWaitStatistics(request) {
        const waitTime = Date.now() - request.enqueuedTime;
        this._totalTimeInQueue += waitTime;
        if (this._minTimeInQueue === 0) {
          this._minTimeInQueue = waitTime;
        } else {
          this._minTimeInQueue = Math.min(this._minTimeInQueue, waitTime);
        }
        this._maxTimeInQueue = Math.max(this._maxTimeInQueue, waitTime);
      }
      //---------------------------------------------------------------------------
      // _verifyGetConnectionOptions()
      //
      // Verify the getConnection() options are acceptable. Performs any
      // transformations that are needed before returning the options to the
      // caller.
      //---------------------------------------------------------------------------
      _verifyGetConnectionOptions(options) {
        const outOptions = {};
        if (options.user !== void 0) {
          errors.assertParamPropValue(typeof options.user === "string", 1, "user");
          outOptions.user = options.user;
        }
        if (options.username !== void 0) {
          errors.assert(outOptions.user === void 0, errors.ERR_DBL_USER);
          errors.assertParamPropValue(
            typeof options.username === "string",
            1,
            "username"
          );
          outOptions.user = options.username;
        }
        if (this.externalAuth && outOptions.user && (outOptions.user[0] !== "[" || outOptions.user.slice(-1) !== "]")) {
          errors.throwErr(errors.ERR_WRONG_USER_FORMAT_EXTAUTH_PROXY);
        }
        if (options.password !== void 0) {
          errors.assertParamPropValue(
            typeof options.password === "string",
            1,
            "password"
          );
          if (this.externalAuth) {
            errors.throwErr(errors.ERR_WRONG_CRED_FOR_EXTAUTH);
          }
          outOptions.password = options.password;
        }
        if (options.tag !== void 0) {
          errors.assertParamPropValue(typeof options.tag === "string", 1, "tag");
          outOptions.tag = options.tag;
        }
        if (options.matchAnyTag !== void 0) {
          errors.assertParamPropValue(
            typeof options.matchAnyTag === "boolean",
            1,
            "matchAnyTag"
          );
          outOptions.matchAnyTag = options.matchAnyTag;
        }
        if (options.shardingKey !== void 0) {
          const value = options.shardingKey;
          errors.assertParamPropValue(
            nodbUtil.isShardingKey(value),
            1,
            "shardingKey"
          );
          outOptions.shardingKey = options.shardingKey;
        }
        if (options.superShardingKey !== void 0) {
          const value = options.superShardingKey;
          errors.assertParamPropValue(
            nodbUtil.isShardingKey(value),
            1,
            "superShardingKey"
          );
          outOptions.superShardingKey = options.superShardingKey;
        }
        if (options.privilege !== void 0) {
          errors.assertParamPropValue(
            nodbUtil.isPrivilege(options.privilege),
            1,
            "privilege"
          );
          outOptions.privilege = options.privilege;
        }
        return outOptions;
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Close the pool, optionally allowing for a period of time to pass for
      // connections to "drain" from the pool.
      //---------------------------------------------------------------------------
      async close(a1) {
        let drainTime = 0;
        let forceClose = false;
        errors.assertArgCount(arguments, 0, 1);
        if (arguments.length == 1) {
          errors.assertParamValue(typeof a1 === "number", 1);
          if (a1 < 0 || isNaN(a1) || a1 > 2 ** 31) {
            errors.throwErr(errors.ERR_INVALID_PARAMETER_VALUE, 1);
          }
          forceClose = true;
          if (this._connectionsOut > 0) {
            drainTime = a1 * 1e3;
          }
        }
        this._checkPoolOpen(false);
        if (forceClose)
          this._status = constants.POOL_STATUS_DRAINING;
        if (drainTime > 0) {
          await new Promise((resolve3) => {
            const timeout = setTimeout(() => {
              this.removeAllListeners("_allCheckedIn");
              resolve3();
            }, drainTime);
            this.once("_allCheckedIn", () => {
              clearTimeout(timeout);
              resolve3();
            });
          });
        }
        if (!forceClose && this._connectionsOut > 0) {
          errors.throwErr(errors.ERR_POOL_HAS_BUSY_CONNECTIONS);
        }
        if (this._processing != 0)
          await new Promise((resolve3) => this._ensureNoPendingRequests = resolve3);
        await this._impl.close();
        this._status = constants.POOL_STATUS_CLOSED;
        if (this._bgRequestWaiter)
          this._bgRequestWaiter();
        this.emit("_afterPoolClose");
      }
      //---------------------------------------------------------------------------
      // connectionsInUse
      //
      // Property for the number of connections in use by the pool.
      //---------------------------------------------------------------------------
      get connectionsInUse() {
        return this._impl.getConnectionsInUse();
      }
      //---------------------------------------------------------------------------
      // connectionsOpen
      //
      // Property for the number of connections opened by the pool.
      //---------------------------------------------------------------------------
      get connectionsOpen() {
        return this._impl.getConnectionsOpen();
      }
      //---------------------------------------------------------------------------
      // connectString
      //
      // Property for the connect string used to create the pool.
      //---------------------------------------------------------------------------
      get connectString() {
        return this._connectString;
      }
      //---------------------------------------------------------------------------
      // thin()
      //
      // return true, if driver mode is thin while creating pool
      // return false, if driver mode is thick while creating pool
      //---------------------------------------------------------------------------
      get thin() {
        return settings.thin;
      }
      //---------------------------------------------------------------------------
      // edition
      //
      // Property for the edition used to create the pool.
      //---------------------------------------------------------------------------
      get edition() {
        return this._edition;
      }
      //---------------------------------------------------------------------------
      // enableStatistics
      //
      // Property for whether statistics are enabled on the pool.
      //---------------------------------------------------------------------------
      get enableStatistics() {
        return this._enableStatistics;
      }
      //---------------------------------------------------------------------------
      // events
      //
      // Property for the events flag value used to create the pool.
      //---------------------------------------------------------------------------
      get events() {
        return this._eventsFlag;
      }
      //---------------------------------------------------------------------------
      // externalAuth
      //
      // Property for the externalAuth flag value used to create the pool.
      //---------------------------------------------------------------------------
      get externalAuth() {
        return this._externalAuth;
      }
      //---------------------------------------------------------------------------
      // getConnection()
      //
      // Gets a connection from the pool and returns it to the caller. If there are
      // fewer connections out than the poolMax setting, then the request will
      // return immediately; otherwise, the request will be queued for up to
      // queueTimeout milliseconds.
      //---------------------------------------------------------------------------
      async getConnection(a1) {
        let options = {};
        errors.assertArgCount(arguments, 0, 1);
        if (arguments.length == 1) {
          errors.assertParamValue(nodbUtil.isObject(a1), 1);
          options = this._verifyGetConnectionOptions(a1);
        }
        options.connectionClass = this._connectionClass;
        this._checkPoolOpen(true);
        if (this._enableStatistics) {
          this._totalConnectionRequests += 1;
        }
        if (this._bgRequestId == Number.MAX_SAFE_INTEGER)
          this._bgRequestId = 0;
        const request = {
          id: this._bgRequestId++,
          options,
          conn: null,
          isWaiting: true,
          error: null,
          timeoutHandle: null,
          enqueuedTime: Date.now(),
          wasQueued: false
        };
        const promiseToAcquire = new Promise((resolve3, reject) => {
          request.resolve = resolve3;
          request.reject = reject;
          if (this._connectionsOut < this.poolMax) {
            this._processRequest(request);
          } else {
            if (this._pendingRequestQueue.size == this._queueMax) {
              if (this._enableStatistics)
                this._totalRequestsRejected += 1;
              return reject(errors.getErr(
                errors.ERR_QUEUE_MAX_EXCEEDED,
                this._queueMax
              ));
            }
            request.wasQueued = true;
            this._pendingRequestQueue.add(request);
            if (this._enableStatistics) {
              this._totalRequestsEnqueued += 1;
              this._maximumQueueLength = Math.max(
                this._maximumQueueLength,
                this._pendingRequestQueue.size
              );
            }
          }
        });
        const promiseToTimeout = new Promise((_, reject) => {
          if (this._queueTimeout > 0)
            request.timeoutHandle = setTimeout(() => {
              request.isWaiting = false;
              this._pendingRequestQueue.delete(request);
              if (this.enableStatistics)
                this._totalRequestTimeouts += 1;
              reject(errors.getErr(
                errors.ERR_CONN_REQUEST_TIMEOUT,
                this._queueTimeout
              ));
            }, this._queueTimeout);
        });
        try {
          await Promise.race([promiseToAcquire, promiseToTimeout]);
        } catch (err) {
          request.error = err;
        }
        clearTimeout(request.timeoutHandle);
        if (this._enableStatistics && request.wasQueued)
          this._updateWaitStatistics(request);
        if (request.error)
          throw request.error;
        return request.conn;
      }
      //---------------------------------------------------------------------------
      // _bgRequestHandler()
      //
      // This method handles the queuing of all pending requests and processes them
      // depending on the open connections and if the request is still waiting.
      //---------------------------------------------------------------------------
      async _bgRequestHandler() {
        while (this.status != constants.POOL_STATUS_DRAINING || this.status != constants.POOL_STATUS_CLOSED) {
          const request = this._pendingRequestQueue.values().next().value;
          if (request && this._connectionsOut < this.poolMax) {
            this._processRequest(request);
          } else {
            await new Promise((resolve3) => {
              this._bgRequestWaiter = resolve3;
            });
            this._bgRequestWaiter = null;
          }
        }
        for (const request of this._pendingRequestQueue)
          request.reject(errors.throwErr(errors.ERR_POOL_CLOSED));
      }
      //---------------------------------------------------------------------------
      // _processRequest()
      //
      // Method called to process a connection request and return the required
      // 'connection'/'error returned by DB' if the client is still waiting.
      //---------------------------------------------------------------------------
      async _processRequest(request) {
        const conn = new Connection();
        try {
          this._processing += 1;
          this._connectionsOut += 1;
          this._pendingRequestQueue.delete(request);
          conn._impl = await this._impl.getConnection(request.options);
          conn._pool = this;
          await this._tagFixup(conn, request.options.tag);
          if (request.isWaiting)
            request.conn = conn;
          else
            await conn.close({});
          request.resolve();
        } catch (err) {
          if (request.isWaiting) {
            if (this._enableStatistics)
              this._totalFailedRequests += 1;
            request.reject(err);
          }
          this._release(conn._impl, request.options);
        } finally {
          this._processing -= 1;
          if (this.status == constants.POOL_STATUS_DRAINING && this._processing == 0 && this._ensureNoPendingRequests)
            this._ensureNoPendingRequests();
        }
      }
      //---------------------------------------------------------------------------
      // _tagFixup()
      //
      // Method to check if requested tag matches the connection's tag.
      // If it does not match the callback function is invoked.
      //---------------------------------------------------------------------------
      async _tagFixup(conn, tag) {
        const requestedTag = tag || "";
        if (typeof this.sessionCallback === "function" && (conn._impl._newSession || conn.tag != requestedTag)) {
          try {
            await new Promise((resolve3, reject) => {
              this.sessionCallback(conn, requestedTag, function(err) {
                if (err) {
                  reject(err);
                } else {
                  resolve3();
                }
              });
            });
          } catch (err) {
            await conn.close({ drop: true });
            throw err;
          }
        }
      }
      //---------------------------------------------------------------------------
      // _release()
      //
      // Method called by 'close() in connection.js after a release'/'error in
      // _processRequest' to decrease connectionsOut & wake up _bgRequestWaiter
      //---------------------------------------------------------------------------
      async _release(impl2, options) {
        this._connectionsOut -= 1;
        try {
          if (impl2)
            await impl2.close(options);
        } finally {
          if (this._connectionsOut == 0)
            this.emit("_allCheckedIn");
          setImmediate(() => {
            if (this._pendingRequestQueue.size > 0 && this._bgRequestWaiter)
              this._bgRequestWaiter();
          });
        }
      }
      //---------------------------------------------------------------------------
      // getStatistics()
      //
      // Method to obtain a JSON object with all statistical metrics and pool
      // properties
      //---------------------------------------------------------------------------
      getStatistics() {
        this._checkPoolOpen(false);
        if (this._enableStatistics !== true) {
          return null;
        }
        return new PoolStatistics(this);
      }
      //---------------------------------------------------------------------------
      // homogeneous
      //
      // Property for the homogeneous flag value used to create the pool.
      //---------------------------------------------------------------------------
      get homogeneous() {
        return this._homogeneous;
      }
      //---------------------------------------------------------------------------
      // logStatistics()
      //
      // Method to print statistical related information and pool related
      // information when enableStatistics is set to true.
      //
      // NOTE: This function replaces the DEPRECATED _logStats() function.
      //---------------------------------------------------------------------------
      logStatistics() {
        const stats = this.getStatistics();
        if (stats === null) {
          errors.throwErr(errors.ERR_POOL_STATISTICS_DISABLED);
        }
        stats.logStatistics();
      }
      //---------------------------------------------------------------------------
      // poolAlias
      //
      // Property for the alias assigned to the pool.
      // ---------------------------------------------------------------------------
      get poolAlias() {
        return this._poolAlias;
      }
      //---------------------------------------------------------------------------
      // poolIncrement
      //
      // Property for the number of connections to create each time the pool needs
      // to grow.
      // ---------------------------------------------------------------------------
      get poolIncrement() {
        return this._impl.getPoolIncrement();
      }
      //---------------------------------------------------------------------------
      // poolMax
      //
      // Property for the maximum number of connections allowed in the pool.
      //---------------------------------------------------------------------------
      get poolMax() {
        return this._impl.getPoolMax();
      }
      //---------------------------------------------------------------------------
      // poolMaxPerShard
      //
      // Property for the maximum number of connections allowed in the pool for
      // each shard.
      //---------------------------------------------------------------------------
      get poolMaxPerShard() {
        return this._impl.getPoolMaxPerShard();
      }
      //---------------------------------------------------------------------------
      // poolMin
      //
      // Property for the minimum number of connections allowed in the pool.
      //---------------------------------------------------------------------------
      get poolMin() {
        return this._impl.getPoolMin();
      }
      //---------------------------------------------------------------------------
      // poolPingInterval
      //
      // Property for the ping interval to use for the pool.
      //---------------------------------------------------------------------------
      get poolPingInterval() {
        return this._impl.getPoolPingInterval();
      }
      //---------------------------------------------------------------------------
      // poolPingTimeout
      //
      // Property for the ping timeout associated with the pool.
      //---------------------------------------------------------------------------
      get poolPingTimeout() {
        return this._impl.getPoolPingTimeout();
      }
      //---------------------------------------------------------------------------
      // poolTimeout
      //
      // Property for the timeout associated with the pool.
      //---------------------------------------------------------------------------
      get poolTimeout() {
        return this._impl.getPoolTimeout();
      }
      //---------------------------------------------------------------------------
      // maxLifetimeSession
      //
      // Property for the max allowed lifetime of a session in the pool.
      //---------------------------------------------------------------------------
      get maxLifetimeSession() {
        return this._impl.getMaxLifetimeSession();
      }
      //---------------------------------------------------------------------------
      // queueMax
      //
      // Property for the maximum number of pending pool connections that can be
      // queued.
      //---------------------------------------------------------------------------
      get queueMax() {
        return this._queueMax;
      }
      //---------------------------------------------------------------------------
      // queueTimeout
      //
      // Property for the milliseconds a connection request can spend in the queue
      // before an exception is thrown.
      //---------------------------------------------------------------------------
      get queueTimeout() {
        return this._queueTimeout;
      }
      //---------------------------------------------------------------------------
      // reconfigure()
      //
      // Reconfigure the pool, change the value for given pool-properties.
      //---------------------------------------------------------------------------
      async reconfigure(options) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(nodbUtil.isObject(options));
        errors.assertParamPropUnsignedInt(options, 1, "queueMax");
        errors.assertParamPropUnsignedInt(options, 1, "queueTimeout");
        errors.assertParamPropBool(options, 1, "enableStatistics");
        errors.assertParamPropBool(options, 1, "resetStatistics");
        errors.assertParamPropUnsignedInt(options, 1, "poolMin");
        errors.assertParamPropUnsignedIntNonZero(options, 1, "poolMax");
        errors.assertParamPropUnsignedInt(options, 1, "poolMaxPerShard");
        errors.assertParamPropUnsignedInt(options, 1, "poolIncrement");
        errors.assertParamPropInt(options, 1, "poolPingInterval");
        errors.assertParamPropUnsignedInt(options, 1, "poolTimeout");
        errors.assertParamPropUnsignedInt(options, 1, "maxLifetimeSession");
        errors.assertParamPropUnsignedInt(options, 1, "stmtCacheSize");
        errors.assertParamPropBool(options, 1, "sodaMetaDataCache");
        if (options.poolMin > options.poolMax) {
          errors.throwErr(
            errors.ERR_INVALID_NUMBER_OF_CONNECTIONS,
            options.poolMax,
            options.poolMin
          );
        }
        this._checkPoolOpen(false);
        this._status = constants.POOL_STATUS_RECONFIGURING;
        try {
          await this._impl.reconfigure(options);
          if (options.resetStatistics == true || options.enableStatistics == true && this._enableStatistics == false) {
            this._resetStatistics();
          }
          if (options.queueMax !== void 0) {
            this._queueMax = options.queueMax;
          }
          if (options.queueTimeout !== void 0) {
            this._queueTimeout = options.queueTimeout;
          }
          if (options.enableStatistics !== void 0) {
            this._enableStatistics = options.enableStatistics;
          }
        } finally {
          this._status = constants.POOL_STATUS_OPEN;
        }
      }
      //---------------------------------------------------------------------------
      // sessionCallback
      //
      // Property for the session callback associated with the pool.
      //---------------------------------------------------------------------------
      get sessionCallback() {
        return this._sessionCallback;
      }
      //---------------------------------------------------------------------------
      // setAccessToken()
      //
      // Set parameters for token based authentication.
      //---------------------------------------------------------------------------
      async setAccessToken(options) {
        errors.assertArgCount(arguments, 1, 1);
        errors.assertParamValue(nodbUtil.isObject(options), 1);
        errors.assertParamPropString(options, 1, "token");
        errors.assertParamPropString(options, 1, "privateKey");
        await this._impl.setAccessToken(options);
      }
      //---------------------------------------------------------------------------
      // sodaMetaDataCache
      //
      // Property for whether the SODA metadata cache is enabled or not.
      //---------------------------------------------------------------------------
      get sodaMetaDataCache() {
        return this._impl.getSodaMetaDataCache();
      }
      //---------------------------------------------------------------------------
      // status
      //
      // Property for the pool's status.
      //---------------------------------------------------------------------------
      get status() {
        return this._status;
      }
      //---------------------------------------------------------------------------
      // stmtCacheSize
      //
      // Property for the size of the statement cache to use when creating
      // connections in the pool.
      //---------------------------------------------------------------------------
      get stmtCacheSize() {
        return this._impl.getStmtCacheSize();
      }
      //---------------------------------------------------------------------------
      // user
      //
      // Property for the user used to create the pool.
      //---------------------------------------------------------------------------
      get user() {
        return this._user;
      }
      //---------------------------------------------------------------------------
      // connectTraceConfig
      //
      // Property for getting the connection related config.
      //---------------------------------------------------------------------------
      get connectTraceConfig() {
        return this._impl && this._impl._getConnectTraceConfig();
      }
    };
    nodbUtil.wrapFns(
      Pool.prototype,
      false,
      "close",
      "getConnection",
      "reconfigure",
      "setAccessToken"
    );
    Pool.prototype.terminate = Pool.prototype.close;
    Pool.prototype._logStats = Pool.prototype.logStatistics;
    module2.exports = Pool;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/base.js
var require_base2 = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/base.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants3();
    var errors = require_errors();
    var RECOVERABLE_ERRORS = /* @__PURE__ */ new Set([
      28,
      // session has been terminated
      31,
      // session marked for kill
      376,
      // file %s cannot be read at this time
      603,
      // ORACLE server session terminated
      1012,
      // not logged on
      1033,
      // ORACLE initialization or shutdown in progress
      1034,
      // the Oracle instance is not available for use
      1089,
      // immediate shutdown or close in progress
      1090,
      // shutdown in progress
      1092,
      // ORACLE instance terminated
      1115,
      // IO error reading block from file %s (block # %s)
      2396,
      // exceeded maximum idle time
      3113,
      // end-of-file on communication channel
      3114,
      // not connected to ORACLE
      3135,
      // connection lost contact
      12153,
      // TNS:not connected
      12514,
      // Service %s is not registered with the listener
      12537,
      // TNS:connection closed
      12547,
      // TNS:lost contact
      12570,
      // TNS:packet reader failure
      12571,
      // TNS:packet writer failure
      12583,
      // TNS:no reader
      12757,
      // instance does not currently know of requested service
      16456
      // missing or invalid value
    ]);
    var Message = class {
      constructor(connection) {
        this.errorInfo = {};
        this.connection = connection;
        this.messageType = constants.TNS_MSG_TYPE_FUNCTION;
        this.functionCode = 0;
        this.callStatus = 0;
        this.flushOutBinds = false;
        this.endOfResponse = false;
        this.endToEndSeqNum = 0;
        this.errorOccurred = false;
        this.warning = void 0;
      }
      preProcess() {
      }
      async postProcess() {
      }
      writeFunctionHeader(buf) {
        this.writePiggybacks(buf);
        buf.writeUInt8(this.messageType);
        buf.writeUInt8(this.functionCode);
        buf.writeSeqNum();
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_23_1_EXT_1) {
          buf.writeUB8(0);
        }
      }
      processErrorInfo(buf) {
        this.callStatus = buf.readUB4();
        buf.skipUB2();
        buf.skipUB4();
        buf.skipUB2();
        buf.skipUB2();
        buf.skipUB2();
        this.errorInfo.cursorId = buf.readUB2();
        const errorPos = buf.readSB2();
        buf.skipUB1();
        buf.skipUB1();
        buf.skipUB1();
        buf.skipUB1();
        buf.skipUB1();
        const warnFlag = buf.readUInt8();
        if (warnFlag & constants.TNS_WARN_COMPILATION_CREATE) {
          this.warning = errors.getErr(errors.WRN_COMPILATION_CREATE);
        }
        this.errorInfo.rowID = buf.readRowID();
        buf.skipUB4();
        buf.skipUB1();
        buf.skipUB1();
        buf.skipUB2();
        buf.skipUB4();
        const numBytes = buf.readUB4();
        if (numBytes > 0) {
          buf.skipBytesChunked();
        }
        const numErrors = buf.readUB2();
        if (numErrors > 0) {
          this.errorInfo.batchErrors = [];
          const firstByte = buf.readUInt8();
          for (let i = 0; i < numErrors; i++) {
            if (firstByte === constants.TNS_LONG_LENGTH_INDICATOR) {
              buf.skipUB4();
            }
            const errorCode = buf.readUB2();
            this.errorInfo.batchErrors.push(new Error(errorCode));
          }
          if (firstByte === constants.TNS_LONG_LENGTH_INDICATOR) {
            buf.skipBytes(1);
          }
        }
        const numOffsets = buf.readUB4();
        if (numOffsets > 0) {
          if (numOffsets > 65535) {
            errors.throwErr(errors.ERR_TOO_MANY_BATCH_ERRORS);
          }
          const firstByte = buf.readUInt8();
          let offset;
          for (let i = 0; i < numOffsets; i++) {
            if (firstByte === constants.TNS_LONG_LENGTH_INDICATOR) {
              buf.skipUB4();
            }
            offset = buf.readUB4();
            if (i < numErrors) {
              this.errorInfo.batchErrors[i].offset = offset;
            }
          }
          if (firstByte === constants.TNS_LONG_LENGTH_INDICATOR) {
            buf.skipBytes(1);
          }
        }
        const errMsgArr = buf.readUB2();
        if (errMsgArr > 0) {
          buf.skipBytes(1);
          for (let i = 0; i < errMsgArr; i++) {
            buf.skipUB2();
            this.errorInfo.batchErrors[i].message = buf.readStr(constants.CSFRM_IMPLICIT);
            buf.skipBytes(2);
          }
        }
        this.errorInfo.num = buf.readUB4();
        this.errorInfo.rowCount = buf.readUB8();
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_20_1) {
          buf.skipUB4();
          buf.skipUB4();
        }
        if (this.errorInfo.num !== 0) {
          this.errorOccurred = true;
          if (errorPos >= 0) {
            this.errorInfo.pos = errorPos;
          }
          this.errorInfo.message = buf.readStr(constants.CSFRM_IMPLICIT);
          this.errorInfo.message = this.errorInfo.message.trim();
        }
        this.errorInfo.isRecoverable = RECOVERABLE_ERRORS.has(this.errorInfo.num);
        this.endOfResponse = !this.connection.nscon.endOfRequestSupport;
      }
      processReturnParameter() {
      }
      processWarningInfo(buf) {
        const errNum = buf.readUB2();
        const numBytes = buf.readUB2();
        buf.skipUB2();
        if (errNum != 0 && numBytes > 0) {
          const message = buf.readStr(constants.CSFRM_IMPLICIT).trim();
          this.warning = new Error(message);
          this.warning.errorNum = errNum;
        }
      }
      decode(buf) {
        this.process(buf);
      }
      process(buf) {
        this.endOfResponse = false;
        this.flushOutBinds = false;
        do {
          this.savePoint(buf);
          const messageType = buf.readUInt8();
          this.processMessage(buf, messageType);
        } while (!this.endOfResponse);
      }
      savePoint(buf) {
        buf.savePoint();
      }
      processMessage(buf, messageType) {
        if (messageType === constants.TNS_MSG_TYPE_ERROR) {
          this.processErrorInfo(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_WARNING) {
          this.processWarningInfo(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_STATUS) {
          this.callStatus = buf.readUB4();
          this.endToEndSeqNum = buf.readUB2();
          this.endOfResponse = !this.connection.nscon.endOfRequestSupport;
        } else if (messageType === constants.TNS_MSG_TYPE_PARAMETER) {
          this.processReturnParameter(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_SERVER_SIDE_PIGGYBACK) {
          this.processServerSidePiggyBack(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_END_OF_REQUEST) {
          this.endOfResponse = true;
        } else {
          errors.throwErr(errors.ERR_UNEXPECTED_MESSAGE_TYPE, messageType, buf.pos, buf.packetNum);
        }
      }
      processServerSidePiggyBack(buf) {
        const opcode = buf.readUInt8();
        if (opcode === constants.TNS_SERVER_PIGGYBACK_LTXID) {
          const num_bytes = buf.readUB4();
          if (num_bytes > 0) {
            this.connection._ltxid = Buffer2.from(buf.readBytesWithLength());
          }
        } else if (opcode === constants.TNS_SERVER_PIGGYBACK_QUERY_CACHE_INVALIDATION || opcode === constants.TNS_SERVER_PIGGYBACK_TRACE_EVENT) {
        } else if (opcode === constants.TNS_SERVER_PIGGYBACK_OS_PID_MTS) {
          const numDtys = buf.readUB2();
          buf.skipUB1();
          buf.skipBytes(numDtys);
        } else if (opcode === constants.TNS_SERVER_PIGGYBACK_SYNC) {
          buf.skipUB2();
          buf.skipUB1();
          const num_elements = buf.readUB4();
          buf.skipBytes(1);
          for (let i = 0; i < num_elements; i++) {
            let numBytes = buf.readUB2();
            let keyTextValue, value;
            if (numBytes > 0) {
              keyTextValue = buf.readStr(constants.CSFRM_IMPLICIT);
            }
            numBytes = buf.readUB2();
            if (numBytes > 0)
              value = buf.readBytesWithLength();
            const keywordNum = buf.readUB2();
            if (keywordNum == constants.TNS_KEYWORD_NUM_TRANSACTION_ID) {
              this._updateSessionlessTxnState(value);
            } else if (keywordNum === constants.TNS_KEYWORD_NUM_CURRENT_SCHEMA) {
              this.connection.currentSchema = keyTextValue;
            } else if (keywordNum === constants.TNS_KEYWORD_NUM_EDITION) {
              this.connection._edition = keyTextValue;
            }
          }
          buf.skipUB4();
        } else if (opcode === constants.TNS_SERVER_PIGGYBACK_EXT_SYNC) {
          buf.skipUB2();
          buf.skipUB1();
        } else if (opcode === constants.TNS_SERVER_PIGGYBACK_AC_REPLAY_CONTEXT) {
          buf.skipUB2();
          buf.skipUB1();
          buf.skipUB4();
          buf.skipUB4();
          buf.skipUB1();
          const num_bytes = buf.readUB4();
          if (num_bytes > 0) {
            buf.skipBytesChunked();
          }
        } else if (opcode === constants.TNS_SERVER_PIGGYBACK_SESS_RET) {
          buf.skipUB2();
          buf.skipUB1();
          const num_elements = buf.readUB2();
          if (num_elements > 0) {
            buf.skipUB1();
            for (let i = 0; i < num_elements; ++i) {
              let temp16 = buf.readUB2();
              if (temp16 > 0) {
                buf.skipBytesChunked();
              }
              temp16 = buf.readUB2();
              if (temp16 > 0) {
                buf.skipBytesChunked();
              }
              buf.skipUB2();
            }
          }
          const flags = buf.readUB4();
          if (flags & constants.TNS_SESSGET_SESSION_CHANGED) {
            if (this.connection._drcpEstablishSession) {
              this.connection.statementCache.clearCursors();
            }
          }
          this.connection._drcpEstablishSession = false;
          buf.skipUB4();
          buf.skipUB2();
        } else if (opcode === constants.TNS_SERVER_PIGGYBACK_SESS_SIGNATURE) {
          buf.skipUB2();
          buf.skipUB1();
          buf.skipUB8();
          buf.skipUB8();
          buf.skipUB8();
        } else {
          errors.throwErr(errors.ERR_UNKOWN_SERVER_SIDE_PIGGYBACK, opcode);
        }
      }
      writePiggybacks(buf) {
        if (this.connection._protocol.connInProgress)
          return;
        if (this.connection._currentSchemaModified) {
          this._writeCurrentSchemaPiggyback(buf);
        }
        if (this.connection.statementCache._cursorsToClose.size > 0 && !this.connection._drcpEstablishSession) {
          this.writeCloseCursorsPiggyBack(buf);
        }
        if (this.connection._actionModified || this.connection._clientIdentifierModified || this.connection._dbopModified || this.connection._clientInfoModified || this.connection._moduleModified) {
          this._writeEndToEndPiggybacks(buf);
        }
        if (this.connection._tempLobsTotalSize > 0) {
          this.writeCloseTempLobsPiggyback(buf);
        }
        if (this.connection._sessionlessData?.pending) {
          this.connection._sessionlessData.pending = false;
          this.connection._sessionlessData.piggyback.encode(buf);
          this.connection._sessionlessData.piggyback = null;
        }
      }
      writePiggybackHeader(buf, functionCode) {
        buf.writeUInt8(constants.TNS_MSG_TYPE_PIGGYBACK);
        buf.writeUInt8(functionCode);
        buf.writeSeqNum();
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_23_1_EXT_1) {
          buf.writeUB8(0);
        }
      }
      writeCloseCursorsPiggyBack(buf) {
        this.writePiggybackHeader(buf, constants.TNS_FUNC_CLOSE_CURSORS);
        buf.writeUInt8(1);
        this.connection.statementCache.writeCursorsToClose(buf);
      }
      writeCloseTempLobsPiggyback(buf) {
        const lobsToClose = this.connection._tempLobsToClose;
        const opCode = constants.TNS_LOB_OP_FREE_TEMP | constants.TNS_LOB_OP_ARRAY;
        this.writePiggybackHeader(buf, constants.TNS_FUNC_LOB_OP);
        buf.writeUInt8(1);
        buf.writeUB4(this.connection._tempLobsTotalSize);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUB4(opCode);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUB8(0);
        buf.writeUB8(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        for (const val of lobsToClose) {
          buf.writeBytes(val);
        }
        this.connection._tempLobsToClose = [];
        this.connection._tempLobsTotalSize = 0;
      }
      _writeCurrentSchemaPiggyback(buf) {
        this.writePiggybackHeader(buf, constants.TNS_FUNC_SET_SCHEMA);
        buf.writeUInt8(1);
        const bytes = Buffer2.byteLength(this.connection.currentSchema);
        buf.writeUB4(bytes);
        buf.writeBytesWithLength(Buffer2.from(this.connection.currentSchema));
      }
      _writeEndToEndPiggybacks(buf) {
        let flags = 0;
        if (this.connection._actionModified) {
          flags |= constants.TNS_END_TO_END_ACTION;
        }
        if (this.connection._clientIdentifierModified) {
          flags |= constants.TNS_END_TO_END_CLIENT_IDENTIFIER;
        }
        if (this.connection._clientInfoModified) {
          flags |= constants.TNS_END_TO_END_CLIENT_INFO;
        }
        if (this.connection._moduleModified) {
          flags |= constants.TNS_END_TO_END_MODULE;
        }
        if (this.connection._dbOpModified) {
          flags |= constants.TNS_END_TO_END_DBOP;
        }
        this.writePiggybackHeader(buf, constants.TNS_FUNC_SET_END_TO_END_ATTR);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUB4(flags);
        const clientIdentifierBytes = this.writeEndEndTraceValue(buf, this.connection._clientIdentifier, this.connection._clientIdentifierModified);
        const moduleBytes = this.writeEndEndTraceValue(buf, this.connection._module, this.connection._moduleModified);
        const actionBytes = this.writeEndEndTraceValue(buf, this.connection._action, this.connection._actionModified);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        const clientInfoBytes = this.writeEndEndTraceValue(buf, this.connection._clientInfo, this.connection._clientInfoModified);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        const dbOpBytes = this.writeEndEndTraceValue(buf, this.connection._dbOp, this.connection._dbOpModified);
        if (this.connection._clientIdentifierModified && this.connection._clientIdentifier) {
          buf.writeBytesWithLength(clientIdentifierBytes);
        }
        if (this.connection._moduleModified && this.connection._module) {
          buf.writeBytesWithLength(moduleBytes);
        }
        if (this.connection._actionModified && this.connection._action) {
          buf.writeBytesWithLength(actionBytes);
        }
        if (this.connection._clientInfoModified && this.connection._clientInfo) {
          buf.writeBytesWithLength(clientInfoBytes);
        }
        if (this.connection._dbOpModified && this.connection._dbOp) {
          buf.writeBytesWithLength(dbOpBytes);
        }
        this.connection._actionModified = false;
        this.connection._action = "";
        this.connection._clientIdentifierModified = false;
        this.connection._clientIdentifier = "";
        this.connection._clientInfoModified = false;
        this.connection._clientInfo = "";
        this.connection._dbOpModified = false;
        this.connection._dbOp = "";
        this.connection._moduleModified = false;
        this.connection._module = "";
      }
      writeEndEndTraceValue(buf, value, modified) {
        let writtenBytes;
        if (modified) {
          buf.writeUInt8(1);
          if (value) {
            writtenBytes = Buffer2.from(value);
            buf.writeUB4(writtenBytes.length);
          } else {
            buf.writeUB4(0);
          }
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        return writtenBytes;
      }
      // Called when an error is encountered during decode of RPC
      saveDeferredErr() {
        if (!this.deferredErr) {
          this.deferredErr = errors.getErr(...arguments);
        }
      }
      _updateSessionlessTxnState(buf) {
        const length = buf.length;
        const sessionlessState = buf.readUInt8(length - 2);
        const syncVersion = buf.readUInt8(length - 1);
        let startedOnServer;
        if (syncVersion == constants.TNS_TPC_TRANS_TRANSACTION_ID_SYNC_VERSION_1) {
          if (sessionlessState & constants.TNS_TPC_TRANS_TRANSACTION_ID_SYNC_UNSET) {
            this.connection._sessionlessData = null;
            this.connection._protocol.txnInProgress = false;
          } else if (sessionlessState & constants.TNS_TPC_TRANS_TRANSACTION_ID_SYNC_SET) {
            if (sessionlessState & constants.TNS_TPC_TRANS_TRANSACTION_ID_SYNC_SERVER)
              startedOnServer = true;
            else if (sessionlessState & constants.TNS_TPC_TRANS_TRANSACTION_ID_SYNC_CLIENT)
              startedOnServer = false;
            this.connection._sessionlessData = {
              startedOnServer
            };
            this.connection._protocol.txnInProgress = true;
          }
        } else
          errors.throwErr(errors.ERR_INTERNAL, "Unexpected TransactionId sync version in session sync piggyback.");
      }
    };
    module2.exports = Message;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/lobOp.js
var require_lobOp = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/lobOp.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants3();
    var Message = require_base2();
    var LobOpMessage = class extends Message {
      constructor(connImpl, options) {
        super(connImpl);
        this.sourceLobImpl = options.sourceLobImpl || null;
        this.operation = options.operation;
        this.sourceOffset = options.sourceOffset || 0;
        this.destOffset = options.destOffset || 0;
        this.boolFlag = false;
        if (options.data) {
          this.data = options.data;
        }
        this.functionCode = constants.TNS_FUNC_LOB_OP;
        this.sendAmount = options.sendAmount;
        this.amount = options.amount || 0;
        this.destLength = options.destLength || 0;
      }
      encode(buf) {
        this.writeFunctionHeader(buf);
        if (this.sourceLobImpl === null) {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        } else {
          buf.writeUInt8(1);
          buf.writeUB4(this.sourceLobImpl._locator.length);
        }
        buf.writeUInt8(0);
        buf.writeUB4(this.destLength);
        buf.writeUB4(0);
        buf.writeUB4(0);
        if (this.operation === constants.TNS_LOB_OP_CREATE_TEMP) {
          buf.writeUInt8(1);
        } else {
          buf.writeUInt8(0);
        }
        buf.writeUInt8(0);
        const operations = [
          constants.TNS_LOB_OP_CREATE_TEMP,
          constants.TNS_LOB_OP_IS_OPEN,
          constants.TNS_LOB_OP_FILE_EXISTS,
          constants.TNS_LOB_OP_FILE_ISOPEN
        ];
        if (operations.includes(this.operation)) {
          buf.writeUInt8(1);
        } else {
          buf.writeUInt8(0);
        }
        buf.writeUB4(this.operation);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUB8(this.sourceOffset);
        buf.writeUB8(this.destOffset);
        if (this.sendAmount) {
          buf.writeUInt8(1);
        } else {
          buf.writeUInt8(0);
        }
        for (let i = 0; i < 3; i++) {
          buf.writeUInt16BE(0);
        }
        if (this.sourceLobImpl) {
          buf.writeBytes(this.sourceLobImpl._locator);
        }
        if (this.operation === constants.TNS_LOB_OP_CREATE_TEMP) {
          if (this.sourceLobImpl.dbType._csfrm === constants.CSFRM_NCHAR) {
            buf.caps.checkNCharsetId();
            buf.writeUB4(constants.TNS_CHARSET_UTF16);
          } else {
            buf.writeUB4(constants.TNS_CHARSET_UTF8);
          }
        }
        if (this.data) {
          let data;
          buf.writeUInt8(constants.TNS_MSG_TYPE_LOB_DATA);
          if (this.sourceLobImpl.dbType._oraTypeNum === constants.TNS_DATA_TYPE_BLOB) {
            data = this.data;
          } else if (this.sourceLobImpl.getCsfrm() === constants.CSFRM_NCHAR) {
            data = this.data;
            if (Buffer2.isBuffer(this.data)) {
              data = data.toString();
            }
            data = Buffer2.from(data, constants.TNS_ENCODING_UTF16).swap16();
          } else {
            data = Buffer2.from(this.data);
          }
          buf.writeBytesWithLength(data);
        }
        if (this.sendAmount) {
          buf.writeUB8(this.amount);
        }
      }
      processMessage(buf, messageType) {
        if (messageType === constants.TNS_MSG_TYPE_LOB_DATA) {
          const oraTypeNum = this.sourceLobImpl.dbType._oraTypeNum;
          let data = buf.readBytesWithLength();
          if (data !== null) {
            if (oraTypeNum === constants.TNS_DATA_TYPE_BLOB || oraTypeNum === constants.TNS_DATA_TYPE_BFILE) {
              data = Buffer2.from(data);
            } else if (this.sourceLobImpl.getCsfrm() === constants.CSFRM_NCHAR) {
              data = Buffer2.from(data).swap16().toString("utf16le");
            } else {
              data = data.toString();
            }
          }
          this.data = data;
        } else {
          super.processMessage(buf, messageType);
        }
      }
      processReturnParameter(buf) {
        let lobArray;
        let locator;
        let temp8;
        let numBytes;
        if (this.sourceLobImpl !== null) {
          numBytes = this.sourceLobImpl._locator.length;
          lobArray = buf.readBytes(numBytes);
          locator = lobArray.slice(0, numBytes);
          locator.copy(this.sourceLobImpl._locator);
        }
        if (this.operation === constants.TNS_LOB_OP_CREATE_TEMP) {
          buf.skipUB2();
          buf.skipUB1();
        } else if (this.sendAmount) {
          this.amount = buf.readSB8();
        }
        if (this.operation === constants.TNS_LOB_OP_IS_OPEN || this.operation === constants.TNS_LOB_OP_FILE_EXISTS || this.operation === constants.TNS_LOB_OP_FILE_ISOPEN) {
          temp8 = buf.readUInt8();
          this.boolFlag = temp8 > 0;
        }
      }
    };
    module2.exports = LobOpMessage;
  }
});

// node_modules/oracledb/lib/thin/lob.js
var require_lob3 = __commonJS({
  "node_modules/oracledb/lib/thin/lob.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var LobImpl = require_lob();
    var constants = require_constants3();
    var LobOpMessage = require_lobOp();
    var errors = require_errors();
    var types = require_types();
    var ThinLobImpl = class extends LobImpl {
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        return this.conn;
      }
      //---------------------------------------------------------------------------
      // _sendMessage()
      //
      // Sends a LOB operation message to the server and processes the response.
      //---------------------------------------------------------------------------
      async _sendMessage(options) {
        const message = new LobOpMessage(this.conn, options);
        await this.conn._protocol._processMessage(message);
        if (options.operation === constants.TNS_LOB_OP_READ) {
          return message.data ? message.data : null;
        } else if (options.operation === constants.TNS_LOB_OP_FILE_EXISTS || options.operation === constants.TNS_LOB_OP_FILE_ISOPEN) {
          return message.boolFlag;
        } else {
          return message.amount;
        }
      }
      //---------------------------------------------------------------------------
      // getChunkSize()
      //
      // Internal method for returning the chunk size of the LOB.
      //---------------------------------------------------------------------------
      getChunkSize() {
        return this._chunkSize;
      }
      //---------------------------------------------------------------------------
      // _getChunkSizeAsync()
      //
      // Internal method for returning the chunk size of the LOB fetched from
      // the database.
      //---------------------------------------------------------------------------
      async _getChunkSizeAsync() {
        this.checkConn();
        const options = {
          operation: constants.TNS_LOB_OP_GET_CHUNK_SIZE,
          sourceLobImpl: this,
          sendAmount: true
        };
        this._chunkSize = this._pieceSize = await this._sendMessage(options);
      }
      //---------------------------------------------------------------------------
      // getLength()
      //
      // Internal method for returning the length of a LOB.
      //---------------------------------------------------------------------------
      getLength() {
        return this._length;
      }
      //---------------------------------------------------------------------------
      // getPieceSize()
      //
      // Internal method returning the size to use for each piece that is
      // transferred when reading from the LOB.
      //---------------------------------------------------------------------------
      getPieceSize() {
        return this._pieceSize;
      }
      //---------------------------------------------------------------------------
      // setPieceSize()
      //
      // Internal method to set the pieceSize for LOBs.
      //---------------------------------------------------------------------------
      setPieceSize(value) {
        this._pieceSize = value;
      }
      //---------------------------------------------------------------------------
      // getType()
      //
      // Internal method returning the datatype of LOBs.
      //---------------------------------------------------------------------------
      getType() {
        return this.dbType;
      }
      //---------------------------------------------------------------------------
      // getData()
      //
      // Internal method returning the data obtained from the database.
      //---------------------------------------------------------------------------
      async getData(offset = 1, len = this._length) {
        let shouldClose = false;
        if (!len) {
          len = this._length;
        }
        if (this.dbType === types.DB_TYPE_BFILE) {
          if (!await this.isFileOpen()) {
            shouldClose = true;
            await this.openFile();
          }
        }
        let data;
        try {
          data = await this.read(offset, len);
        } finally {
          if (shouldClose) {
            await this.closeFile();
          }
        }
        return data;
      }
      //---------------------------------------------------------------------------
      // read()
      //
      // Internal method for reading a portion (or all) of the data in the LOB.
      //---------------------------------------------------------------------------
      async read(offset, length) {
        this.checkConn();
        const options = {
          operation: constants.TNS_LOB_OP_READ,
          sourceLobImpl: this,
          sourceOffset: offset,
          sendAmount: true,
          amount: length || this._pieceSize
        };
        return await this._sendMessage(options);
      }
      //---------------------------------------------------------------------------
      // write()
      //
      // Internal method for writing data to the LOB object.
      //---------------------------------------------------------------------------
      async write(offset, data) {
        this.checkConn();
        const options = {
          operation: constants.TNS_LOB_OP_WRITE,
          sourceLobImpl: this,
          sourceOffset: offset,
          data
        };
        await this._sendMessage(options);
        this._length += data.length;
      }
      //---------------------------------------------------------------------------
      // getCsfrm()
      //
      // Return the character set encoding used by the LOB.
      //---------------------------------------------------------------------------
      getCsfrm() {
        if (this.dbType._csfrm !== constants.CSFRM_NCHAR) {
          if (this._locator[constants.TNS_LOB_LOC_OFFSET_FLAG_3] & constants.TNS_LOB_LOC_FLAGS_VAR_LENGTH_CHARSET) {
            return constants.CSFRM_NCHAR;
          }
        }
        return this.dbType._csfrm;
      }
      /**
       * Creates a temporary LOB.
       *
       * @param {object} conn Connection Impl object
       * @param {number} dbType indicates BLOB/CLOB DB type
       */
      async create(conn, dbType) {
        this.dirtyLength = false;
        this.conn = conn;
        this.dbType = dbType;
        this._locator = Buffer2.alloc(40);
        this._isTempLob = true;
        this._length = 0;
        const options = {
          operation: constants.TNS_LOB_OP_CREATE_TEMP,
          sourceLobImpl: this,
          destOffset: dbType._oraTypeNum,
          sourceOffset: dbType._csfrm,
          destLength: constants.TNS_DURATION_SESSION
        };
        await this._sendMessage(options);
        await this._getChunkSizeAsync();
      }
      //---------------------------------------------------------------------------
      // fileExists()
      //
      // Internal method for returning whether the file referenced by a BFILE
      // exists.
      //---------------------------------------------------------------------------
      async fileExists() {
        this.checkConn();
        const options = {
          operation: constants.TNS_LOB_OP_FILE_EXISTS,
          sourceLobImpl: this
        };
        return await this._sendMessage(options);
      }
      //---------------------------------------------------------------------------
      // getDirFileName()
      //
      // Internal method for returning the directory alias and name of the file
      // referenced by a BFILE
      //---------------------------------------------------------------------------
      getDirFileName() {
        const dirNameOffset = constants.TNS_LOB_LOC_FIXED_OFFSET + 2;
        const dirNameLen = this._locator.readUInt16BE(
          constants.TNS_LOB_LOC_FIXED_OFFSET
        );
        const fileNameOffset = constants.TNS_LOB_LOC_FIXED_OFFSET + dirNameLen + 4;
        const fileNameLen = this._locator.readUInt16BE(
          dirNameOffset + dirNameLen
        );
        const dirName = this._locator.slice(
          dirNameOffset,
          dirNameOffset + dirNameLen
        ).toString();
        const fileName = this._locator.slice(
          fileNameOffset,
          fileNameOffset + fileNameLen
        ).toString();
        return { dirName, fileName };
      }
      //---------------------------------------------------------------------------
      // checkConn()
      //
      // Internal method to check the connection.
      //---------------------------------------------------------------------------
      checkConn() {
        if (!this.conn.nscon.connected)
          errors.throwErr(errors.ERR_INVALID_CONNECTION);
      }
      //---------------------------------------------------------------------------
      // close()
      //
      // Internal method to close the LOBs using piggyback mechanism.
      //---------------------------------------------------------------------------
      close() {
        this.checkConn();
        if (this._isTempLob) {
          this.conn._tempLobsToClose.push(this._locator);
          this.conn._tempLobsTotalSize += this._locator.length;
        }
      }
      //---------------------------------------------------------------------------
      // closeFile()
      //
      // Internal method to close the opened file for BFILE LOBs.
      //---------------------------------------------------------------------------
      async closeFile() {
        this.checkConn();
        const options = {
          operation: constants.TNS_LOB_OP_FILE_CLOSE,
          sourceLobImpl: this
        };
        await this._sendMessage(options);
      }
      //---------------------------------------------------------------------------
      // init()
      //
      // Internal method to initialize LOBs.
      //---------------------------------------------------------------------------
      init(conn, locator, dbType, len, chunkSize) {
        this.dirtyLength = false;
        this.conn = conn;
        this._locator = locator;
        this._isTempLob = false;
        if (this._locator[constants.TNS_LOB_LOC_OFFSET_FLAG_4] & constants.TNS_LOB_LOC_FLAGS_TEMP === constants.TNS_LOB_LOC_FLAGS_TEMP || this._locator[constants.TNS_LOB_LOC_OFFSET_FLAG_1] & constants.TNS_LOB_LOC_FLAGS_ABSTRACT === constants.TNS_LOB_LOC_FLAGS_ABSTRACT) {
          this._isTempLob = true;
        }
        this.dbType = dbType;
        this._length = len;
        this._chunkSize = chunkSize;
        this._pieceSize = chunkSize;
      }
      //---------------------------------------------------------------------------
      // isFileOpen()
      //
      // Internal method to check if the file is already open.
      //---------------------------------------------------------------------------
      async isFileOpen() {
        const options = {
          operation: constants.TNS_LOB_OP_FILE_ISOPEN,
          sourceLobImpl: this
        };
        await this._sendMessage(options);
      }
      //---------------------------------------------------------------------------
      // openFile()
      //
      // Internal method for opening file (BFILE).
      //---------------------------------------------------------------------------
      async openFile() {
        this.checkConn();
        const options = {
          operation: constants.TNS_LOB_OP_FILE_OPEN,
          sourceLobImpl: this,
          amount: constants.TNS_LOB_OPEN_READ_ONLY,
          sendAmount: true
        };
        return await this._sendMessage(options);
      }
      //---------------------------------------------------------------------------
      // setDirFileName()
      //
      // Internal method for setting the directory alias and name of the file
      // referenced by a BFILE
      //---------------------------------------------------------------------------
      setDirFileName(dirObject) {
        const dirNameLen = Buffer2.byteLength(dirObject.dirName);
        const dirNameOffset = constants.TNS_LOB_LOC_FIXED_OFFSET + 2;
        const fileNameOffset = dirNameOffset + dirNameLen + 2;
        const fileNameLen = Buffer2.byteLength(dirObject.fileName);
        const newLocLen = fileNameOffset + fileNameLen;
        const newLocator = Buffer2.allocUnsafe(newLocLen);
        this._locator.copy(newLocator, 0, 0, constants.TNS_LOB_LOC_FIXED_OFFSET + 1);
        newLocator.writeUInt16BE(dirNameLen, constants.TNS_LOB_LOC_FIXED_OFFSET);
        newLocator.write(dirObject.dirName, dirNameOffset);
        newLocator.writeInt16BE(fileNameLen, dirNameOffset + dirNameLen);
        newLocator.write(dirObject.fileName, fileNameOffset);
        this._locator = newLocator;
      }
    };
    module2.exports = ThinLobImpl;
  }
});

// node_modules/oracledb/lib/thin/dbObject.js
var require_dbObject3 = __commonJS({
  "node_modules/oracledb/lib/thin/dbObject.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants3();
    var errors = require_errors();
    var types = require_types();
    var DbObjectImpl = require_dbObject();
    var { GrowableBuffer } = require_buffer();
    var ThinLobImpl = require_lob3();
    var DbObjectPickleBuffer = class extends GrowableBuffer {
      //---------------------------------------------------------------------------
      // _readBytesWithLength()
      //
      // Helper function that processes the number of bytes (if needed) and then
      // acquires the specified number of bytes from the buffer.
      //---------------------------------------------------------------------------
      _readBytesWithLength(numBytes) {
        if (numBytes === constants.TNS_LONG_LENGTH_INDICATOR) {
          numBytes = this.readUInt32BE();
        }
        return this.readBytes(numBytes);
      }
      //---------------------------------------------------------------------------
      // getIsAtomicNull()
      //
      // Reads the next byte and checks to see if the value is atomically null. If
      // not, the byte is returned to the buffer for further processing.
      //---------------------------------------------------------------------------
      getIsAtomicNull(isCollection) {
        const value = this.readUInt8();
        if (value === constants.TNS_OBJ_ATOMIC_NULL || isCollection && value === constants.TNS_NULL_LENGTH_INDICATOR) {
          return true;
        }
        this.pos -= 1;
        return false;
      }
      //---------------------------------------------------------------------------
      // readHeader()
      //
      // Reads the header of the pickled data.
      //---------------------------------------------------------------------------
      readHeader(obj) {
        obj.imageFlags = this.readUInt8();
        obj.imageVersion = this.readUInt8();
        this.readLength();
        if ((obj.imageFlags & constants.TNS_OBJ_NO_PREFIX_SEG) === 0) {
          const prefixSegLength = this.readLength();
          this.skipBytes(prefixSegLength);
        }
      }
      //---------------------------------------------------------------------------
      // readLength()
      //
      // Read the length from the buffer. This will be a single byte, unless the
      // value meets or exeeds TNS_LONG_LENGTH_INDICATOR. In that case, the value
      // is stored as a 4-byte integer.
      //---------------------------------------------------------------------------
      readLength() {
        const shortLength = this.readUInt8();
        if (shortLength !== constants.TNS_LONG_LENGTH_INDICATOR) {
          return shortLength;
        }
        return this.readUInt32BE();
      }
      //---------------------------------------------------------------------------
      // writeHeader()
      //
      // Writes the header of the pickled data. Since the size is unknown at this
      // point, zero is written initially and the actual size is written later.
      //---------------------------------------------------------------------------
      writeHeader(obj) {
        this.writeUInt8(obj.imageFlags);
        this.writeUInt8(obj.imageVersion);
        this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);
        this.writeUInt32BE(0);
        if (obj._objType.isCollection) {
          this.writeUInt8(1);
          this.writeUInt8(1);
        }
      }
      //---------------------------------------------------------------------------
      // writeLength()
      //
      // Writes the length to the buffer.
      //---------------------------------------------------------------------------
      writeLength(length) {
        if (length <= constants.TNS_OBJ_MAX_SHORT_LENGTH) {
          this.writeUInt8(length);
        } else {
          this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);
          this.writeUInt32BE(length);
        }
      }
      //---------------------------------------------------------------------------
      // _writeRawBytesAndLength()
      //
      // Writes the length in the format required before
      // writing the bytes.
      //---------------------------------------------------------------------------
      _writeRawBytesAndLength(value, numBytes) {
        this.writeLength(numBytes);
        this.writeBytes(value);
      }
    };
    var ThinDbObjectImpl = class _ThinDbObjectImpl extends DbObjectImpl {
      constructor(objType, packedData) {
        if (typeof objType === "function") {
          objType = objType.prototype._objType;
        }
        super(objType);
        this.packedData = packedData;
        this.unpackedAttrs = /* @__PURE__ */ new Map();
        if (packedData) {
          this.unpackedAssocArray = /* @__PURE__ */ new Map();
          this.unpackedAssocKeys = void 0;
        } else if (objType) {
          const prefix = Buffer2.from([
            0,
            34,
            constants.TNS_OBJ_NON_NULL_OID,
            constants.TNS_OBJ_HAS_EXTENT_OID
          ]);
          this.toid = Buffer2.concat([prefix, objType.oid, constants.TNS_EXTENT_OID]);
          this.flags = constants.TNS_OBJ_TOP_LEVEL;
          this.imageFlags = constants.TNS_OBJ_IS_VERSION_81;
          this.imageVersion = constants.TNS_OBJ_IMAGE_VERSION;
          if (objType.isCollection) {
            this.imageFlags |= constants.TNS_OBJ_IS_COLLECTION;
            if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {
              this.unpackedAssocArray = /* @__PURE__ */ new Map();
            } else {
              this.unpackedArray = [];
            }
          } else {
            this.imageFlags |= constants.TNS_OBJ_NO_PREFIX_SEG;
          }
        }
      }
      //---------------------------------------------------------------------------
      // _ensureAssocKeys()
      //
      // Ensure that the keys for the associative array have been calculated.
      // PL/SQL associative arrays keep their keys in sorted order so this must be
      // calculated when indices are required.
      //---------------------------------------------------------------------------
      _ensureAssocKeys() {
        if (!this.unpackedAssocKeys) {
          this.unpackedAssocKeys = [...this.unpackedAssocArray.keys()].sort((x, y) => x - y);
        }
      }
      //---------------------------------------------------------------------------
      // _ensureUnpacked()
      //
      // Ensure that the data has been unpacked.
      //---------------------------------------------------------------------------
      _ensureUnpacked() {
        if (this.packedData) {
          this._unpackData();
        }
      }
      //---------------------------------------------------------------------------
      // _getPackedData()
      //
      // Returns the packed data for the object. This will either be the value
      // retrieved from the database or generated packed data (for new objects and
      // those that have had their data unpacked already).
      //---------------------------------------------------------------------------
      _getPackedData() {
        if (this.packedData)
          return this.packedData;
        const buf = new DbObjectPickleBuffer();
        buf.writeHeader(this);
        this._packData(buf);
        const size = buf.pos;
        buf.pos = 3;
        buf.writeUInt32BE(size);
        return buf.buf.subarray(0, size);
      }
      //---------------------------------------------------------------------------
      // _packData()
      //
      // Packs the data from the object into the buffer.
      //---------------------------------------------------------------------------
      _packData(buf) {
        const objType = this._objType;
        if (objType.isCollection) {
          buf.writeUInt8(objType.collectionFlags);
          if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {
            this._ensureAssocKeys();
            buf.writeLength(this.unpackedAssocKeys.length);
            for (const index of this.unpackedAssocKeys) {
              buf.writeInt32BE(index);
              this._packValue(
                buf,
                objType.elementType,
                objType.elementTypeClass,
                this.unpackedAssocArray.get(index)
              );
            }
          } else {
            buf.writeLength(this.unpackedArray.length);
            for (const value of this.unpackedArray) {
              this._packValue(
                buf,
                objType.elementType,
                objType.elementTypeClass,
                value
              );
            }
          }
        } else {
          for (const attr of objType.attributes) {
            this._packValue(
              buf,
              attr.type,
              attr.typeClass,
              this.unpackedAttrs.get(attr.name)
            );
          }
        }
      }
      //---------------------------------------------------------------------------
      // _packValue()
      //
      // Packs a value into the buffer. At this point it is assumed that the value
      // matches the correct type.
      //---------------------------------------------------------------------------
      _packValue(buf, type, typeClass, value) {
        if (value === null || value === void 0) {
          if (typeClass && !typeClass.prototype.isCollection) {
            buf.writeUInt8(constants.TNS_OBJ_ATOMIC_NULL);
          } else {
            buf.writeUInt8(constants.TNS_NULL_LENGTH_INDICATOR);
          }
        } else {
          switch (type) {
            case types.DB_TYPE_CHAR:
            case types.DB_TYPE_VARCHAR:
              buf.writeBytesWithLength(Buffer2.from(value));
              break;
            case types.DB_TYPE_NCHAR:
            case types.DB_TYPE_NVARCHAR:
              buf.writeBytesWithLength(Buffer2.from(value, "utf16le").swap16());
              break;
            case types.DB_TYPE_NUMBER:
              buf.writeOracleNumber(value.toString());
              break;
            case types.DB_TYPE_BINARY_INTEGER:
            case types.DB_TYPE_BOOLEAN:
              buf.writeUInt8(4);
              buf.writeUInt32BE(value);
              break;
            case types.DB_TYPE_RAW:
              buf.writeBytesWithLength(value);
              break;
            case types.DB_TYPE_BINARY_DOUBLE:
              buf.writeUInt8(8);
              buf.writeBinaryDouble(value);
              break;
            case types.DB_TYPE_BINARY_FLOAT:
              buf.writeUInt8(4);
              buf.writeBinaryFloat(value);
              break;
            case types.DB_TYPE_DATE:
            case types.DB_TYPE_TIMESTAMP:
            case types.DB_TYPE_TIMESTAMP_LTZ:
            case types.DB_TYPE_TIMESTAMP_TZ:
              buf.writeOracleDate(value, type);
              break;
            case types.DB_TYPE_OBJECT:
              if (this._objType.isCollection || value._objType.isCollection) {
                buf.writeBytesWithLength(value._getPackedData());
              } else {
                value._packData(buf);
              }
              break;
            default:
              errors.throwErr(errors.ERR_NOT_IMPLEMENTED, type);
          }
        }
      }
      //---------------------------------------------------------------------------
      // _unpackData()
      //
      // Unpacks the packed data into a map of JavaScript values.
      //---------------------------------------------------------------------------
      _unpackData() {
        const buf = new DbObjectPickleBuffer(this.packedData);
        buf.readHeader(this);
        this._unpackDataFromBuf(buf);
        this.packedData = void 0;
      }
      //---------------------------------------------------------------------------
      // _unpackDataFromBuf()
      //
      // Unpacks the data in the buffer into a map of JavaScript values.
      //---------------------------------------------------------------------------
      _unpackDataFromBuf(buf) {
        let unpackedArray, unpackedAssocArray, assocIndex, unpackedAttrs;
        const objType = this._objType;
        if (objType.isCollection) {
          if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {
            unpackedAssocArray = /* @__PURE__ */ new Map();
          } else {
            unpackedArray = [];
          }
          this.collectionFlags = buf.readUInt8();
          const numElements = buf.readLength();
          for (let i = 0; i < numElements; i++) {
            if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {
              assocIndex = buf.readUInt32BE();
            }
            const value = this._unpackValue(
              buf,
              objType.elementType,
              objType.elementTypeClass
            );
            if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {
              unpackedAssocArray.set(assocIndex, value);
            } else {
              unpackedArray.push(value);
            }
          }
        } else {
          unpackedAttrs = /* @__PURE__ */ new Map();
          for (const attr of objType.attributes) {
            const value = this._unpackValue(buf, attr.type, attr.typeClass);
            unpackedAttrs.set(attr.name, value);
          }
        }
        this.unpackedAttrs = unpackedAttrs;
        this.unpackedArray = unpackedArray;
        this.unpackedAssocArray = unpackedAssocArray;
      }
      //---------------------------------------------------------------------------
      // _unpackValue()
      //
      // Unpacks a single value and returns it.
      //---------------------------------------------------------------------------
      _unpackValue(buf, type, typeClass) {
        let isNull, obj, value, isCollection;
        switch (type) {
          case types.DB_TYPE_NUMBER:
            return buf.readOracleNumber();
          case types.DB_TYPE_BINARY_INTEGER:
            return buf.readBinaryInteger();
          case types.DB_TYPE_VARCHAR:
          case types.DB_TYPE_CHAR:
            return buf.readStr(constants.CSFRM_IMPLICIT);
          case types.DB_TYPE_NVARCHAR:
          case types.DB_TYPE_NCHAR:
            return buf.readStr(constants.CSFRM_NCHAR);
          case types.DB_TYPE_RAW:
            value = buf.readBytesWithLength();
            if (value !== null)
              value = Buffer2.from(value);
            return value;
          case types.DB_TYPE_BINARY_DOUBLE:
            return buf.readBinaryDouble();
          case types.DB_TYPE_BINARY_FLOAT:
            return buf.readBinaryFloat();
          case types.DB_TYPE_DATE:
          case types.DB_TYPE_TIMESTAMP:
            return buf.readOracleDate(true);
          case types.DB_TYPE_TIMESTAMP_LTZ:
          case types.DB_TYPE_TIMESTAMP_TZ:
            return buf.readOracleDate(false);
          case types.DB_TYPE_BOOLEAN:
            return buf.readBool();
          case types.DB_TYPE_OBJECT:
          case types.DB_TYPE_XMLTYPE:
            obj = new _ThinDbObjectImpl(typeClass);
            isCollection = obj._objType.isCollection || this._objType.isCollection;
            isNull = buf.getIsAtomicNull(isCollection);
            if (isNull)
              return null;
            if (obj._objType.isXmlType) {
              return readXML(obj._objType._connection, buf.readBytesWithLength());
            }
            if (isCollection) {
              obj.packedData = Buffer2.from(buf.readBytesWithLength());
            } else {
              obj._unpackDataFromBuf(buf);
            }
            return obj;
          default:
            errors.throwErr(errors.ERR_NOT_IMPLEMENTED, type);
        }
      }
      //---------------------------------------------------------------------------
      // append()
      //
      // Appends an element to the collection.
      //---------------------------------------------------------------------------
      append(value) {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          const objType = this._objType;
          if (objType.maxNumElements > 0 && this.unpackedArray.length >= objType.maxNumElements) {
            errors.throwErr(
              errors.ERR_INVALID_COLL_INDEX_SET,
              this.unpackedArray.length,
              0,
              objType.maxNumElements - 1
            );
          }
          this.unpackedArray.push(value);
        } else {
          this._ensureAssocKeys();
          let newIndex;
          if (this.unpackedAssocKeys.length === 0) {
            newIndex = 0;
          } else {
            const keyIndex = this.unpackedAssocKeys.length - 1;
            newIndex = this.unpackedAssocKeys[keyIndex] + 1;
          }
          this.unpackedAssocArray.set(newIndex, value);
          this.unpackedAssocKeys.push(newIndex);
        }
      }
      //---------------------------------------------------------------------------
      // copy
      //
      // Creates and returns a copy of the ThinDBObjectImpl object. The copy is
      // independent of the original object that was copied.
      //---------------------------------------------------------------------------
      copy() {
        const newObjImpl = new _ThinDbObjectImpl(this._objType, this._getPackedData());
        newObjImpl.toid = this.toid;
        newObjImpl.flags = this.flags;
        newObjImpl.imageFlags = this.imageFlags;
        newObjImpl.imageVersion = this.imageVersion;
        return newObjImpl;
      }
      //---------------------------------------------------------------------------
      // deleteElement()
      //
      // Deletes an element from a collection.
      //---------------------------------------------------------------------------
      deleteElement(index) {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          if (this._objType.collectionType == constants.TNS_OBJ_VARRAY) {
            errors.throwErr(errors.ERR_DELETE_ELEMENTS_OF_VARRAY);
          }
          this.unpackedArray.splice(index, 1);
        } else {
          this.unpackedAssocKeys = void 0;
          this.unpackedAssocArray.delete(index);
        }
      }
      //---------------------------------------------------------------------------
      // getAttrValue()
      //
      // Returns the value of the given attribute on the object.
      //---------------------------------------------------------------------------
      getAttrValue(attr) {
        this._ensureUnpacked();
        const value = this.unpackedAttrs.get(attr.name);
        if (value === void 0)
          return null;
        return value;
      }
      //---------------------------------------------------------------------------
      // getElement()
      //
      // Returns an element from the collection.
      //---------------------------------------------------------------------------
      getElement(index) {
        let value;
        this._ensureUnpacked();
        if (this.unpackedArray) {
          value = this.unpackedArray[index];
        } else {
          value = this.unpackedAssocArray.get(index);
        }
        if (value === void 0) {
          errors.throwErr(errors.ERR_INVALID_COLL_INDEX_GET, index);
        }
        return value;
      }
      //---------------------------------------------------------------------------
      // getFirstIndex()
      //
      // Returns the first index in a collection.
      //---------------------------------------------------------------------------
      getFirstIndex() {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          return 0;
        } else if (this.unpackedAssocArray) {
          this._ensureAssocKeys();
          return this.unpackedAssocKeys[0];
        }
      }
      //---------------------------------------------------------------------------
      // getKeys()
      //
      // Returns the keys of the collection in a JavaScript array.
      //---------------------------------------------------------------------------
      getKeys() {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          return Array.from(this.unpackedArray.keys());
        } else if (this.unpackedAssocArray) {
          this._ensureAssocKeys();
          return Array.from(this.unpackedAssocKeys);
        }
        return [];
      }
      //---------------------------------------------------------------------------
      // getLastIndex()
      //
      // Returns the last index in a collection.
      //---------------------------------------------------------------------------
      getLastIndex() {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          if (this.unpackedArray.length > 0)
            return this.unpackedArray.length - 1;
        } else if (this.unpackedAssocArray) {
          this._ensureAssocKeys();
          return this.unpackedAssocKeys[this.unpackedAssocKeys.length - 1];
        }
      }
      //---------------------------------------------------------------------------
      // getNextIndex()
      //
      // Returns the next index in a collection.
      // For associative arrays indexed by integers, if the passed-in index
      // parameter is not present, it will return the next higher index found
      // in the associative array.
      //---------------------------------------------------------------------------
      getNextIndex(index) {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          if (index + 1 < this.unpackedArray.length) {
            return index + 1;
          }
        } else if (this.unpackedAssocArray) {
          this._ensureAssocKeys();
          for (const key of this.unpackedAssocKeys) {
            if (key > index)
              return key;
          }
        }
      }
      //---------------------------------------------------------------------------
      // getPrevIndex()
      //
      // Returns the previous index in a collection.
      // For associative arrays indexed by integers, if the passed-in index
      // parameter is not present, it will return the next lower index found
      // in the associative array.
      //---------------------------------------------------------------------------
      getPrevIndex(index) {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          if (index > 0) {
            return index - 1;
          }
        } else if (this.unpackedAssocArray) {
          this._ensureAssocKeys();
          let prev;
          for (const key of this.unpackedAssocKeys) {
            if (key >= index)
              return prev;
            prev = key;
          }
        }
      }
      //---------------------------------------------------------------------------
      // getValues()
      //
      // Returns the values of the collection in a JavaScript array.
      //---------------------------------------------------------------------------
      getValues() {
        const result = [];
        this._ensureUnpacked();
        if (this.unpackedArray) {
          return Array.from(this.unpackedArray);
        } else if (this.unpackedAssocArray) {
          this._ensureAssocKeys();
          for (const key of this.unpackedAssocKeys) {
            result.push(this.unpackedAssocArray.get(key));
          }
        }
        return result;
      }
      //---------------------------------------------------------------------------
      // getLength
      //
      // Gets the size of the database object if it is a collection. Else returns
      // undefined.
      //---------------------------------------------------------------------------
      getLength() {
        this._ensureUnpacked();
        if (this.unpackedArray)
          return this.unpackedArray.length;
        if (this.unpackedAssocArray)
          return this.unpackedAssocArray.size;
      }
      //---------------------------------------------------------------------------
      // hasElement()
      //
      // Returns whether an element exists at the given index.
      //---------------------------------------------------------------------------
      hasElement(index) {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          return index >= 0 && index < this.unpackedArray.length;
        }
        return this.unpackedAssocArray.has(index);
      }
      //---------------------------------------------------------------------------
      // setAttrValue()
      //
      // Sets the value of the attribute on the object to the given value.
      //---------------------------------------------------------------------------
      setAttrValue(attr, value) {
        this._ensureUnpacked();
        this.unpackedAttrs.set(attr.name, value);
      }
      //---------------------------------------------------------------------------
      // setElement()
      //
      // Sets an entry in a collection that is indexed by integers.
      //---------------------------------------------------------------------------
      setElement(index, value) {
        this._ensureUnpacked();
        if (this.unpackedArray) {
          const maxIndex = Math.max(this.unpackedArray.length - 1, 0);
          if (index > maxIndex) {
            errors.throwErr(errors.ERR_INVALID_COLL_INDEX_SET, index, 0, maxIndex);
          }
          this.unpackedArray[index] = value;
        } else {
          if (!this.unpackedAssocArray.has(index))
            this.unpackedAssocKeys = void 0;
          this.unpackedAssocArray.set(index, value);
        }
      }
      //---------------------------------------------------------------------------
      // trim()
      //
      // Trim the specified number of elements from the end of the collection.
      //---------------------------------------------------------------------------
      trim(numToTrim) {
        this._ensureUnpacked();
        if (numToTrim > 0) {
          this.unpackedArray = this.unpackedArray.slice(
            0,
            this.unpackedArray.length - numToTrim
          );
        }
      }
    };
    function readXML(conn, buf) {
      let colValue;
      const xmlObj = new DbObjectPickleBuffer(buf);
      const tempobj = {};
      xmlObj.readHeader(tempobj);
      xmlObj.skipBytes(1);
      const xmlflag = xmlObj.readUInt32BE();
      if (xmlflag & constants.TNS_XML_TYPE_FLAG_SKIP_NEXT_4) {
        xmlObj.skipBytes(4);
      }
      const numBytesLeft = xmlObj.numBytesLeft();
      const ptr = xmlObj.readBytes(numBytesLeft);
      if (xmlflag & constants.TNS_XML_TYPE_STRING) {
        colValue = ptr.toString();
      } else if (xmlflag & constants.TNS_XML_TYPE_LOB) {
        const lobImpl = new ThinLobImpl();
        const locator = Buffer2.from(ptr);
        lobImpl.init(conn, locator, types.DB_TYPE_CLOB, 0, 0);
        colValue = lobImpl;
      } else {
        errors.throwErr(errors.ERR_UNEXPECTED_XML_TYPE, xmlflag);
      }
      return colValue;
    }
    module2.exports = { ThinDbObjectImpl, readXML };
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/withData.js
var require_withData = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/withData.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var utils = require_utils();
    var constants = require_constants3();
    var Message = require_base2();
    var { ThinDbObjectImpl, readXML } = require_dbObject3();
    var ThinLobImpl = require_lob3();
    var errors = require_errors();
    var types = require_types();
    var MessageWithData = class extends Message {
      constructor(connection, statement = null, options = null) {
        super(connection);
        this.statement = statement;
        this.options = options;
        this.offset = 0;
        this.numExecs = 1;
        this.arrayDmlRowCounts = false;
        this.requiresDefine = false;
        this.rowIndex = statement.bufferRowCount || 0;
        this.dmlRowCounts = [];
        this.batchErrors = false;
        this.outVariables = [];
        this.inFetch = false;
        this.parseOnly = false;
        this.resultSetsToSetup = [];
        this.deferredErr = null;
      }
      /**
        * processMessage() - Process the data type message
        */
      processMessage(buf, messageType) {
        if (messageType === constants.TNS_MSG_TYPE_DESCRIBE_INFO) {
          buf.skipBytesChunked();
          const prevQueryVars = this.statement.queryVars;
          this.statement.numQueryVars = 0;
          this.statement.bufferRowCount = 0;
          this.statement.bufferRowIndex = 0;
          this.processDescribeInfo(buf, this.resultSet, prevQueryVars);
          this.outVariables = this.statement.queryVars;
        } else if (messageType === constants.TNS_MSG_TYPE_ROW_HEADER) {
          this.processRowHeader(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_ROW_DATA) {
          this.processRowData(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_IMPLICIT_RESULTSET) {
          this.processImplicitResultSet(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_BIT_VECTOR) {
          this.processBitVector(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_IO_VECTOR) {
          this.processIOVector(buf);
        } else if (messageType === constants.TNS_MSG_TYPE_FLUSH_OUT_BINDS) {
          this.flushOutBinds = true;
          this.endOfResponse = true;
        } else if (messageType === constants.TNS_MSG_TYPE_ERROR) {
          this.processErrorInfo(buf);
        } else {
          super.processMessage(buf, messageType);
        }
      }
      processErrorInfo(buf) {
        super.processErrorInfo(buf);
        if (this.errorInfo.cursorId !== 0) {
          this.statement.cursorId = this.errorInfo.cursorId;
        }
        if (!this.statement.isPlSql) {
          this.statement.rowCount = this.errorInfo.rowCount;
        }
        if (this.errorInfo.rowCount > 0) {
          this.statement.lastRowid = utils.encodeRowID(this.errorInfo.rowID);
        }
        this.options.batchErrors = this.errorInfo.batchErrors;
        if (this.batchErrors && this.options.batchErrors === null) {
          this.options.batchErrors = [];
        }
        if (this.errorInfo.num === constants.TNS_ERR_NO_DATA_FOUND && this.statement.isQuery) {
          this.errorInfo.num = 0;
          this.errorOccurred = false;
          this.statement.moreRowsToFetch = false;
        } else if (this.retry) {
          this.retry = false;
        } else if (this.statement.isQuery && (this.errorInfo.num === constants.TNS_ERR_VAR_NOT_IN_SELECT_LIST || this.errorInfo.num === constants.TNS_ERR_INCONSISTENT_DATA_TYPES)) {
          this.retry = true;
          this.connection.statementCache.clearCursor(this.statement);
        } else if (this.errorInfo.num !== 0 && this.errorInfo.cursorId !== 0) {
          if (!errors.ERR_INTEGRITY_ERROR_CODES.includes(this.errorInfo.num)) {
            this.connection.statementCache.clearCursor(this.statement);
            this.statement.returnToCache = false;
          }
        }
        if (this.errorInfo.batchErrors) {
          this.errorOccurred = false;
        }
      }
      //---------------------------------------------------------------------------
      // If we have fetched this column earlier, we set that
      // fetch type for the describe info variable received
      // assuming the returned column order is same as previous.
      //---------------------------------------------------------------------------
      _adjustFetchType(pVar, cVar) {
        if (cVar.fetchInfo.dbType._oraTypeNum === constants.TNS_DATA_TYPE_CLOB && pVar.fetchInfo.fetchType._oraTypeNum === constants.TNS_DATA_TYPE_LONG || cVar.fetchInfo.dbType._oraTypeNum === constants.TNS_DATA_TYPE_BLOB && pVar.fetchInfo.fetchType._oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW || cVar.fetchInfo.dbType._oraTypeNum === constants.TNS_DATA_TYPE_JSON && pVar.fetchInfo.fetchType._oraTypeNum === constants.TNS_DATA_TYPE_VARCHAR || cVar.fetchInfo.dbType._oraTypeNum === constants.TNS_DATA_TYPE_VECTOR && pVar.fetchInfo.fetchType._oraTypeNum === constants.TNS_DATA_TYPE_LONG) {
          cVar.type = pVar.fetchInfo.fetchType;
          cVar.maxSize = pVar.maxSize;
        }
      }
      processDescribeInfo(buf, resultSet, prevQueryVars) {
        const statement = resultSet.statement;
        buf.skipUB4();
        statement.numQueryVars = buf.readUB4();
        if (statement.numQueryVars > 0) {
          buf.skipUB1();
        }
        const metadata = [];
        const queryVars = [];
        for (let i = 0; i < statement.numQueryVars; i++) {
          const variable = this.processColumnInfo(buf, i + 1);
          if (prevQueryVars && i < prevQueryVars.length) {
            this._adjustFetchType(prevQueryVars[i], variable);
          }
          queryVars.push(variable);
          metadata.push(variable.fetchInfo);
        }
        let numBytes = buf.readUB4();
        if (numBytes > 0) {
          buf.skipBytesChunked();
        }
        buf.skipUB4();
        buf.skipUB4();
        buf.skipUB4();
        buf.skipUB4();
        numBytes = buf.readUB4();
        if (numBytes > 0) {
          buf.skipBytesChunked();
        }
        resultSet.metaData = metadata;
        statement.queryVars = queryVars;
        this.resultSetsToSetup.push(resultSet);
      }
      processColumnInfo(buf, columnNum) {
        const dataType = buf.readUInt8();
        buf.skipUB1();
        const precision = buf.readInt8();
        const scale = buf.readInt8();
        const maxSize = buf.readUB4();
        buf.skipUB4();
        buf.skipUB8();
        let oid;
        let numBytes = buf.readUB4();
        if (numBytes > 0) {
          oid = Buffer2.from(buf.readBytesWithLength());
        }
        buf.skipUB2();
        buf.skipUB2();
        const csfrm = buf.readUInt8();
        let size = buf.readUB4();
        if (dataType === constants.TNS_DATA_TYPE_RAW) {
          size = maxSize;
        }
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {
          buf.skipUB4();
        }
        const nullable = Boolean(buf.readUInt8());
        buf.skipUB1();
        let name;
        numBytes = buf.readUB4();
        if (numBytes > 0) {
          name = buf.readStr(constants.CSFRM_IMPLICIT);
        }
        let schema;
        numBytes = buf.readUB4();
        if (numBytes > 0) {
          schema = buf.readStr(constants.CSFRM_IMPLICIT);
        }
        numBytes = buf.readUB4();
        let typeName;
        if (numBytes > 0) {
          typeName = buf.readStr(constants.CSFRM_IMPLICIT);
        }
        buf.skipUB2();
        const udsFlags = buf.readUB4();
        const fetchInfo = {
          name,
          dbColumnName: name,
          dbType: types.getTypeByOraTypeNum(dataType, csfrm),
          nullable
        };
        fetchInfo.isJson = Boolean(udsFlags & constants.TNS_UDS_FLAGS_IS_JSON);
        fetchInfo.isOson = Boolean(udsFlags & constants.TNS_UDS_FLAGS_IS_OSON);
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_23_1) {
          numBytes = buf.readUB4();
          if (numBytes > 0) {
            fetchInfo.domainSchema = buf.readStr(constants.CSFRM_IMPLICIT);
          }
          numBytes = buf.readUB4();
          if (numBytes > 0) {
            fetchInfo.domainName = buf.readStr(constants.CSFRM_IMPLICIT);
          }
        }
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_23_1_EXT_3) {
          if (buf.readUB4() > 0) {
            fetchInfo.annotations = {};
            buf.skipUB1();
            const numAnnotations = buf.readUB4();
            buf.skipUB1();
            let key, value;
            for (let i = 0; i < numAnnotations; i++) {
              buf.skipUB4();
              value = "";
              key = buf.readStr(constants.CSFRM_IMPLICIT);
              numBytes = buf.readUB4();
              if (numBytes > 0) {
                value = buf.readStr(constants.CSFRM_IMPLICIT);
              }
              fetchInfo.annotations[key] = value;
              buf.skipUB4();
            }
            buf.skipUB4();
          }
        }
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_23_4) {
          const dimensions = buf.readUB4();
          const vectorFormat = buf.readUInt8();
          const vectorFlags = buf.readUInt8();
          if (fetchInfo.dbType === types.DB_TYPE_VECTOR) {
            if (!(vectorFlags & constants.VECTOR_META_FLAG_FLEXIBLE_DIM)) {
              fetchInfo.vectorDimensions = dimensions;
            }
            fetchInfo.isSparseVector = Boolean(vectorFlags & constants.VECTOR_META_FLAG_SPARSE);
            if (vectorFormat !== constants.VECTOR_FORMAT_FLEX) {
              fetchInfo.vectorFormat = vectorFormat;
            }
          }
        }
        switch (fetchInfo.dbType) {
          case types.DB_TYPE_VARCHAR:
          case types.DB_TYPE_NVARCHAR:
          case types.DB_TYPE_CHAR:
          case types.DB_TYPE_NCHAR:
          case types.DB_TYPE_RAW:
            fetchInfo.byteSize = size;
            break;
          case types.DB_TYPE_NUMBER:
            fetchInfo.precision = precision;
            break;
          case types.DB_TYPE_TIMESTAMP:
          case types.DB_TYPE_TIMESTAMP_TZ:
          case types.DB_TYPE_TIMESTAMP_LTZ:
            fetchInfo.precision = scale;
            break;
          case types.DB_TYPE_OBJECT:
            fetchInfo.dbTypeClass = this.connection._getDbObjectType(
              schema,
              typeName,
              void 0,
              oid
            );
            if (fetchInfo.dbTypeClass.partial) {
              this.connection._partialDbObjectTypes.push(fetchInfo.dbTypeClass);
            }
            if (fetchInfo.dbTypeClass.isXmlType) {
              fetchInfo.dbType = types.DB_TYPE_XMLTYPE;
            }
            break;
          default:
            break;
        }
        if (fetchInfo.dbType === types.DB_TYPE_NUMBER) {
          fetchInfo.scale = scale;
        }
        return {
          fetchInfo,
          type: fetchInfo.dbType,
          maxSize,
          columnNum,
          values: new Array(this.options.fetchArraySize)
        };
      }
      processRowHeader(buf) {
        buf.skipUB1();
        buf.skipUB2();
        buf.skipUB4();
        buf.skipUB4();
        buf.skipUB2();
        let numBytes = buf.readUB4();
        if (numBytes > 0) {
          this.bitVector = Buffer2.from(buf.readBytesWithLength());
        }
        numBytes = buf.readUB4();
        if (numBytes > 0) {
          buf.skipBytesChunked();
        }
      }
      isDuplicateData(columnName) {
        if (!this.bitVector) {
          return false;
        }
        const byteNum = Math.floor(columnName / 8);
        const bitNum = columnName % 8;
        return (this.bitVector[byteNum] & 1 << bitNum) === 0;
      }
      processRowData(buf) {
        let value;
        for (const [col, variable] of this.outVariables.entries()) {
          if (variable.isArray) {
            variable.numElementsInArray = buf.readUB4();
            const values = new Array(variable.numElementsInArray).fill(null);
            for (let pos = 0; pos < variable.numElementsInArray; pos++) {
              value = this.processColumnData(buf, variable, pos);
              values[pos] = value;
            }
            variable.values[this.rowIndex] = values;
          } else if (this.statement.isReturning) {
            const numRows = buf.readUB4();
            const values = Array(numRows).fill(null);
            for (let j = 0; j < numRows; j++) {
              values[j] = this.processColumnData(buf, variable, j);
            }
            variable.values[this.rowIndex] = values;
          } else if (this.isDuplicateData(col)) {
            if (this.rowIndex === 0 && variable.outConverter) {
              value = variable.lastRawValue;
            } else {
              value = variable.values[this.statement.lastRowIndex];
            }
            variable.values[this.rowIndex] = value;
          } else {
            value = this.processColumnData(buf, variable, this.rowIndex);
            variable.values[this.rowIndex] = value;
          }
        }
        this.rowIndex++;
        if (this.inFetch) {
          this.statement.lastRowIndex = this.rowIndex - 1;
          this.statement.bufferRowCount++;
          this.bitVector = null;
        }
      }
      processIOVector(buf) {
        let numBytes;
        buf.skipUB1();
        const temp16 = buf.readUB2();
        const temp32 = buf.readUB4();
        const numBinds = temp32 * 256 + temp16;
        buf.skipUB4();
        buf.skipUB2();
        numBytes = buf.readUB2();
        if (numBytes > 0) {
          buf.skipBytes(numBytes);
        }
        numBytes = buf.readUB2();
        if (numBytes > 0) {
          buf.skipBytes(numBytes);
        }
        this.outVariables = [];
        for (let i = 0; i < numBinds; i++) {
          const bindInfo = this.statement.bindInfoList[i];
          bindInfo.bindDir = buf.readUInt8();
          if (bindInfo.bindDir === constants.TNS_BIND_DIR_INPUT) {
            continue;
          }
          this.outVariables.push(bindInfo.bindVar);
        }
      }
      processColumnData(buf, variable) {
        const dbType = variable.type;
        const oraTypeNum = dbType._oraTypeNum;
        const csfrm = dbType._csfrm;
        const maxSize = variable.maxSize;
        let colValue = null;
        if (maxSize === 0 && oraTypeNum !== constants.TNS_DATA_TYPE_LONG && oraTypeNum !== constants.TNS_DATA_TYPE_LONG_RAW && oraTypeNum !== constants.TNS_DATA_TYPE_UROWID) {
          colValue = null;
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_VARCHAR || oraTypeNum === constants.TNS_DATA_TYPE_CHAR || oraTypeNum === constants.TNS_DATA_TYPE_LONG) {
          if (csfrm === constants.CSFRM_NCHAR) {
            buf.caps.checkNCharsetId();
          }
          colValue = buf.readStr(csfrm);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_RAW || oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW) {
          colValue = buf.readBytesWithLength();
          if (colValue !== null) {
            colValue = Buffer2.from(colValue);
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_NUMBER) {
          colValue = buf.readOracleNumber();
          if (!this.inFetch && colValue !== null)
            colValue = parseFloat(colValue);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_DATE || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_LTZ || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_TZ) {
          const useLocalTime = oraTypeNum === constants.TNS_DATA_TYPE_DATE || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP;
          colValue = buf.readOracleDate(useLocalTime);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_ROWID) {
          if (!this.inFetch) {
            colValue = buf.readStr(constants.CSFRM_IMPLICIT);
          } else {
            const numBytes = buf.readUInt8();
            if (isNullLength(numBytes)) {
              colValue = null;
            } else {
              const rowid = buf.readRowID();
              colValue = utils.encodeRowID(rowid);
            }
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_UROWID) {
          if (!this.inFetch) {
            colValue = buf.readStr(constants.CSFRM_IMPLICIT);
          } else {
            colValue = buf.readURowID();
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_DOUBLE) {
          colValue = buf.readBinaryDouble();
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_FLOAT) {
          colValue = buf.readBinaryFloat();
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_INTEGER) {
          colValue = buf.readOracleNumber();
          if (colValue !== null)
            colValue = parseFloat(colValue);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_CURSOR) {
          const numBytes = buf.readUInt8();
          if (isNullLength(numBytes)) {
            colValue = null;
          } else {
            colValue = this.createCursorFromDescribe(buf);
            colValue.statement.cursorId = buf.readUB2();
            if (colValue.statement.cursorId === 0 && variable.dir !== constants.BIND_IN) {
              if (this.options.nullifyInvalidCursor) {
                colValue = null;
              } else {
                errors.throwErr(errors.ERR_INVALID_REF_CURSOR);
              }
            }
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {
          colValue = buf.readBool();
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_INTERVAL_YM) {
          colValue = buf.readOracleIntervalYM();
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_INTERVAL_DS) {
          colValue = buf.readOracleIntervalDS();
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_CLOB || oraTypeNum === constants.TNS_DATA_TYPE_BLOB || oraTypeNum === constants.TNS_DATA_TYPE_BFILE) {
          let length = 0;
          let chunkSize = 0;
          const bvalue = buf.readUB4();
          if (bvalue > 0) {
            colValue = new ThinLobImpl();
            if (oraTypeNum !== constants.TNS_DATA_TYPE_BFILE) {
              length = buf.readUB8();
              chunkSize = buf.readUB4();
            }
            const locator = Buffer2.from(buf.readBytesWithLength());
            colValue.init(this.connection, locator, dbType, length, chunkSize);
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_JSON) {
          colValue = buf.readOson();
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_VECTOR) {
          colValue = buf.readVector();
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {
          const obj = buf.readDbObject();
          if (obj.packedData) {
            const objType = variable.fetchInfo ? variable.fetchInfo.dbTypeClass : variable.typeClass;
            if (variable.type === types.DB_TYPE_XMLTYPE) {
              colValue = readXML(this.connection, obj.packedData);
            } else {
              colValue = new ThinDbObjectImpl(objType, obj.packedData);
              colValue.toid = obj.toid;
              colValue.oid = obj.oid;
            }
          }
        } else {
          errors.throwErr(
            errors.ERR_UNSUPPORTED_DATA_TYPE,
            dbType.num,
            variable.columnNum
          );
        }
        if (!this.inFetch) {
          const actualNumBytes = buf.readSB4();
          if (actualNumBytes < 0 && oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {
            colValue = null;
          } else if (actualNumBytes !== 0 && colValue !== null && oraTypeNum !== constants.TNS_DATA_TYPE_INT_NAMED) {
            this.saveDeferredErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_LONG || oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW || variable.maxSize > buf.caps.maxStringSize) {
          buf.skipSB4();
          buf.skipUB4();
        }
        return colValue;
      }
      processReturnParameter(buf) {
        let keywordNum = 0;
        let keyTextValue;
        let numParams = buf.readUB2();
        for (let i = 0; i < numParams; i++) {
          buf.skipUB4();
        }
        let numBytes = buf.readUB2();
        if (numBytes > 0) {
          buf.skipBytes(numBytes);
        }
        numParams = buf.readUB2();
        for (let i = 0; i < numParams; i++) {
          numBytes = buf.readUB2();
          if (numBytes > 0) {
            keyTextValue = buf.readStr(constants.CSFRM_IMPLICIT);
          }
          numBytes = buf.readUB2();
          if (numBytes > 0) {
            buf.skipBytesChunked();
          }
          keywordNum = buf.readUB2();
          if (keywordNum === constants.TNS_KEYWORD_NUM_CURRENT_SCHEMA) {
            this.connection.currentSchema = keyTextValue;
          } else if (keywordNum === constants.TNS_KEYWORD_NUM_EDITION) {
            this.connection._edition = keyTextValue;
          }
        }
        numBytes = buf.readUB2();
        if (numBytes > 0) {
          buf.skip(numBytes);
        }
        if (this.arrayDmlRowCounts) {
          const numRows = buf.readUB4();
          const rowCounts = this.options.dmlRowCounts = [];
          for (let i = 0; i < numRows; i++) {
            const rowCount = buf.readUB8();
            rowCounts.push(rowCount);
          }
        }
      }
      async postProcess() {
        if (this.deferredErr) {
          throw this.deferredErr;
        }
        if (this.outVariables) {
          for (const variable of this.outVariables) {
            if (variable.isArray) {
              if (variable.outConverter) {
                for (let pos = 0; pos < variable.numElementsInArray; pos++) {
                  variable.values[0][pos] = await variable.outConverter(variable.values[0][pos]);
                }
              }
            } else {
              if (variable.outConverter) {
                variable.values[0] = await variable.outConverter(variable.values[0]);
              }
            }
          }
        }
        await this.connection._populatePartialDbObjectTypes();
        for (const resultSet of this.resultSetsToSetup) {
          resultSet._setup(this.options, resultSet.metaData);
          for (const variable of resultSet.statement.queryVars) {
            if (variable.type === types.DB_TYPE_CLOB || variable.type === types.DB_TYPE_NCLOB || variable.type === types.DB_TYPE_BLOB || variable.type === types.DB_TYPE_JSON || variable.type === types.DB_TYPE_VECTOR) {
              if (variable.type !== variable.fetchInfo.fetchType) {
                variable.type = variable.fetchInfo.fetchType;
                variable.maxSize = constants.TNS_MAX_LONG_LENGTH;
              }
              if (!resultSet.statement.noPrefetch) {
                resultSet.statement.requiresDefine = true;
                resultSet.statement.noPrefetch = true;
              }
            }
          }
        }
      }
      preProcess() {
        if (this.statement.isReturning && !this.parseOnly) {
          this.outVariables = [];
          for (const bindInfo of this.statement.bindInfoList) {
            if (bindInfo.isReturnBind) {
              this.outVariables.push(bindInfo.bindVar);
            }
          }
        }
        if (this.statement.isQuery) {
          this.inFetch = true;
          if (this.statement.queryVars) {
            this.outVariables = [];
            for (let i = 0; i < this.statement.queryVars.length; i++) {
              this.outVariables.push(this.statement.queryVars[i]);
            }
          }
        }
      }
      processBitVector(buf) {
        this.numColumnsSent = buf.readUB2();
        let numBytes = Math.floor(this.statement.numQueryVars / 8);
        if (this.statement.numQueryVars % 8 > 0) {
          numBytes += 1;
        }
        this.bitVector = Buffer2.from(buf.readBytes(numBytes));
      }
      processBindParams(buf, params) {
        const bindVars = [];
        const nonReturningParams = [];
        for (const bindInfo of params) {
          if (!bindInfo.isReturnBind) {
            nonReturningParams.push(bindInfo);
          }
          bindVars.push(bindInfo.bindVar);
        }
        this.writeColumnMetadata(buf, bindVars);
        return nonReturningParams;
      }
      writeColumnMetadata(buf, bindVars) {
        for (const variable of bindVars) {
          let oraTypeNum = variable.type._oraTypeNum;
          let maxSize = variable.maxSize || variable.type._bufferSizeFactor;
          let lobPrefetchLength = 0;
          if (variable.type._csfrm === constants.CSFRM_NCHAR) {
            maxSize = Math.min(maxSize * variable.type._bufferSizeFactor, constants.TNS_MAX_LONG_LENGTH);
          }
          if ([constants.TNS_DATA_TYPE_ROWID, constants.TNS_DATA_TYPE_UROWID].includes(oraTypeNum)) {
            oraTypeNum = constants.TNS_DATA_TYPE_VARCHAR;
            maxSize = constants.TNS_MAX_UROWID_LENGTH;
          }
          let flag = constants.TNS_BIND_USE_INDICATORS;
          if (variable.isArray) {
            flag |= constants.TNS_BIND_ARRAY;
          }
          let contFlag = 0;
          if (variable.type === types.DB_TYPE_BLOB || variable.type === types.DB_TYPE_CLOB || variable.type === types.DB_TYPE_NCLOB) {
            contFlag = constants.TNS_LOB_PREFETCH_FLAG;
          } else if (variable.type === types.DB_TYPE_JSON) {
            contFlag = constants.TNS_LOB_PREFETCH_FLAG;
            maxSize = lobPrefetchLength = constants.TNS_JSON_MAX_LENGTH;
          } else if (variable.type === types.DB_TYPE_VECTOR) {
            contFlag = constants.TNS_LOB_PREFETCH_FLAG;
            maxSize = lobPrefetchLength = constants.TNS_VECTOR_MAX_LENGTH;
          }
          buf.writeUInt8(oraTypeNum);
          buf.writeUInt8(flag);
          buf.writeUInt8(0);
          buf.writeUInt8(0);
          buf.writeUB4(maxSize);
          if (variable.isArray) {
            buf.writeUB4(variable.maxArraySize);
          } else {
            buf.writeUB4(0);
          }
          buf.writeUB4(contFlag);
          if (variable.objType) {
            const objType = variable.objType;
            buf.writeUB4(objType.oid.length);
            buf.writeBytesWithLength(objType.oid);
            buf.writeUB2(objType.version);
          } else {
            buf.writeUB4(0);
            buf.writeUB2(0);
          }
          if (variable.type._csfrm !== 0) {
            buf.writeUB2(constants.TNS_CHARSET_UTF8);
          } else {
            buf.writeUB2(0);
          }
          buf.writeUInt8(variable.type._csfrm);
          buf.writeUB4(lobPrefetchLength);
          if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {
            buf.writeUB4(0);
          }
        }
      }
      writeBindParamsRow(buf, params, pos) {
        const offset = this.offset;
        let foundLong = false;
        for (const bindInfo of params) {
          if (bindInfo.isReturnBind)
            continue;
          const variable = bindInfo.bindVar;
          if (variable.isArray) {
            const numElements = variable.values.length;
            buf.writeUB4(numElements);
            for (let i = 0; i < numElements; i++) {
              this.writeBindParamsColumn(buf, variable, variable.values[i]);
            }
          } else {
            if (!this.statement.isPlSql && variable.maxSize > buf.caps.maxStringSize) {
              foundLong = true;
            } else {
              this.writeBindParamsColumn(
                buf,
                variable,
                variable.values[pos + offset]
              );
            }
          }
        }
        if (foundLong) {
          for (const bindInfo of params) {
            if (bindInfo.isReturnBind)
              continue;
            const variable = bindInfo.bindVar;
            if (variable.maxSize > buf.caps.maxStringSize) {
              this.writeBindParamsColumn(buf, variable, variable.values[pos + offset]);
            }
          }
        }
      }
      writeBindParamsColumn(buf, variable, value) {
        const oraTypeNum = variable.type._oraTypeNum;
        let tempVal;
        if ((value === void 0 || value === null) && oraTypeNum !== constants.TNS_DATA_TYPE_CURSOR && oraTypeNum !== constants.TNS_DATA_TYPE_JSON) {
          if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {
            buf.writeUInt8(constants.TNS_ESCAPE_CHAR);
            buf.writeUInt8(1);
          } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {
            buf.writeUB4(0);
            buf.writeUB4(0);
            buf.writeUB4(0);
            buf.writeUB4(0);
            buf.writeUB4(0);
            buf.writeUB4(constants.TNS_OBJ_TOP_LEVEL);
          } else {
            buf.writeUInt8(0);
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_NUMBER || oraTypeNum === constants.TNS_DATA_TYPE_BINARY_INTEGER) {
          if (typeof value === "boolean") {
            tempVal = value ? "1" : "0";
          } else {
            tempVal = value.toString();
          }
          buf.writeOracleNumber(tempVal);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_VARCHAR || oraTypeNum === constants.TNS_DATA_TYPE_CHAR || oraTypeNum === constants.TNS_DATA_TYPE_LONG || oraTypeNum === constants.TNS_DATA_TYPE_RAW || oraTypeNum === constants.TNS_DATA_TYPE_LONG_RAW) {
          if (variable.type._csfrm === constants.CSFRM_NCHAR) {
            buf.caps.checkNCharsetId();
            value = Buffer2.from(value, constants.TNS_ENCODING_UTF16).swap16();
          } else {
            value = Buffer2.from(value);
          }
          buf.writeBytesWithLength(value);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_DATE || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_TZ || oraTypeNum === constants.TNS_DATA_TYPE_TIMESTAMP_LTZ) {
          buf.writeOracleDate(value, variable.type);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_DOUBLE) {
          buf.writeUInt8(8);
          buf.writeBinaryDouble(value);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_BINARY_FLOAT) {
          buf.writeUInt8(4);
          buf.writeBinaryFloat(value);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_CURSOR) {
          let cursor = value;
          if (!value) {
            cursor = this.connection._createResultSet();
          }
          if (cursor.statement.cursorId === 0) {
            buf.writeUInt8(1);
            buf.writeUInt8(0);
          } else {
            buf.writeUB4(1);
            buf.writeUB4(cursor.statement.cursorId);
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_BOOLEAN) {
          if (value) {
            buf.writeUInt8(2);
            buf.writeUInt16BE(257);
          } else {
            buf.writeUInt16BE(256);
          }
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_INTERVAL_YM) {
          buf.writeOracleIntervalYM(value);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_INTERVAL_DS) {
          buf.writeOracleIntervalDS(value);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_CLOB || oraTypeNum === constants.TNS_DATA_TYPE_BLOB || oraTypeNum === constants.TNS_DATA_TYPE_BFILE) {
          buf.writeUB4(value._locator.length);
          buf.writeBytesWithLength(value._locator);
        } else if ([constants.TNS_DATA_TYPE_ROWID, constants.TNS_DATA_TYPE_UROWID].includes(oraTypeNum)) {
          buf.writeBytesWithLength(Buffer2.from(value));
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_JSON) {
          buf.writeOson(value, this.connection._osonMaxFieldNameSize);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_VECTOR) {
          buf.writeVector(value);
        } else if (oraTypeNum === constants.TNS_DATA_TYPE_INT_NAMED) {
          buf.writeDbObject(value);
        } else {
          const message = `Binding data of type ${variable.type}`;
          errors.throwErr(errors.ERR_NOT_IMPLEMENTED, message);
        }
      }
      createCursorFromDescribe(buf) {
        const resultSet = this.connection._createResultSet(this.options);
        resultSet.options.moreRowsToFetch = true;
        resultSet.statement.isQuery = true;
        resultSet.statement.requiresFullExecute = true;
        this.processDescribeInfo(buf, resultSet);
        return resultSet;
      }
      processImplicitResultSet(buf) {
        this.options.implicitResultSet = [];
        const numResults = buf.readUB4();
        for (let i = 0; i < numResults; i++) {
          const numBytes = buf.readUInt8();
          buf.skipBytes(numBytes);
          const childResultSet = this.createCursorFromDescribe(buf);
          childResultSet.statement.cursorId = buf.readUB2();
          this.options.implicitResultSet.push(childResultSet);
        }
      }
    };
    var isNullLength = (len) => {
      return len === 0 || len === constants.TNS_NULL_LENGTH_INDICATOR;
    };
    module2.exports = MessageWithData;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/transactionSwitch.js
var require_transactionSwitch = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/transactionSwitch.js"(exports2, module2) {
    "use strict";
    var Message = require_base2();
    var constants = require_constants3();
    var errors = require_errors();
    var TransactionSwitchMessage = class extends Message {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_TPC_TXN_SWITCH;
        this.applicationValue = 0;
        this.internalName = connImpl.internalName;
        if (this.internalName) {
          this.internalName = Buffer.from(this.internalName);
        }
        this.externalName = connImpl.externalName;
        if (this.externalName) {
          this.externalName = Buffer.from(this.externalName);
        }
      }
      processReturnParameter(buf) {
        this.applicationValue = buf.readUB4();
        this.contextLen = buf.readUB2();
        if (this.contextLen > 0) {
          this.context = Buffer.from(buf.readBytes(this.contextLen));
        }
      }
      encode(buf) {
        if (this.connection._sessionlessData?.pending)
          errors.throwErr(errors.ERR_SESSIONLESS_ALREADY_ACTIVE);
        let xidBytes;
        if (this.xid) {
          xidBytes = Buffer.alloc(128);
          this.xid.globalTransactionId.copy(xidBytes);
          if (this.xid.branchQualifier)
            this.xid.branchQualifier.copy(
              xidBytes,
              this.xid.globalTransactionId.length
            );
        }
        this.writeFunctionHeader(buf);
        buf.writeUB4(this.operation);
        if (this.context) {
          buf.writeUInt8(1);
          buf.writeUB4(this.context.length);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        if (this.xid) {
          buf.writeUB4(this.xid.formatId);
          buf.writeUB4(this.xid.globalTransactionId.length);
          buf.writeUB4(this.xid.branchQualifier.length);
          buf.writeUInt8(1);
          buf.writeUB4(xidBytes.length);
        } else {
          buf.writeUB4(0);
          buf.writeUB4(0);
          buf.writeUB4(0);
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        buf.writeUB4(this.flags);
        buf.writeUB4(this.timeout ? this.timeout : 0);
        buf.writeUInt8(1);
        buf.writeUInt8(1);
        buf.writeUInt8(1);
        if (this.internalName) {
          buf.writeUInt8(1);
          buf.writeUB4(this.internalName.length);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        if (this.externalName) {
          buf.writeUInt8(1);
          buf.writeUB4(this.externalName.length);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        if (this.context) {
          buf.writeBytes(this.context);
        }
        if (this.xid) {
          buf.writeBytes(xidBytes);
        }
        buf.writeUB4(this.applicationValue);
        if (this.internalName) {
          buf.writeBytes(this.internalName);
        }
        if (this.externalName) {
          buf.writeBytes(this.externalName);
        }
      }
    };
    module2.exports = TransactionSwitchMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/execute.js
var require_execute = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/execute.js"(exports2, module2) {
    "use strict";
    var MessageWithData = require_withData();
    var constants = require_constants3();
    var errors = require_errors();
    var TransactionSwitchMessage = require_transactionSwitch();
    var ExecuteMessage = class extends MessageWithData {
      /**
       *
       * @param {object} statement
       * @param {object} options
       */
      constructor(connection, statement, options, resultSet) {
        super(connection, statement, options);
        if (!resultSet && statement.isQuery) {
          resultSet = connection._createResultSet(options, statement);
        }
        this.resultSet = resultSet;
        this.functionCode = constants.TNS_FUNC_EXECUTE;
        this.bindParams = void 0;
        this.currentRow = 0;
      }
      //-------------------------------------------------------------------------
      // writeReExecuteMessage()
      //
      // Write the message for a full execute.
      //-------------------------------------------------------------------------
      writeExecuteMessage(buf) {
        let options = 0;
        let dmlOptions = 0;
        let numParams = 0;
        let numIters = 1;
        const stmt = this.statement;
        const params = stmt.bindInfoList;
        if (this.noImplicitRelease) {
          dmlOptions |= constants.TNS_EXEC_OPTION_NO_IMPL_REL;
        }
        if (!stmt.requiresDefine && !this.parseOnly && params) {
          numParams = params.length;
        }
        if (stmt.requiresDefine) {
          options |= constants.TNS_EXEC_OPTION_DEFINE;
        } else if (!this.parseOnly && stmt.sql) {
          dmlOptions |= constants.TNS_EXEC_OPTION_IMPLICIT_RESULTSET;
          options |= constants.TNS_EXEC_OPTION_EXECUTE;
        }
        if (stmt.cursorId === 0 || stmt.isDdl) {
          options |= constants.TNS_EXEC_OPTION_PARSE;
        }
        if (stmt.isQuery) {
          if (this.parseOnly) {
            options |= constants.TNS_EXEC_OPTION_DESCRIBE;
          } else {
            if (stmt.cursorId === 0 || stmt.requiresDefine) {
              numIters = this.options.prefetchRows;
            } else {
              numIters = this.options.fetchArraySize;
            }
            if (numIters > 0 && !stmt.noPrefetch) {
              options |= constants.TNS_EXEC_OPTION_FETCH;
            }
          }
        }
        if (!stmt.isPlSql && !this.parseOnly) {
          options |= constants.TNS_EXEC_OPTION_NOT_PLSQL;
        } else if (stmt.isPlSql && numParams > 0) {
          options |= constants.TNS_EXEC_OPTION_PLSQL_BIND;
        }
        if (numParams > 0) {
          options |= constants.TNS_EXEC_OPTION_BIND;
        }
        if (this.batchErrors) {
          options |= constants.TNS_EXEC_OPTION_BATCH_ERRORS;
        }
        if (this.arrayDmlRowCounts) {
          dmlOptions |= constants.TNS_EXEC_OPTION_DML_ROWCOUNTS;
        }
        if (this.options.autoCommit) {
          options |= constants.TNS_EXEC_OPTION_COMMIT;
        }
        if (this.options.suspendOnSuccess) {
          this._handleSuspendSessionless();
        }
        this.writeFunctionHeader(buf);
        buf.writeUB4(options);
        buf.writeUB4(stmt.cursorId);
        if (stmt.cursorId === 0 || stmt.isDdl) {
          buf.writeUInt8(1);
          buf.writeUB4(stmt.sqlLength);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        buf.writeUInt8(1);
        buf.writeUB4(13);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUB4(numIters);
        buf.writeUB4(constants.TNS_MAX_LONG_LENGTH);
        if (numParams === 0) {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        } else {
          buf.writeUInt8(1);
          buf.writeUB4(numParams);
        }
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        if (stmt.requiresDefine) {
          buf.writeUInt8(1);
          buf.writeUB4(this.statement.queryVars.length);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUInt8(1);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        if (this.arrayDmlRowCounts) {
          buf.writeUInt8(1);
          buf.writeUB4(this.numExecs);
          buf.writeUInt8(1);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
          buf.writeUInt8(0);
        }
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {
          buf.writeUInt8(0);
          buf.writeUB4(0);
          buf.writeUInt8(0);
          buf.writeUB4(0);
          buf.writeUInt8(0);
          if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2_EXT1) {
            buf.writeUInt8(0);
            buf.writeUB4(0);
          }
        }
        if (stmt.cursorId === 0 || stmt.isDdl) {
          if (stmt.sql) {
            buf.writeBytesWithLength(stmt.sqlBytes);
            buf.writeUB4(1);
          } else {
            errors.throwErr(errors.ERR_INVALID_REF_CURSOR);
          }
        } else {
          buf.writeUB4(0);
        }
        if (stmt.isQuery) {
          if (stmt.cursorId === 0) {
            buf.writeUB4(0);
          } else {
            buf.writeUB4(numIters);
          }
        } else {
          buf.writeUB4(this.numExecs);
        }
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUB4(stmt.isQuery ? 1 : 0);
        buf.writeUB4(0);
        buf.writeUB4(dmlOptions);
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        if (stmt.requiresDefine) {
          this.writeColumnMetadata(buf, this.statement.queryVars);
        } else if (numParams > 0) {
          return this.processBindParams(buf, params);
        }
      }
      //-------------------------------------------------------------------------
      // writeReExecuteMessage()
      //
      // Write the message header for a re-execute and return the bind parameters.
      //-------------------------------------------------------------------------
      writeReExecuteMessage(buf) {
        const stmt = this.statement;
        let params = stmt.bindInfoList;
        let execFlag1 = 0, execFlag2 = 0, numIters;
        if (params !== void 0) {
          if (!stmt.isQuery) {
            this.outVariables = [];
            params.forEach((info) => {
              if (info.bindDir !== constants.TNS_BIND_DIR_INPUT) {
                this.outVariables.push(info.bindVar);
              }
            });
          }
          const tmpparams = [];
          params.forEach((info) => {
            if (info.bindDir !== constants.TNS_BIND_DIR_OUTPUT && !info.isReturnBind) {
              tmpparams.push(info);
            }
          });
          params = tmpparams;
        }
        if (this.functionCode === constants.TNS_FUNC_REEXECUTE_AND_FETCH) {
          execFlag1 |= constants.TNS_EXEC_OPTION_EXECUTE;
          numIters = this.options.prefetchRows;
        } else {
          if (this.options.autoCommit) {
            execFlag2 |= constants.TNS_EXEC_OPTION_COMMIT_REEXECUTE;
          }
          numIters = this.numExecs;
        }
        if (this.options.suspendOnSuccess) {
          this._handleSuspendSessionless();
        }
        this.writeFunctionHeader(buf);
        buf.writeUB4(stmt.cursorId);
        buf.writeUB4(numIters);
        buf.writeUB4(execFlag1);
        buf.writeUB4(execFlag2);
        return params;
      }
      //-------------------------------------------------------------------------
      // _handleSuspendSessionless()
      //
      // Suspend the active sessionless transaction after DML execution if
      // suspendOnSuccess option was given to execute()
      //-------------------------------------------------------------------------
      _handleSuspendSessionless() {
        const sessionlessData = this.connection._sessionlessData;
        this.connection._validateSessionlessState();
        if (!sessionlessData)
          errors.throwErr(errors.ERR_SESSIONLESS_INACTIVE);
        if (sessionlessData.piggyback) {
          sessionlessData.piggyback.operation |= constants.TNS_TPC_TXN_POST_DETACH;
        } else {
          const message = new TransactionSwitchMessage(this.connection);
          message.operation = constants.TNS_TPC_TXN_POST_DETACH;
          message.flags = constants.TNS_TPC_TRANS_SESSIONLESS;
          message.messageType = constants.TNS_MSG_TYPE_PIGGYBACK;
          sessionlessData.piggyback = message;
          sessionlessData.pending = true;
        }
      }
      //-------------------------------------------------------------------------
      // encode()
      //
      // Write the execute message to the buffer. Two types of execute messages
      // are possible: one for a full execute and the second, simpler message,
      // for when an existing cursor is being re-executed.
      //-------------------------------------------------------------------------
      encode(buf) {
        if (this.currentRow === 0) {
          const stmt = this.statement;
          if (stmt.cursorId !== 0 && !stmt.requiresFullExecute && !this.parseOnly && !stmt.requiresDefine && !stmt.noPrefetch && !stmt.isDdl && !this.batchErrors) {
            if (stmt.isQuery && this.options.prefetchRows > 0) {
              this.functionCode = constants.TNS_FUNC_REEXECUTE_AND_FETCH;
            } else {
              this.functionCode = constants.TNS_FUNC_REEXECUTE;
            }
            this.bindParams = this.writeReExecuteMessage(buf);
          } else {
            this.functionCode = constants.TNS_FUNC_EXECUTE;
            this.bindParams = this.writeExecuteMessage(buf);
          }
        }
        if (this.bindParams && this.bindParams.length > 0) {
          const adapter = buf.nsi.ntAdapter;
          while (this.currentRow < this.numExecs) {
            buf.writeUInt8(constants.TNS_MSG_TYPE_ROW_DATA);
            this.writeBindParamsRow(buf, this.bindParams, this.currentRow);
            this.currentRow++;
            if (this.currentRow < this.numExecs && adapter.shouldPauseWrite())
              return true;
          }
        }
        this.currentRow = 0;
        this.bindParams = void 0;
      }
    };
    module2.exports = ExecuteMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/fetch.js
var require_fetch = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/fetch.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var MessageWithData = require_withData();
    var errors = require_errors();
    var FetchMessage = class extends MessageWithData {
      constructor(connection, statement, options, resultSet) {
        super(connection, statement, options);
        this.resultSet = resultSet;
        this.functionCode = constants.TNS_FUNC_FETCH;
      }
      //-------------------------------------------------------------------------
      // encode()
      //
      // Write the cursor ID and the number of rows to be fetched in the
      // Fetch Message RPC
      //-------------------------------------------------------------------------
      encode(buf) {
        this.writeFunctionHeader(buf);
        if (this.statement.cursorId === 0) {
          errors.throwErr(errors.ERR_CURSOR_HAS_BEEN_CLOSED);
        }
        buf.writeUB4(this.statement.cursorId);
        buf.writeUB4(this.options.fetchArraySize);
      }
    };
    module2.exports = FetchMessage;
  }
});

// node_modules/oracledb/lib/thin/resultSet.js
var require_resultSet = __commonJS({
  "node_modules/oracledb/lib/thin/resultSet.js"(exports2, module2) {
    "use strict";
    var ResultSetImpl = require_resultset();
    var ExecuteMessage = require_execute();
    var FetchMessage = require_fetch();
    var ThinResultSetImpl = class extends ResultSetImpl {
      //---------------------------------------------------------------------------
      // _fetchMoreRows()
      //
      // Fetches more rows from the database. This is done by means of the full
      // OAL8 RPC if needed; otherwise, the simpler OFETCH RPC is used.
      //---------------------------------------------------------------------------
      async _fetchMoreRows(options) {
        const cls = this.statement.requiresFullExecute ? ExecuteMessage : FetchMessage;
        const message = new cls(this.connection, this.statement, options, this);
        await this.connection._protocol._processMessage(message);
        this.statement.requiresFullExecute = false;
      }
      //---------------------------------------------------------------------------
      // Set the metadata info for a new resultSet object
      //---------------------------------------------------------------------------
      _resultSetNew(connection, statement, options) {
        this.connection = connection;
        this.statement = statement;
        this._nestedCursorIndices = [];
        this.options = options;
        this.prefetchRowsProcessed = false;
        this.statement.bufferRowIndex = 0;
      }
      //---------------------------------------------------------------------------
      // Returns the statement to cache so that it can be used later
      //---------------------------------------------------------------------------
      close() {
        this.connection._returnStatement(this.statement);
      }
      //---------------------------------------------------------------------------
      // Returns rows fetched to the common layer in array format
      //---------------------------------------------------------------------------
      _processRows(numRowsFetched) {
        const rows = [];
        const bufferRowIndex = this.statement.bufferRowIndex;
        for (let row = bufferRowIndex; row < bufferRowIndex + numRowsFetched; row++) {
          const rowObj = [];
          for (let col = 0; col < this.statement.numQueryVars; col++) {
            rowObj.push(this.statement.queryVars[col].values[row]);
          }
          rows.push(rowObj);
        }
        this.statement.bufferRowIndex += numRowsFetched;
        if (this.statement.bufferRowIndex === this.statement.bufferRowCount) {
          this.statement.bufferRowCount = 0;
          this.statement.bufferRowIndex = 0;
        }
        return rows;
      }
      //---------------------------------------------------------------------------
      // getRows()
      //
      // Fetches the specified number of rows from the database and returns them to
      // the common layer for processing.
      //---------------------------------------------------------------------------
      async getRows(numRows, options) {
        options.fetchArraySize = numRows || this.options.fetchArraySize;
        options.prefetchRows = this.options.prefetchRows;
        if (this.statement.bufferRowCount - this.statement.bufferRowIndex >= options.fetchArraySize) {
          return this._processRows(options.fetchArraySize);
        } else {
          options.fetchArraySize = options.fetchArraySize - (this.statement.bufferRowCount - this.statement.bufferRowIndex);
          const prevBufferRowCount = this.statement.bufferRowCount;
          if (this.statement.moreRowsToFetch && options.fetchArraySize > 0) {
            await this._fetchMoreRows(options);
          }
          options.fetchArraySize = numRows || this.options.fetchArraySize;
          if (prevBufferRowCount === this.statement.bufferRowCount) {
            const numRowsFetched2 = this.statement.bufferRowCount - this.statement.bufferRowIndex;
            this.statement.bufferRowCount = 0;
            if (numRowsFetched2 > 0) {
              return this._processRows(numRowsFetched2);
            }
            return [];
          }
        }
        const numRowsFetched = this.statement.bufferRowCount - this.statement.bufferRowIndex;
        return this._processRows(numRowsFetched);
      }
    };
    module2.exports = ThinResultSetImpl;
  }
});

// node_modules/oracledb/lib/thin/protocol/capabilities.js
var require_capabilities = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/capabilities.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants3();
    var errors = require_errors();
    var Capabilities = class {
      constructor(nscon) {
        this.protocolVersion = nscon.sAtts.version;
        this.ttcFieldVersion = constants.TNS_CCAP_FIELD_VERSION_MAX;
        this.supports12cLogon = true;
        this.supportsOob = false;
        this.nCharsetId = constants.TNS_CHARSET_UTF16;
        this.compileCaps = Buffer2.alloc(constants.TNS_CCAP_MAX);
        this.runtimeCaps = Buffer2.alloc(constants.TNS_RCAP_MAX);
        this.initCompileCaps(nscon);
        this.initRuntimeCaps();
        this.maxStringSize = 0;
      }
      adjustForServerCompileCaps(serverCaps, nscon) {
        if (serverCaps[constants.TNS_CCAP_FIELD_VERSION] < this.ttcFieldVersion) {
          this.ttcFieldVersion = serverCaps[constants.TNS_CCAP_FIELD_VERSION];
          this.compileCaps[constants.TNS_CCAP_FIELD_VERSION] = this.ttcFieldVersion;
        }
        if (this.ttcFieldVersion < constants.TNS_CCAP_FIELD_VERSION_23_4 && nscon.endOfRequestSupport) {
          this.compileCaps[constants.TNS_CCAP_TTC4] ^= constants.TNS_CCAP_END_OF_REQUEST;
          nscon.endOfRequestSupport = false;
        }
      }
      adjustForServerRuntimeCaps(serverCaps) {
        if (serverCaps[constants.TNS_RCAP_TTC] & constants.TNS_RCAP_TTC_32K) {
          this.maxStringSize = 32767;
        } else {
          this.maxStringSize = 4e3;
        }
      }
      initCompileCaps(nscon) {
        this.compileCaps[constants.TNS_CCAP_SQL_VERSION] = constants.TNS_CCAP_SQL_VERSION_MAX;
        this.compileCaps[constants.TNS_CCAP_LOGON_TYPES] = constants.TNS_CCAP_O5LOGON | constants.TNS_CCAP_O5LOGON_NP | constants.TNS_CCAP_O7LOGON | constants.TNS_CCAP_O8LOGON_LONG_IDENTIFIER | constants.TNS_CCAP_O9LOGON_LONG_PASSWORD;
        this.compileCaps[constants.TNS_CCAP_FIELD_VERSION] = this.ttcFieldVersion;
        this.compileCaps[constants.TNS_CCAP_SERVER_DEFINE_CONV] = 1;
        this.compileCaps[constants.TNS_CCAP_DEQUEUE_WITH_SELECTOR] = 1;
        this.compileCaps[constants.TNS_CCAP_TTC1] = constants.TNS_CCAP_FAST_BVEC | constants.TNS_CCAP_END_OF_CALL_STATUS | constants.TNS_CCAP_IND_RCD;
        this.compileCaps[constants.TNS_CCAP_OCI1] = constants.TNS_CCAP_FAST_SESSION_PROPAGATE | constants.TNS_CCAP_APP_CTX_PIGGYBACK;
        this.compileCaps[constants.TNS_CCAP_TDS_VERSION] = constants.TNS_CCAP_TDS_VERSION_MAX;
        this.compileCaps[constants.TNS_CCAP_RPC_VERSION] = constants.TNS_CCAP_RPC_VERSION_MAX;
        this.compileCaps[constants.TNS_CCAP_RPC_SIG] = constants.TNS_CCAP_RPC_SIG_VALUE;
        this.compileCaps[constants.TNS_CCAP_DBF_VERSION] = constants.TNS_CCAP_DBF_VERSION_MAX;
        this.compileCaps[constants.TNS_CCAP_LOB] = constants.TNS_CCAP_LOB_UB8_SIZE | constants.TNS_CCAP_LOB_ENCS | constants.TNS_CCAP_LOB_PREFETCH | constants.TNS_CCAP_LOB_TEMP_SIZE | constants.TNS_CCAP_LOB_12C | constants.TNS_CCAP_LOB_PREFETCH_DATA;
        this.compileCaps[constants.TNS_CCAP_UB2_DTY] = 1;
        this.compileCaps[constants.TNS_CCAP_LOB2] = constants.TNS_CCAP_LOB2_QUASI | constants.TNS_CCAP_LOB2_2GB_PREFETCH;
        this.compileCaps[constants.TNS_CCAP_TTC3] = constants.TNS_CCAP_IMPLICIT_RESULTS | constants.TNS_CCAP_BIG_CHUNK_CLR | constants.TNS_CCAP_KEEP_OUT_ORDER | constants.TNS_CCAP_LTXID;
        this.compileCaps[constants.TNS_CCAP_OCI3] = constants.TNS_CCAP_OCI3_OCSSYNC;
        this.compileCaps[constants.TNS_CCAP_TTC2] = constants.TNS_CCAP_ZLNP;
        this.compileCaps[constants.TNS_CCAP_OCI2] = constants.TNS_CCAP_DRCP;
        this.compileCaps[constants.TNS_CCAP_CLIENT_FN] = constants.TNS_CCAP_CLIENT_FN_MAX;
        this.compileCaps[constants.TNS_CCAP_SESS_SIGNATURE_VERSION] = constants.TNS_CCAP_FIELD_VERSION_12_2;
        this.compileCaps[constants.TNS_CCAP_TTC4] = constants.TNS_CCAP_INBAND_NOTIFICATION;
        if (nscon.endOfRequestSupport) {
          this.compileCaps[constants.TNS_CCAP_TTC4] |= constants.TNS_CCAP_END_OF_REQUEST;
        }
        this.compileCaps[constants.TNS_CCAP_CTB_FEATURE_BACKPORT] = constants.TNS_CCAP_CTB_IMPLICIT_POOL | constants.TNS_CCAP_CTB_OAUTH_MSG_ON_ERR;
        this.compileCaps[constants.TNS_CCAP_TTC5] = constants.TNS_CCAP_VECTOR_SUPPORT | constants.TNS_CCAP_TTC5_SESSIONLESS_TXNS;
        this.compileCaps[constants.TNS_CCAP_VECTOR_FEATURES] = constants.TNS_CCAP_VECTOR_FEATURE_BINARY | constants.TNS_CCAP_VECTOR_FEATURE_SPARSE;
      }
      initRuntimeCaps() {
        this.runtimeCaps[constants.TNS_RCAP_COMPAT] = constants.TNS_RCAP_COMPAT_81;
        this.runtimeCaps[constants.TNS_RCAP_TTC] = constants.TNS_RCAP_TTC_ZERO_COPY | constants.TNS_RCAP_TTC_32K;
      }
      checkNCharsetId() {
        if (this.nCharsetId !== constants.TNS_CHARSET_UTF16) {
          errors.throwErr(errors.ERR_NCHAR_CS_NOT_SUPPORTED, this.nCharsetId);
        }
      }
    };
    module2.exports = Capabilities;
  }
});

// node_modules/oracledb/lib/thin/protocol/packet.js
var require_packet = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/packet.js"(exports2, module2) {
    "use strict";
    var { BaseBuffer } = require_buffer();
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants3();
    var oson = require_oson();
    var utils = require_utils();
    var vector = require_vector();
    var errors = require_errors();
    var TNS_BASE64_ALPHABET_ARRAY = Buffer2.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "utf8");
    var FAST_AUTH_END_OF_RPC_VALUE = 2048;
    var FAST_AUTH_END_OF_RPC_OFFSET = 8;
    var MSG_TYPE_OFFSET = 11;
    var BytesChunk = class {
      /**
       * Constructor.
       * @param {Number} number of bytes to add to the chunk (rounded to the
       * nearest chunk size to avoid unnecessary allocations and copies)
       */
      constructor(numBytes) {
        this.allocLen = numBytes;
        const remainder = numBytes % constants.CHUNKED_BYTES_CHUNK_SIZE;
        if (remainder > 0) {
          this.allocLen += constants.CHUNKED_BYTES_CHUNK_SIZE - remainder;
        }
        this.buf = Buffer2.allocUnsafe(this.allocLen);
        this.actualLen = 0;
      }
    };
    var ChunkedBytesBuffer = class {
      /**
       * Constructor.
       */
      constructor() {
        this.chunks = [];
      }
      /**
       * End the chunked read and return a consolidated buffer.
       */
      endChunkedRead() {
        if (this.chunks.length > 1) {
          let totalNumBytes = 0;
          for (const chunk2 of this.chunks) {
            totalNumBytes += chunk2.actualLen;
          }
          let pos = 0;
          const consolidatedChunk = new BytesChunk(totalNumBytes);
          for (const chunk2 of this.chunks) {
            chunk2.buf.copy(consolidatedChunk.buf, pos, 0, chunk2.actualLen);
            pos += chunk2.actualLen;
          }
          consolidatedChunk.actualLen = totalNumBytes;
          this.chunks = [consolidatedChunk];
        }
        const chunk = this.chunks[0];
        return chunk.buf.subarray(0, chunk.actualLen);
      }
      /**
       * Constructor.
       */
      getBuf(numBytes) {
        let chunk;
        if (this.chunks.length > 0) {
          chunk = this.chunks[this.chunks.length - 1];
          if (chunk.allocLen - chunk.actualLen < numBytes) {
            chunk = void 0;
          }
        }
        if (!chunk) {
          chunk = new BytesChunk(numBytes);
          this.chunks.push(chunk);
        }
        const buf = chunk.buf.subarray(
          chunk.actualLen,
          chunk.actualLen + numBytes
        );
        chunk.actualLen += numBytes;
        return buf;
      }
      /**
       * Start a chunked read. This ensures that only one chunk is available and
       * its actual length is set to zero.
       */
      startChunkedRead() {
        if (this.chunks.length > 0) {
          this.chunks = this.chunks.splice(0, 1);
          this.chunks[0].actualLen = 0;
        }
      }
    };
    var ReadPacket = class extends BaseBuffer {
      /**
       * Constructor.
       * @param {Object} adapter used for sending/receiving data
       * @param {Object} capabilities
       */
      constructor(nsi, caps) {
        super();
        this.nsi = nsi;
        this.caps = caps;
        this.chunkedBytesBuf = new ChunkedBytesBuffer();
      }
      /**
       * Helper function that processes the length. If the length is defined as
       * TNS_LONG_LENGTH_INDICATOR, a chunked read is performed.
       */
      _readBytesWithLength(numBytes) {
        if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {
          return this.readBytes(numBytes);
        }
        this.chunkedBytesBuf.startChunkedRead();
        while (true) {
          const numBytesInChunk = this.readUB4();
          if (numBytesInChunk === 0) {
            break;
          }
          this.readBytes(numBytesInChunk, true);
        }
        return this.chunkedBytesBuf.endChunkedRead();
      }
      skipBytes(numBytes) {
        if (this.pos === this.size) {
          this.receivePacket();
        }
        const numBytesLeft = this.numBytesLeft();
        if (numBytes <= numBytesLeft) {
          this.pos += numBytes;
          return;
        }
        numBytes -= numBytesLeft;
        while (numBytes > 0) {
          this.receivePacket();
          const numSplitBytes = Math.min(numBytes, this.size - this.pos);
          this.pos += numSplitBytes;
          numBytes -= numSplitBytes;
        }
      }
      /**
       * Returns a buffer containing the specified number of bytes. If an
       * insufficient number of bytes are available, a new packet is read.
       * @param {Number} specifies the number of bytes to read from the buffer
       */
      readBytes(numBytes, inChunkedRead = false) {
        if (this.pos === this.size) {
          this.receivePacket();
        }
        const numBytesLeft = this.numBytesLeft();
        if (numBytes <= numBytesLeft) {
          let buf2;
          if (inChunkedRead) {
            buf2 = this.chunkedBytesBuf.getBuf(numBytes);
            this.buf.copy(buf2, 0, this.pos, this.pos + numBytes);
          } else {
            buf2 = this.buf.subarray(this.pos, this.pos + numBytes);
          }
          this.pos += numBytes;
          return buf2;
        }
        let buf;
        if (inChunkedRead) {
          buf = this.chunkedBytesBuf.getBuf(numBytes);
        } else {
          buf = Buffer2.allocUnsafe(numBytes);
        }
        let offset = 0;
        this.buf.copy(buf, offset, this.pos, this.pos + numBytesLeft);
        offset += numBytesLeft;
        numBytes -= numBytesLeft;
        while (numBytes > 0) {
          this.receivePacket();
          const numSplitBytes = Math.min(numBytes, this.size - this.pos);
          this.buf.copy(buf, offset, this.pos, this.pos + numSplitBytes);
          this.pos += numSplitBytes;
          offset += numSplitBytes;
          numBytes -= numSplitBytes;
        }
        return buf;
      }
      /**
       * Receives a packet from the adapter.
       */
      receivePacket() {
        if (this.savedPacketPos === this.savedPackets.length) {
          const packet = this.nsi.syncRecvPacket();
          if (!packet || this.nsi.isBreak)
            throw new utils.OutOfPacketsError();
          this.savedPackets.push(packet);
        }
        this.startPacket(this.savedPackets[this.savedPacketPos++]);
      }
      restorePoint() {
        this.savedPacketPos = 0;
        this.startPacket(this.savedPackets[this.savedPacketPos++]);
        this.pos = this.savedPos;
      }
      savePoint() {
        if (this.savedPackets) {
          this.savedPackets = this.savedPackets.splice(this.savedPacketPos - 1);
        } else {
          this.savedPackets = [this.packet];
        }
        this.savedPacketPos = 1;
        this.savedPos = this.pos;
      }
      startPacket(packet) {
        this.packet = packet;
        this.buf = packet.buf;
        this.pos = 10;
        this.size = packet.buf.length;
        this.packetNum = packet.num;
      }
      /**
       * Read packets from network.
       * If checkRequestBoundary is passed as true, it
       * would read all packets until end of request
       * boundary is seen in nwk header.
       */
      async waitForPackets(checkRequestBoundary = false) {
        let packet = await this.nsi.recvPacket();
        if (!this.savedPackets) {
          this.savedPackets = [packet];
          this.savedPacketPos = 0;
        } else {
          this.savedPackets.push(packet);
        }
        if (checkRequestBoundary && this.nsi.endOfRequestSupport) {
          while (packet.type === constants.TNS_PACKET_TYPE_DATA) {
            if (packet.buf.readUInt16BE(8) & constants.TNS_DATA_FLAGS_END_OF_REQUEST) {
              break;
            }
            if (packet.buf.length === MSG_TYPE_OFFSET && packet.buf[MSG_TYPE_OFFSET - 1] === constants.TNS_MSG_TYPE_END_OF_REQUEST) {
              break;
            }
            packet = await this.nsi.recvPacket();
            this.savedPackets.push(packet);
          }
        }
        this.startPacket(this.savedPackets[this.savedPacketPos++]);
      }
      /**
       * Reads OSON (QLocator followed by data) and decodes it into a JavaScript
       * object.
       */
      readOson() {
        const numBytes = this.readUB4();
        if (numBytes === 0) {
          return null;
        }
        this.skipUB8();
        this.skipUB4();
        const decoder = new oson.OsonDecoder(this.readBytesWithLength());
        this.skipBytesChunked();
        return decoder.decode();
      }
      readURowID() {
        let outputOffset = 0, inputOffset = 1;
        let buf = this.readBytesWithLength();
        if (buf === null)
          return null;
        buf = this.readBytesWithLength();
        let inputLen = buf.length;
        if (buf && buf[0] === 1) {
          const rba = buf.readUInt32BE(1);
          const partitionID = buf.readUInt16BE(5);
          const blockNum = buf.readUInt32BE(7);
          const slotNum = buf.readUInt16BE(11);
          return utils.encodeRowID({ rba, partitionID, blockNum, slotNum });
        }
        let outputLen = Math.floor(inputLen / 3) * 4;
        const remainder = inputLen % 3;
        if (remainder === 1) {
          outputLen += 1;
        } else if (remainder === 2) {
          outputLen += 3;
        }
        const outputValue = Buffer2.allocUnsafe(outputLen);
        inputLen -= 1;
        outputValue[0] = 42;
        outputOffset += 1;
        while (inputLen > 0) {
          let pos = buf[inputOffset] >> 2;
          outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];
          outputOffset += 1;
          pos = (buf[inputOffset] & 3) << 4;
          if (inputLen == 1) {
            outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];
            break;
          }
          inputOffset += 1;
          pos |= (buf[inputOffset] & 240) >> 4;
          outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];
          outputOffset += 1;
          pos = (buf[inputOffset] & 15) << 2;
          if (inputLen == 2) {
            outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];
            break;
          }
          inputOffset += 1;
          pos |= (buf[inputOffset] & 192) >> 6;
          outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];
          outputOffset += 1;
          pos = buf[inputOffset] & 63;
          outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];
          outputOffset += 1;
          inputOffset += 1;
          inputLen -= 3;
        }
        return outputValue.toString("utf-8");
      }
      readRowID() {
        const rba = this.readUB4();
        const partitionID = this.readUB2();
        this.skipUB1();
        const blockNum = this.readUB4();
        const slotNum = this.readUB2();
        return { rba, partitionID, blockNum, slotNum };
      }
      /**
       * Reads VECTOR data (QLocator followed by data) and decodes it into a
       * JavaScript object.
       */
      readVector() {
        const numBytes = this.readUB4();
        if (numBytes === 0) {
          return null;
        }
        this.skipUB8();
        this.skipUB4();
        const decoder = new vector.VectorDecoder(this.readBytesWithLength());
        this.skipBytesChunked();
        return decoder.decode();
      }
      skipBytesChunked() {
        const numBytes = this.readUInt8();
        if (numBytes === 0 || numBytes === constants.TNS_NULL_LENGTH_INDICATOR) {
          return;
        }
        if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {
          this.skipBytes(numBytes);
        } else {
          while (true) {
            const tempNumBytes = this.readUB4();
            if (tempNumBytes === 0)
              break;
            this.skipBytes(tempNumBytes);
          }
        }
      }
      readNullTerminatedBytes(maxSize = 50) {
        let offset = 0;
        const tmp = Buffer2.allocUnsafe(maxSize);
        while (offset < maxSize) {
          tmp[offset] = this.readUInt8();
          if (tmp[offset] === 0) {
            break;
          }
          offset = offset + 1;
        }
        if (offset === maxSize) {
          const reason = `Byte Arrray Exceeded MaxSize ${maxSize}`;
          errors.throwErr(errors.ERR_INTERNAL, reason);
        }
        return tmp.subarray(0, offset + 1);
      }
    };
    var WritePacket = class extends BaseBuffer {
      constructor(nsi, caps, protocol) {
        super(nsi.sAtts.sdu);
        this.size = this.maxSize;
        this.isLargeSDU = nsi.sAtts.version >= constants.TNS_VERSION_MIN_LARGE_SDU;
        this.protocol = protocol;
        this.packetType = constants.TNS_PACKET_TYPE_DATA;
        this.caps = caps;
        this.nsi = nsi;
      }
      /**
       * Grows the buffer by sending the existing buffer on the transport. A copy
       * is made so that the existing buffer can be used for the next batch of data
       * that needs to be sent
       */
      _grow() {
        this._sendPacket();
      }
      /**
       * Sends the data in the buffer on the transport. First, the packet header is
       * set up by writing the size and packet type.
       */
      _sendPacket(finalPacket = false) {
        const size = this.pos;
        this.pos = 0;
        if (this.isLargeSDU) {
          this.writeUInt32BE(size);
        } else {
          this.writeUInt16BE(size);
          this.writeUInt16BE(0);
        }
        this.writeUInt8(this.packetType);
        this.writeUInt8(0);
        this.writeUInt16BE(0);
        let buf = this.buf.subarray(0, size);
        if (!finalPacket) {
          buf = Buffer2.from(buf);
          this.startPacket();
        } else {
          this.buf.writeUInt16BE(
            FAST_AUTH_END_OF_RPC_VALUE,
            FAST_AUTH_END_OF_RPC_OFFSET
          );
        }
        if (!this.nsi.ntAdapter) {
          errors.throwErr(errors.ERR_INVALID_CONNECTION);
        }
        this.nsi.sendPacket(buf);
      }
      /**
       * Starts a packet.
       */
      startPacket(dataFlags = 0) {
        this.pos = constants.PACKET_HEADER_SIZE;
        if (this.packetType === constants.TNS_PACKET_TYPE_DATA) {
          this.writeUInt16BE(dataFlags);
        }
      }
      /**
       * Starts a database request.
       */
      startRequest(packetType, dataFlags = 0) {
        this.packetType = packetType;
        this.startPacket(dataFlags);
      }
      /**
       * Ends a database request.
       */
      endRequest() {
        if (this.pos > constants.PACKET_HEADER_SIZE) {
          this._sendPacket(true);
        }
      }
      writeKeyValue(key, value, flags = 0) {
        const keyBytesLen = Buffer2.byteLength(key);
        const valBytesLen = Buffer2.byteLength(value);
        this.writeUB4(keyBytesLen);
        this.writeBytesWithLength(Buffer2.from(key));
        this.writeUB4(valBytesLen);
        if (valBytesLen > 0) {
          this.writeBytesWithLength(Buffer2.from(value));
        }
        this.writeUB4(flags);
      }
      /**
       * Encodes a JavaScript object into OSON and then writes it (QLocator
       * followed by data) to the buffer.
       */
      writeOson(value, osonMaxFieldSize, writeLength = true) {
        const encoder = new oson.OsonEncoder();
        const buf = encoder.encode(value, osonMaxFieldSize);
        this.writeQLocator(buf.length, writeLength);
        this.writeBytesWithLength(buf);
      }
      writeSeqNum() {
        this.writeUInt8(this.protocol.sequenceId);
        this.protocol.sequenceId = (this.protocol.sequenceId + 1) % 256;
      }
      /**
       * Encodes a JavaScript object into VECTOR data and then writes it (QLocator
       * followed by data) to the buffer.
       */
      writeVector(value) {
        const encoder = new vector.VectorEncoder();
        const buf = encoder.encode(value);
        this.writeQLocator(buf.length);
        this.writeBytesWithLength(buf);
      }
      //---------------------------------------------------------------------------
      // writeQLocator()
      //
      // Writes a QLocator. QLocators are always 40 bytes in length.
      //---------------------------------------------------------------------------
      writeQLocator(numBytes, writeLength = true) {
        this.writeUB4(40);
        if (writeLength)
          this.writeUInt8(40);
        this.writeUInt16BE(38);
        this.writeUInt16BE(constants.TNS_LOB_QLOCATOR_VERSION);
        this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_VALUE_BASED | constants.TNS_LOB_LOC_FLAGS_BLOB | constants.TNS_LOB_LOC_FLAGS_ABSTRACT);
        this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_INIT);
        this.writeUInt16BE(0);
        this.writeUInt16BE(1);
        this.writeUInt64BE(numBytes);
        this.writeUInt16BE(0);
        this.writeUInt16BE(0);
        this.writeUInt16BE(0);
        this.writeUInt64BE(0);
        this.writeUInt64BE(0);
      }
    };
    module2.exports = {
      ReadPacket,
      WritePacket
    };
  }
});

// node_modules/oracledb/lib/thin/protocol/protocol.js
var require_protocol = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/protocol.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var Capabilities = require_capabilities();
    var { WritePacket, ReadPacket } = require_packet();
    var errors = require_errors();
    var utils = require_utils();
    var traceHandler = require_traceHandler();
    var Protocol = class {
      constructor(conn) {
        this._breakInProgress = false;
        this.txnInProgress = false;
        this.connInProgress = true;
        this.nsi = conn.nscon;
        this.sequenceId = 1;
        this.caps = new Capabilities(conn.nscon);
        this.writeBuf = new WritePacket(conn.nscon, this.caps, this);
        this.readBuf = new ReadPacket(conn.nscon, this.caps);
        this.callTimeout = 0;
      }
      /**
       * Decodes the message returned by the database. A message may consist of
       * multiple packets. Not all packets may be available so if insufficient
       * packets are available, the message decode function is expected to return
       * the value true if more data is expected to follow.
       *
       * If that occurs, waiting occurs until more packets arrive.
       *
       * @param {object} message: the RPC dynamic structure specific to the RPC
       */
      async _decodeMessage(message) {
        message.preProcess();
        await this.readBuf.waitForPackets(true);
        while (true) {
          if (this.nsi.isBreak) {
            await this.resetMessage();
            delete this.readBuf.savedPackets;
            await this.readBuf.waitForPackets();
          }
          try {
            message.decode(this.readBuf);
            break;
          } catch (err) {
            if (err instanceof utils.OutOfPacketsError) {
              if (!this.nsi.isBreak) {
                await this.readBuf.waitForPackets();
                this.readBuf.restorePoint();
              }
              continue;
            }
            throw err;
          }
        }
        await message.postProcess();
      }
      /**
       * Encodes the message to be sent to the database. A message may be encoded
       * in multiple packets. In order to facilitate encoding of very large
       * messages consisting of a large number of packets, the message encode
       * function is expected to return the value true if more data is to follow.
       *
       * If that occurs, waiting occurs until the stream has drained and is ready
       * to accept more data.
       *
       * @param {object} message: the RPC dynamic structure specific to the RPC
       */
      async _encodeMessage(message) {
        const adapter = this.nsi.ntAdapter;
        this.writeBuf.startRequest(constants.TNS_PACKET_TYPE_DATA);
        while (message.encode(this.writeBuf)) {
          await adapter.pauseWrite();
        }
        this.writeBuf.endRequest();
      }
      async _recoverFromError(caughtErr, message) {
        try {
          this.breakMessage();
          this._breakInProgress = false;
          await this.resetMessage();
          await this.readBuf.waitForPackets();
          message.decode(this.readBuf);
        } catch (err) {
          this.nsi.disconnect();
          const newErr = errors.getErr(errors.ERR_CONNECTION_CLOSED);
          caughtErr.message = newErr.message + "\nError recovery failed: " + err.message + "\nOriginal error: " + caughtErr.message;
          throw caughtErr;
        }
      }
      /**
       *
       * @param {object} message The RPC dynamic structure specific to the RPC
       * @return {Promise}
       */
      async _processMessage(message) {
        let callTimer;
        let callTimeoutExpired = false;
        let traceInstance, traceContext;
        const traceEnabled = traceHandler.isEnabled();
        if (traceEnabled) {
          traceContext = { additionalConfig: {} };
          traceInstance = traceHandler.getTraceInstance();
        }
        try {
          if (this.callTimeout > 0) {
            callTimer = setTimeout(() => {
              callTimeoutExpired = true;
              this.breakMessage();
            }, this.callTimeout);
          }
          if (traceEnabled) {
            traceContext.operation = `oracledb.${message.constructor.name}`;
            traceInstance.onBeginRoundTrip(traceContext);
          }
          await this._encodeMessage(message);
          if (message.messageType !== constants.TNS_MSG_TYPE_ONEWAY_FN) {
            await this._decodeMessage(message);
          }
        } catch (err) {
          if (!this.connInProgress && err.code !== errors.ERR_CONNECTION_CLOSED_CODE) {
            await this._recoverFromError(err, message);
          }
          if (traceEnabled) {
            traceContext.error = err;
          }
          throw err;
        } finally {
          clearTimeout(callTimer);
          if (traceEnabled) {
            traceContext.callLevelConfig = message.connection._callLevelTraceData;
            traceContext.connectLevelConfig = message.connection._getConnectTraceConfig();
            if (message.callStatus & constants.TNS_EOCS_FLAGS_SESS_RELEASE) {
              traceContext.additionalConfig.implicitRelease = true;
            }
            traceInstance.onEndRoundTrip(traceContext);
          }
        }
        if (message.flushOutBinds) {
          await this.flushOutBindMessage(message);
        }
        this.txnInProgress = Boolean(message.callStatus & constants.TNS_EOCS_FLAGS_TXN_IN_PROGRESS);
        if (message.callStatus & constants.TNS_EOCS_FLAGS_SESS_RELEASE) {
          message.connection.statementCache.clearCursors();
        }
        if (message.errorOccurred) {
          if (callTimeoutExpired) {
            errors.throwErr(errors.ERR_CALL_TIMEOUT_EXCEEDED, this.callTimeout);
          }
          if (message.retry) {
            message.errorOccurred = false;
            return await this._processMessage(message);
          }
          let err = new Error(message.errorInfo.message);
          err.offset = message.errorInfo.pos;
          err.errorNum = message.errorInfo.num;
          err.isRecoverable = message.errorInfo.isRecoverable;
          err = errors.transformErr(err);
          if (err.code === errors.ERR_CONNECTION_CLOSED_CODE) {
            this.nsi.disconnect();
          }
          throw err;
        }
      }
      async flushOutBindMessage(message) {
        this.writeBuf.startRequest(constants.TNS_PACKET_TYPE_DATA);
        this.writeBuf.writeUInt8(constants.TNS_MSG_TYPE_FLUSH_OUT_BINDS);
        this.writeBuf.endRequest();
        await this._decodeMessage(message);
      }
      /**
       * Send break packet
       */
      breakMessage() {
        this._breakInProgress = true;
        this.nsi.sendBreak();
      }
      /**
       * Reset the connection
       */
      async resetMessage() {
        await this.nsi.reset();
      }
    };
    module2.exports = Protocol;
  }
});

// node_modules/oracledb/lib/thin/sqlnet/constants.js
var require_constants4 = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // TNS packet types
      NSPTCN: 1,
      // Connect
      NSPTAC: 2,
      // Accept
      NSPTAK: 3,
      // Acknowledge
      NSPTRF: 4,
      // Refuse
      NSPTRD: 5,
      // Redirect
      NSPTDA: 6,
      // Data
      NSPTNL: 7,
      // Null
      NSPTAB: 9,
      // Abort
      NSPTRS: 11,
      // Re-send
      NSPTMK: 12,
      // Marker
      NSPTAT: 13,
      // Attention
      NSPTCNL: 14,
      // Control information
      NSPTDD: 15,
      // data descriptor
      NSPTHI: 19,
      // Highest legal packet type
      // Packet Header
      NSPHDLEN: 0,
      // Packet length
      NSPHDPSM: 2,
      // Packet checksum(deprecated in version 3.15 with large sdu support)
      NSPHDTYP: 4,
      // Packet type
      NSPHDFLGS: 5,
      // Packet flags
      NSPHDHSM: 6,
      // Header checksum
      NSPSIZHD: 8,
      // Packet header size
      /* Packet flags for NSPHDFLGS */
      NSPFSID: 1,
      // SID is given
      NSPFRDS: 2,
      // ReDirect Separation of cnda vs cndo
      NSPFRDR: 4,
      // ReDiRected client Connect (NSPTCN)
      NSPFLSD: 32,
      // packet with large sdu field
      NO_HEADER_FLAGS: 0,
      NSPFSRN: 8,
      // Connect Packet
      NSPCNVSN: 8,
      // My version number
      NSPCNLOV: 10,
      // Lowest version number I can be compatible with
      NSPCNOPT: 12,
      // Global service options
      NSPCNSDU: 14,
      // My SDU size
      NSPCNTDU: 16,
      // Maximum TDU size
      NSPCNNTC: 18,
      // NT characterstics
      NSPCNTNA: 20,
      // Line turnaround value
      NSPCNONE: 22,
      // The value '1' in my hardware byte order
      NSPCNLEN: 24,
      // Length of connect data
      NSPCNOFF: 26,
      // Offset to connect data
      NSPCNMXC: 28,
      // Maximum connect data you can send me
      NSPCNFL0: 32,
      // Connect flags
      NSPCNFL1: 33,
      NSPCNTMO: 50,
      // local connection timeout val
      NSPCNTCK: 52,
      // local tick size
      NSPCNADL: 54,
      NSPCNAOF: 56,
      // offset to reconnect tns addr
      NSPCNLSD: 58,
      // large sdu
      NSPCNLTD: 62,
      // large tdu
      NSPCNCFL: 66,
      // compression data
      NSPCNCFL2: 70,
      // connect flag2
      //  NSPCNV310DAT : (NSPCNTMO + 8), start of connect data, V3.10   packet
      //  NSPCNV315DAT : (NSPCNCFL + 4),
      NSPCNDAT: 74,
      // Start connect data
      NSPMXCDATA: 230,
      // Maximum length of connect data
      // Connect flags (Used mostly by NA)
      NSINAWANTED: 1,
      // Want to use NA
      NSINAINTCHG: 2,
      // Interchange involved
      NSINADISABLEDFORCONNECTION: 4,
      // Disable NA
      NSINANOSERVICES: 8,
      // No NA services linked
      NSINAREQUIRED: 16,
      // NA is required
      NSINAAUTHWANTED: 32,
      // Authentication linked
      NSISUPSECRENEG: 128,
      // bkwrd comp: SUPport SECurity RE-NEG
      // Connect options
      NSGDONTCARE: 1,
      // "don't care"
      NSGHDX: 2,
      // half-duplex (w/ token management)
      NSGFDX: 4,
      // full-duplex
      NSGHDRCHKSUM: 8,
      // checksum on packet header
      NSGPAKCHKSUM: 16,
      // checksum on entire packet
      NSGBROKEN: 32,
      // provide broken connection notification
      NSGUSEVIO: 64,
      // can use Vectored I/O
      NSGOSAUTHOK: 128,
      // use OS authentication
      NSGSENDATTN: 512,
      // can send attention
      NSGRECVATTN: 1024,
      // can recv attention
      NSGNOATTNPR: 2048,
      // no attention processing
      NSGRAW: 4096,
      // I/O is direct to/from transport
      TNS_VERSION_DESIRED: 319,
      TNS_VERSION_MINIMUM: 300,
      TNS_VERSION_MIN_DATA_FLAGS: 318,
      TNS_VERSION_MIN_END_OF_RESPONSE: 319,
      TNS_UUID_OFFSET: 45,
      /* Accept Packet */
      NSPACVSN: 8,
      // connection version
      NSPACOPT: 10,
      // global service options
      NSPACSDU: 12,
      // SDU size
      NSPACTDU: 14,
      // Maximum TDU
      NSPACONE: 16,
      // The value '1' in my hardware byte order
      NSPACLEN: 18,
      // connect data length
      NSPACOFF: 20,
      // offset to connect data
      NSPACFL0: 22,
      // connect flags
      NSPACFL1: 23,
      NSPACTMO: 24,
      // connection pool timeout value
      NSPACTCK: 26,
      // local tick size
      NSPACADL: 28,
      // reconnect tns address length
      NSPACAOF: 30,
      // offset to reconnect tns addr
      NSPACLSD: 32,
      // Large sdu
      NSPACLTD: 36,
      // Large tdu
      NSPACCFL: 40,
      // compression flag
      NSPACFL2: 41,
      // accept flag2 (4 bytes)
      NSPACV310DAT: 32,
      /* start of accept data, V3.10     packet */
      NSPACV315DAT: 41,
      // start of accept data, V3.15     packet
      /* Refuse Packet */
      NSPRFURS: 8,
      // User (appliction) reason for refusal
      NSPRFSRS: 9,
      // System (NS) reason for
      NSPRFLEN: 10,
      // Length of refuse data
      NSPRFDAT: 12,
      // Start of connect data
      // Compression flags
      NSPACCFON: 128,
      // 1st MSB:  compression on/off
      NSPACCFAT: 64,
      // 2nd MSB :   compression auto
      NSPACCFNT: 2,
      // Second last LSB : compression for non-tcp protocol
      // Accept flag2
      NSPACOOB: 1,
      // OOB support check at connection time
      NSGPCHKSCMD: 16777216,
      // Support for Poll and Check logic
      TNS_ACCEPT_FLAG_HAS_END_OF_REQUEST: 33554432,
      TNS_ACCEPT_FLAG_FAST_AUTH: 268435456,
      // Support Fast Auth
      /* Redirect packet */
      NSPRDLEN: 8,
      // Length of redirect data
      NSPRDDAT: 10,
      // Start of connect data
      /* Data Packet */
      NSPDAFLG: 8,
      // Data flags
      NSPDADAT: 10,
      // Start of Data
      NSPDAFEOF: 64,
      // "end of file"
      NSPDAFCMP: 1024,
      // "compressed data"
      /* Marker Packet */
      NSPMKTYP: 8,
      // marker type (see below)
      NSPMKODT: 9,
      // old (pre-V3.05) data byte
      NSPMKDAT: 10,
      // data byte
      NSPMKTD0: 0,
      // data marker - 0 data bytes
      NSPMKTD1: 1,
      // data marker - 1 data byte
      NSPMKTAT: 2,
      // Attention Marker
      NIQBMARK: 1,
      // Break marker
      NIQRMARK: 2,
      // Reset marker
      NIQIMARK: 3,
      // Interrupt marker
      /* Control Packet */
      NSPCTLCMD: 8,
      // Control Command length is 2 bytes
      NSPCTLDAT: 10,
      // Control Data length is specific to the Command type.
      NSPCTL_SERR: 8,
      // Error Control Command Type
      NSPCTL_CLRATTN: 9,
      // Clear OOB option
      /* OPTIONS */
      NSPDFSDULN: 8192,
      // default SDU size
      NSPABSSDULN: 2097152,
      // maximim SDU size
      NSPMXSDULN: 65535,
      // maximim SDU size
      NSPMNSDULN: 512,
      // minimum SDU size
      NSPDFTDULN: 2097152,
      // default TDU size
      NSPMXTDULN: 2097152,
      // maximum TDU size
      NSPMNTDULN: 255,
      // minimum TDU size
      NSFIMM: 64,
      // immediate close
      /* PARAMETERS */
      DISABLE_OOB_STR: "DISABLE_OOB",
      // disable OOB parameter
      EXPIRE_TIME: "EXPIRE_TIME",
      // expire Time
      PEM_WALLET_FILE_NAME: "ewallet.pem",
      DEFAULT_TRANSPORT_CONNECT_TIMEOUT: 2e4,
      //default transport connect timeout
      DEFAULT_RETRY_DELAY: 1e3,
      //default retry delay
      /* Get/Set options */
      NT_MOREDATA: 1,
      // More Data in Transport available
      NS_MOREDATA: 2,
      // More Data available to be read
      SVCNAME: 3,
      // Service name
      SERVERTYPE: 4,
      // Server type
      REMOTEADDR: 5,
      // Remote Address
      HEALTHCHECK: 6,
      // Health check of connection
      CONNCLASS: 7,
      // Connection Class
      PURITY: 8,
      // Purity
      SID: 9,
      // SID
      /* Network Compression Algorithms */
      NETWORK_COMPRESSION_ZLIB: 2,
      /* FLAGS */
      NSNOBLOCK: 1
      // Do not block
    };
  }
});

// node_modules/oracledb/lib/thin/sqlnet/packet.js
var require_packet2 = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/packet.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var constants = require_constants4();
    var errors = require_errors();
    var MAX_CDATA_LEN = 230;
    var NSPCNL = 74;
    function ConnectPacket(connectData, sAtts, flags = 0) {
      this.connectData = connectData;
      this.connectDataLen = connectData.length;
      this.overflow = false;
      let size;
      if (this.connectDataLen <= MAX_CDATA_LEN) {
        size = NSPCNL + this.connectDataLen;
      } else {
        size = NSPCNL;
        this.overflow = true;
      }
      this.buf = Buffer2.allocUnsafe(size).fill(0);
      this.buf.writeUInt16BE(size, constants.NSPHDLEN);
      this.buf.writeUInt8(flags, constants.NSPHDFLGS);
      this.buf.writeUInt8(constants.NSPTCN, constants.NSPHDTYP);
      this.buf.writeUInt16BE(
        constants.TNS_VERSION_DESIRED,
        constants.NSPCNVSN
      );
      this.buf.writeUInt16BE(
        constants.TNS_VERSION_MINIMUM,
        constants.NSPCNLOV
      );
      const options = constants.NSGDONTCARE;
      this.buf.writeUInt16BE(options, constants.NSPCNOPT);
      if (sAtts.sdu > constants.NSPMXSDULN) {
        this.buf.writeUInt16BE(constants.NSPMXSDULN, constants.NSPCNSDU);
      } else {
        this.buf.writeUInt16BE(sAtts.sdu, constants.NSPCNSDU);
      }
      if (sAtts.tdu > constants.NSPMXSDULN) {
        this.buf.writeUInt16BE(constants.NSPMXSDULN, constants.NSPCNTDU);
      } else {
        this.buf.writeUInt16BE(sAtts.tdu, constants.NSPCNTDU);
      }
      this.buf.writeUInt16BE(
        sAtts.ntCha,
        constants.NSPCNNTC
      );
      this.buf.writeUInt16BE(
        1,
        constants.NSPCNONE
      );
      this.buf.writeUInt16BE(
        this.connectDataLen,
        constants.NSPCNLEN
      );
      this.buf.writeUInt16BE(
        constants.NSPCNDAT,
        constants.NSPCNOFF
      );
      this.buf.writeUInt8(
        sAtts.NAFlags,
        constants.NSPCNFL0
      );
      this.buf.writeUInt8(
        sAtts.NAFlags,
        constants.NSPCNFL1
      );
      this.buf.writeUInt16BE(0, constants.NSPCNTMO);
      this.buf.writeUInt16BE(0, constants.NSPCNTCK);
      this.buf.writeUInt16BE(0, constants.NSPCNADL);
      this.buf.writeUInt16BE(0, constants.NSPCNAOF);
      this.buf.writeUInt32BE(sAtts.sdu, constants.NSPCNLSD);
      this.buf.writeUInt32BE(sAtts.tdu, constants.NSPCNLTD);
      let compressionFieldBuilder = 0;
      if (sAtts.networkCompression) {
        compressionFieldBuilder = constants.NSPACCFON << 8;
        const schemeShiftCounter = 10;
        if (sAtts.networkCompressionLevels.includes("high"))
          compressionFieldBuilder |= constants.NETWORK_COMPRESSION_ZLIB << schemeShiftCounter;
      }
      this.buf.writeUInt16BE(compressionFieldBuilder, constants.NSPCNCFL);
      this.buf.writeUInt32BE(
        0,
        constants.NSPCNCFL2
      );
      if (!this.overflow && this.connectDataLen) {
        this.buf.write(connectData.toString("ascii"), constants.NSPCNDAT, this.connectDataLen, "ascii");
      }
    }
    function DataPacket(isLargeSDU) {
      this.dataPtr = 0;
      this.dataLen = 0;
      this.offset = 0;
      this.len = 0;
      this.bufLen = 0;
      this.createPacket = function(len) {
        this.dataPtr = constants.NSPDADAT;
        this.dataLen = constants.NSPDADAT;
        this.buf = Buffer2.allocUnsafe(len).fill(0);
        this.buf.writeUInt8(0, constants.NSPHDFLGS);
        this.buf.writeUInt8(constants.NSPTDA, constants.NSPHDTYP);
        this.bufLen = len;
      };
      this.fillBuf = function(userbuf, offset, len, flags = 0) {
        let bytes2Copy;
        if (!this.buf) {
          this.createPacket(len + constants.NSPDADAT);
        }
        if (len > this.bufLen - this.dataLen) {
          bytes2Copy = this.bufLen - this.dataLen;
        } else {
          bytes2Copy = len;
        }
        if (bytes2Copy) {
          userbuf.copy(this.buf, this.dataLen, offset, offset + bytes2Copy);
        }
        this.dataLen += bytes2Copy;
        this.prepare2Send(flags);
        return bytes2Copy;
      };
      this.prepare2Send = function(flags = 0) {
        if (isLargeSDU) {
          this.buf.writeUInt32BE(this.dataLen, constants.NSPHDLEN);
        } else {
          this.buf.writeUInt16BE(this.dataLen, constants.NSPHDLEN);
        }
        this.buf.writeUInt16BE(flags, constants.NSPDAFLG);
        this.dataBuf = this.buf.subarray(0, this.dataLen);
      };
      this.fromPacket = function(packet) {
        this.buf = packet.buf;
        this.dataLen = packet.buf.length;
        this.dataPtr = constants.NSPDADAT;
        this.offset = this.dataPtr;
        this.len = this.dataLen;
        packet.dataOffset = this.dataPtr;
      };
    }
    function AcceptPacket(packet, sAtts) {
      this.buf = packet.buf;
      this.len = packet.buf.length;
      sAtts.version = packet.buf.readUInt16BE(constants.NSPACVSN);
      sAtts.options = packet.buf.readUInt16BE(constants.NSPACOPT);
      sAtts.sdu = packet.buf.readUInt16BE(constants.NSPACSDU);
      sAtts.tdu = packet.buf.readUInt16BE(constants.NSPACTDU);
      if (sAtts.version >= 315) {
        sAtts.sdu = packet.buf.readUInt32BE(constants.NSPACLSD);
        sAtts.tdu = packet.buf.readUInt32BE(constants.NSPACLTD);
        sAtts.largeSDU = true;
        this.cflag = packet.buf.readUInt8(constants.NSPACCFL);
        if ((this.cflag & constants.NSPACCFON) != 0) {
          sAtts.negotiatedNetworkCompressionScheme = (this.cflag & 60) >> 2;
          sAtts.networkCompressionEnabled = true;
          sAtts.firstRecvCompressedPacket = true;
          sAtts.firstSendCompressedPacket = true;
        } else {
          sAtts.networkCompressionEnabled = false;
        }
      }
      this.flag0 = packet.buf.readUInt8(constants.NSPACFL0);
      this.flag1 = packet.buf.readUInt8(constants.NSPACFL1);
      sAtts.noNA = (this.flag1 & constants.NSINANOSERVICES) == constants.NSINANOSERVICES;
      if (!sAtts.noNA)
        sAtts.noNA = (this.flag0 & constants.NSINADISABLEDFORCONNECTION) == constants.NSINADISABLEDFORCONNECTION;
      if (sAtts.version >= constants.TNS_VERSION_MIN_DATA_FLAGS) {
        packet.flags = packet.buf.readUInt32BE(constants.NSPACFL2);
      }
    }
    function RefusePacket(packet) {
      this.buf = packet.buf;
      this.len = packet.buf.length;
      this.userReason = packet.buf.readUInt8(constants.NSPRFURS);
      this.systemReason = packet.buf.readUInt8(constants.NSPRFURS);
      this.dataLen = packet.buf.readUInt16BE(constants.NSPRFLEN);
      this.dataOff = constants.NSPRFDAT;
      if (this.len > this.dataOff) {
        this.dataBuf = this.buf.toString("ascii", this.dataOff, this.len);
        this.overflow = false;
      } else {
        this.overflow = true;
      }
    }
    function RedirectPacket(packet) {
      this.buf = packet.buf;
      this.len = packet.buf.length;
      this.flags = packet.flags;
      this.dataLen = packet.buf.readUInt16BE(constants.NSPRDLEN);
      this.dataOff = constants.NSPRDDAT;
      if (this.len > this.dataOff) {
        this.dataBuf = this.buf.subarray(this.dataOff, this.len);
        this.overflow = false;
      } else {
        this.overflow = true;
      }
    }
    function MarkerPacket(isLargeSDU) {
      this.len = constants.NSPMKDAT + 1;
      this.buf = Buffer2.allocUnsafe(constants.NSPMKDAT + 1).fill(0);
      if (isLargeSDU) {
        this.buf.writeUInt32BE(this.len, constants.NSPHDLEN);
      } else {
        this.buf.writeUInt16BE(this.len, constants.NSPHDLEN);
      }
      this.buf.writeUInt8(0, constants.NSPHDFLGS);
      this.buf.writeUInt8(constants.NSPTMK, constants.NSPHDTYP);
      this.prepare = function(type, data) {
        this.buf.writeUInt8(type, constants.NSPMKTYP);
        this.buf.writeUInt8(data, constants.NSPMKDAT);
      };
      this.fromPacket = function(packet, nsi) {
        this.type = packet.buf.readUInt8(constants.NSPMKTYP);
        switch (this.type) {
          case constants.NSPMKTD0:
            nsi.isBreak = true;
            break;
          case constants.NSPMKTD1:
            this.data = packet.buf.readUInt8(constants.NSPMKDAT);
            nsi.isBreak = true;
            if (this.data == constants.NIQRMARK) {
              nsi.isReset = true;
              nsi.isBreak = true;
            }
            break;
          default:
            errors.throwErr(errors.ERR_INVALID_PACKET);
        }
      };
    }
    function ControlPacket() {
      this.clear = function() {
        this.errno = 0;
        this.notif = null;
        this.notifLen = 0;
        this.cmd = 0;
      };
      this.fromPacket = function(packet) {
        const NSECMANSHUT = 12572;
        const NSESENDMESG = 12573;
        const ORA_ERROR_EMFI_NUMBER = 22;
        let emfi;
        let err1;
        let err2;
        this.cmd = packet.buf.readUInt16BE(constants.NSPCTLCMD);
        switch (this.cmd) {
          case constants.NSPCTL_SERR:
            emfi = packet.buf.readUInt32BE(constants.NSPCTLDAT);
            err1 = packet.buf.readUInt32BE(constants.NSPCTLDAT + 4);
            err2 = packet.buf.readUInt32BE(constants.NSPCTLDAT + 8);
            if (err1 == NSECMANSHUT) {
              this.errno = err1;
            } else if (err1 == NSESENDMESG) {
              this.errno = err1;
              this.notifLen = err2;
              this.notif = Buffer2.allocUnsafe(err2 + 1).fill(0);
              this.buf.copy(this.notif, 0, constants.NSPCTLDAT + 12, constants.NSPCTLDAT + 12 + err2);
            } else {
              this.errno = err1;
              if (emfi == ORA_ERROR_EMFI_NUMBER) {
                errors.throwErr(errors.ERR_CONNECTION_INBAND, "ORA-" + err1);
              } else {
                errors.throwErr(errors.ERR_CONNECTION_INBAND, "TNS-" + err1);
              }
            }
            break;
          default:
            errors.throwErr(errors.ERR_INVALID_PACKET);
        }
      };
    }
    module2.exports = {
      ConnectPacket,
      DataPacket,
      AcceptPacket,
      RefusePacket,
      RedirectPacket,
      MarkerPacket,
      ControlPacket
    };
  }
});

// node_modules/oracledb/lib/thin/sqlnet/nvStrToNvPair.js
var require_nvStrToNvPair = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/nvStrToNvPair.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var RHS_NONE = 0;
    var RHS_ATOM = 1;
    var RHS_LIST = 2;
    var LIST_REGULAR = 3;
    var LIST_COMMASEP = 4;
    var NVPair = class {
      constructor(name) {
        this.name = name;
        this.listType = LIST_REGULAR;
        this.rhsType = RHS_NONE;
      }
      /**
       * @param {string} atom - input atom string literal
       */
      set setAtom(atom) {
        if (this._containsComment(atom)) {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        this.rhsType = RHS_ATOM;
        this.list = null;
        this.atom = atom;
      }
      /**
        * Checks if the input string contains comment.
        * @param {string} str - input string
        * @returns {boolean}
        */
      _containsComment(str) {
        for (let i = 0; i < str.length; i++) {
          if (str.charAt(i) == "#") {
            if (i != 0) {
              if (str.charAt(i - 1) == "\\")
                continue;
              else
                return true;
            } else {
              return true;
            }
          }
        }
        return false;
      }
      /**
         * gets the size of the list.
         * @returns {integer}
         */
      getListSize() {
        if (this.list == null)
          return 0;
        else
          return this.list.length;
      }
      /**
         * gets the element at a given position in the list.
         * @param {integer} pos
         * @returns {string}
         */
      getListElement(pos) {
        if (this.list == null)
          return null;
        else
          return this.list[pos];
      }
      /**
         * adds a nvpair to the existing one.
         * @param {NVPair} pair
         */
      addListElement(pair) {
        if (this.list == null) {
          this.rhsType = RHS_LIST;
          this.list = new Array();
          this.atom = null;
        }
        this.list.push(pair);
        pair.parent = this;
      }
      /**
         * removes an element at a given position.
         * @param {integer} pos
         */
      removeListElement(pos) {
        if (this.list != null) {
          this.list.splice(pos, 1);
          if (this.getListSize == 0) {
            this.list = null;
            this.rhsType = RHS_NONE;
          }
        }
      }
      /**
        * Returns an empty string with the number specified in the argument. Used
        * for indentation of multi-level NVPairs as they are stored
        *
        * @param count
        *          Number of spaces required in the blank string.
        */
      _space(count) {
        var blank_str = "";
        for (let i = 0; i < count; i++) {
          blank_str += " ";
        }
        return blank_str;
      }
      /**
      * Returns the value of an NVPair (and all child NVPairs) as a readable
      * String.
        */
      valueToString() {
        let out = "";
        if (this.rhsType == RHS_ATOM) {
          out = out + this.atom;
        } else if (this.rhsType == RHS_LIST) {
          if (this.listType == LIST_REGULAR) {
            for (let i = 0; i < this.getListSize(); i++) {
              out = out + this.getListElement(i).toString();
            }
          } else if (this.listType == LIST_COMMASEP) {
            for (let i = 0; i < this.getListSize(); i++) {
              const listElem = this.getListElement(i);
              out = out + listElem.name;
              if (i != this.getListSize() - 1)
                out = out + ", ";
            }
          }
        }
        return out;
      }
      /**
        *
        * @returns string representation of the nvpair
        */
      toString() {
        let out = "(" + this.name + "=";
        if (this.rhsType == RHS_ATOM) {
          out = out + this.atom;
        } else if (this.rhsType == RHS_LIST) {
          if (this.listType == LIST_REGULAR) {
            for (let i = 0; i < this.getListSize(); i++) {
              out = out + this.getListElement(i).toString();
            }
          } else if (this.listType == LIST_COMMASEP) {
            out = out + " (";
            for (let i = 0; i < this.getListSize(); i++) {
              const listElem = this.getListElement(i);
              out = out + listElem.name;
              if (i != this.getListSize() - 1)
                out = out + ", ";
            }
            out = out + ")";
          }
        }
        out = out + ")";
        return out;
      }
    };
    var TKN_NONE = 0;
    var TKN_LPAREN = 1;
    var TKN_RPAREN = 2;
    var TKN_COMMA = 3;
    var TKN_EQUAL = 4;
    var TKN_LITERAL = 8;
    var TKN_EOS = 9;
    var TKN_LPAREN_VALUE = "(";
    var TKN_RPAREN_VALUE = ")";
    var TKN_COMMA_VALUE = ",";
    var TKN_EQUAL_VALUE = "=";
    var TKN_BKSLASH_VALUE = "\\";
    var TKN_DQUOTE_VALUE = '"';
    var TKN_SQUOTE_VALUE = "'";
    var TKN_EOS_VALUE = "%";
    var TKN_SPC_VALUE = " ";
    var TKN_TAB_VALUE = "	";
    var TKN_LF_VALUE = "\n";
    var TKN_CR_VALUE = "\r";
    var NVTokens = class {
      /**
       * Constructs NVTokens object for use.
       */
      constructor() {
        this.tkType = null;
        this.tkValue = null;
        this.numTokens = 0;
        this.tkPos = 0;
      }
      /*
       * function to determine if a given character is whitespace. The
       * following constitute whitespace: ' ' (SPACE), '\t' (TAB), '\n' (NEWLINE),
       * '\r' (LINEFEED),
       */
      _isWhiteSpace(it) {
        if (it == TKN_SPC_VALUE || it == TKN_TAB_VALUE || it == TKN_LF_VALUE || it == TKN_CR_VALUE) {
          return true;
        }
        return false;
      }
      /*
       * function to trim leading and trailing spaces from a literal.
       */
      _trimWhiteSpace(it) {
        const length = it.length;
        let start = 0;
        let end = length;
        while (start < length && this._isWhiteSpace(it.charAt(start))) {
          start++;
        }
        while (start < end && this._isWhiteSpace(it.charAt(end - 1))) {
          end--;
        }
        return it.substring(start, end);
      }
      /**
       * Parses an NVString into a list of tokens which can be more easily
       * interpreted. The list of tokens is stored within the class and must be
       * accessed through getToken()/getLiteral() and eatToken().
       *
       * @param nvString
       *          NVString to be parsed.
       */
      parseTokens(nvString) {
        this.numTokens = 0;
        this.tkPos = 0;
        this.tkType = new Array();
        this.tkValue = new Array();
        const len = nvString.length;
        let eql_seen = false;
        let input = new Array();
        input = Array.from(nvString);
        let pos = 0;
        while (pos < len) {
          while (pos < len && this._isWhiteSpace(input[pos])) {
            pos++;
          }
          if (pos < len) {
            switch (input[pos]) {
              // For metacharacters (, ), and =, add to the token list, and
              // advance the NVString position. (Save token, eat character)
              case TKN_LPAREN_VALUE:
                eql_seen = false;
                this._addToken(TKN_LPAREN, TKN_LPAREN_VALUE);
                pos++;
                break;
              case TKN_EQUAL_VALUE:
                eql_seen = true;
                this._addToken(TKN_EQUAL, TKN_EQUAL_VALUE);
                pos++;
                break;
              case TKN_RPAREN_VALUE:
                eql_seen = false;
                this._addToken(TKN_RPAREN, TKN_RPAREN_VALUE);
                pos++;
                break;
              case TKN_COMMA_VALUE:
                eql_seen = false;
                this._addToken(TKN_COMMA, TKN_COMMA_VALUE);
                pos++;
                break;
              default: {
                let startPos = pos;
                let endPos = -1;
                let quoted_str = false;
                let quote_char = TKN_DQUOTE_VALUE;
                if (input[pos] == TKN_SQUOTE_VALUE || input[pos] == TKN_DQUOTE_VALUE) {
                  quoted_str = true;
                  quote_char = input[pos];
                  pos++;
                  startPos = pos;
                }
                while (pos < len) {
                  if (input[pos] == TKN_BKSLASH_VALUE) {
                    pos += 2;
                    continue;
                  }
                  if (quoted_str) {
                    if (input[pos] == quote_char) {
                      pos++;
                      endPos = pos - 1;
                      break;
                    }
                  } else {
                    if (input[pos] == TKN_LPAREN_VALUE || input[pos] == TKN_RPAREN_VALUE || input[pos] == TKN_COMMA_VALUE && !eql_seen || input[pos] == TKN_EQUAL_VALUE && !eql_seen) {
                      endPos = pos;
                      break;
                    }
                  }
                  pos++;
                }
                if (endPos == -1) {
                  endPos = pos;
                }
                this._addToken(
                  TKN_LITERAL,
                  nvString.substring(startPos, endPos).trim()
                );
                break;
              }
            }
          }
        }
        this._addToken(TKN_EOS, TKN_EOS_VALUE);
        return true;
      }
      /**
       * Returns current token. Throws Error if no string has been parsed,
       * or if there are no tokens left. Does NOT advance the token position.
       */
      getToken() {
        if (this.tkType == null) {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        if (this.tkPos < this.numTokens) {
          return Number(this.tkType[this.tkPos]);
        } else {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
      }
      /**
       * Returns current token. Throws Error if no string has been parsed,
       * or if there are no tokens left. DOES advance the token position.
       */
      popToken() {
        let token = TKN_NONE;
        if (this.tkType == null) {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        if (this.tkPos < this.numTokens) {
          token = Number(this.tkType[this.tkPos++]);
        } else {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        return token;
      }
      /**
       * Returns literal for current token. If current token is NOT a TKN_LITERAL,
       * it returns a string representation of the current token. Throws Error
       * if no string has been parsed, or if there are no tokens left.
       *
       * DOES NOT advance the token position.
       */
      getLiteral() {
        let theLiteral = null;
        if (this.tkValue == null) {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        if (this.tkPos < this.numTokens) {
          theLiteral = String(this.tkValue[this.tkPos]);
        } else {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        return theLiteral;
      }
      /**
       * Returns literal for current token. If current token is NOT a TKN_LITERAL,
       * it returns a string representation of the current token. Throws Error
       * if no string has been parsed, or if there are no tokens left.
       *
       * DOES advance the token position.
       */
      popLiteral() {
        let theLiteral = null;
        if (this.tkValue == null) {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        if (this.tkPos < this.numTokens) {
          theLiteral = String(this.tkValue[this.tkPos++]);
        } else {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        return theLiteral;
      }
      /**
       * Advances the token position by one.
       */
      eatToken() {
        if (this.tkPos < this.numTokens) {
          this.tkPos++;
        }
      }
      /**
       * Returns NVTokens list as a readable String.
       */
      toString() {
        if (this.tkType == null) {
          return "*NO TOKENS*";
        }
        let out = "Tokens";
        for (let i = 0; i < this.numTokens; i++) {
          out = out + " : " + this.tkValue[i];
        }
        return out;
      }
      /*
       * function to add a token and corresponding printable version (i.e.,
       * TKN_LPAREN and TKN_LPAREN_VALUE) into the token list.
       */
      _addToken(tk, tk_val) {
        this.tkType.push(Number(tk));
        this.tkValue.push(String(tk_val));
        this.numTokens++;
      }
    };
    function createNVPair(nvString) {
      const nvt = new NVTokens();
      nvt.parseTokens(nvString);
      return readTopLevelNVPair(nvt);
    }
    function readTopLevelNVPair(nvt) {
      let tk = nvt.getToken();
      nvt.eatToken();
      if (tk != TKN_LPAREN) {
        errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
      }
      let name = readNVLiteral(nvt);
      const nvp = new NVPair(name);
      if ((tk = nvt.getToken()) == TKN_COMMA) {
        while (tk == TKN_LITERAL || tk == TKN_COMMA) {
          name += nvt.popLiteral();
          tk = nvt.getToken();
        }
        nvp.name = name;
        return readRightHandSide(nvp, nvt);
      }
      return readRightHandSide(nvp, nvt);
    }
    function readNVPair(nvt) {
      const tk = nvt.getToken();
      nvt.eatToken();
      if (!(tk == TKN_LPAREN || tk == TKN_COMMA)) {
        errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
      }
      const name = readNVLiteral(nvt);
      const nvp = new NVPair(name);
      return readRightHandSide(nvp, nvt);
    }
    function readRightHandSide(nvp, nvt) {
      let tk = nvt.getToken();
      switch (tk) {
        case TKN_EQUAL:
          nvt.eatToken();
          tk = nvt.getToken();
          if (tk == TKN_LITERAL) {
            const value = readNVLiteral(nvt);
            nvp.setAtom = value;
          } else {
            readNVList(nvt, nvp);
          }
          break;
        case TKN_COMMA:
        case TKN_RPAREN:
          nvp.setAtom = nvp.name;
          break;
        default:
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
      }
      tk = nvt.getToken();
      if (tk == TKN_RPAREN) {
        nvt.eatToken();
      } else if (tk != TKN_COMMA) {
        errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
      }
      return nvp;
    }
    function readNVLiteral(nvt) {
      const tk = nvt.getToken();
      if (tk != TKN_LITERAL) {
        errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
      }
      return nvt.popLiteral();
    }
    function readNVList(nvt, parent) {
      const tk = nvt.getToken();
      if (!(tk == TKN_LPAREN || tk == TKN_COMMA)) {
        return;
      }
      const child = readNVPair(nvt);
      parent.addListElement(child);
      if (tk == TKN_COMMA || child.name == child.atom) {
        if (parent.getListType != LIST_COMMASEP)
          parent.setListType = LIST_COMMASEP;
      }
      readNVList(nvt, parent);
    }
    function findNVPairRecurse(nvp, name) {
      if (!nvp) {
        return null;
      }
      if (name.toUpperCase() == nvp.name.toUpperCase())
        return nvp;
      if (nvp.getRHSType == RHS_ATOM)
        return null;
      for (let i = 0; i < nvp.getListSize(); i++) {
        const child = findNVPairRecurse(nvp.getListElement(i), name);
        if (child !== null)
          return child;
      }
      return null;
    }
    function findNVPair(nvp, name) {
      if (!nvp) {
        return null;
      }
      if (nvp.getRHSType == RHS_ATOM)
        return null;
      for (let i = 0; i < nvp.getListSize(); i++) {
        const child = nvp.getListElement(i);
        if (name.toUpperCase() == child.name.toUpperCase())
          return child;
      }
      return null;
    }
    function findValue(nvp, names) {
      if (!nvp) {
        return null;
      }
      if (names[0].toUpperCase() != nvp.name.toUpperCase())
        return null;
      let output = nvp;
      const sze = names.length;
      for (let i = 1; i < sze; i++) {
        output = findNVPair(output, names[i]);
        if (!output)
          return null;
      }
      if (output.atom == null) {
        if (output.list == null)
          return null;
        else
          return output.list.toString();
      } else {
        return output.atom.toString();
      }
    }
    module2.exports = { findNVPairRecurse, createNVPair, findNVPair, findValue };
  }
});

// node_modules/oracledb/lib/thin/sqlnet/ntTcp.js
var require_ntTcp = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/ntTcp.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var net = require("net");
    var process2 = require("process");
    var tls = require("tls");
    var http = require("http");
    var Timers = require("timers");
    var constants = require_constants4();
    var errors = require_errors();
    var { findValue, findNVPair } = require_nvStrToNvPair();
    var PACKET_HEADER_SIZE = 8;
    var DEFAULT_PORT = 1521;
    var DEFAULT_HTTPS_PROXY_PORT = 80;
    var TCPCHA = 1 << 1 | /* ASYNC support */
    1 << 2 | /* Callback support */
    1 << 3 | /* More Data support */
    1 << 8 | /* Read/Write Readiness support */
    1 << 9 | /* Full Duplex support */
    1 << 12;
    var sniAllowedCDParams = [
      "SERVICE_NAME",
      "INSTANCE_NAME",
      "SERVER",
      "COLOCATION_TAG",
      "CONNECTION_ID",
      "POOL_BOUNDARY",
      "POOL_PURITY",
      "POOL_CONNECTION_CLASS",
      "POOL_NAME",
      "SERVICE_TAG",
      "CID"
    ];
    var sniParams = ["SERVICE_NAME", "INSTANCE_NAME", "SERVER", "COLOCATION_TAG"];
    var sniMap = ["S", "I", "T", "C"];
    var SNI_MAX_BYTES = 256;
    var streamNum = 1;
    var NTTCP = class {
      constructor(atts) {
        this.atts = atts;
        this.cha = TCPCHA;
        this.connected = false;
        this.err = false;
        this.needsDrain = false;
        this.numPacketsSinceLastWait = 0;
        this.secure = false;
        this.largeSDU = false;
        this.streamNum = streamNum++;
        this.packetNum = 1;
        this.doDNMatch = true;
      }
      /**
       * DN matching function(used with TLS)
       */
      dnMatch(serverName, cert) {
        if (this.atts.sslServerDNMatch && this.doDNMatch) {
          const toObject = (str) => str.split(",").map((x) => x.split("=").map((y) => y.trim())).reduce((a, x) => {
            a[x[0]] = x[1];
            return a;
          }, {});
          if (this.atts.sslServerCertDN) {
            const obj = toObject(this.atts.sslServerCertDN);
            if (Object.keys(obj).length == Object.keys(cert.subject).length) {
              for (const key in obj) {
                if (obj[key] != cert.subject[key]) {
                  return errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE);
                }
              }
            } else {
              return errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE);
            }
          } else {
            if (tls.checkServerIdentity(this.hostName, cert) && (!this.originHost || tls.checkServerIdentity(this.originHost, cert))) {
              if (this.atts.sslAllowWeakDNMatch) {
                const serviceName = findValue(this.atts.cDataNVPair, ["DESCRIPTION", "CONNECT_DATA", "SERVICE_NAME"]);
                if (serviceName != cert.subject.CN) {
                  return errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE);
                }
              } else {
                const hostName = this.hostName + " " + (this.originHost ? "or " + this.originHost : "");
                return errors.getErr(errors.ERR_TLS_HOSTMATCH_FAILURE, hostName);
              }
            }
          }
        }
      }
      /**
       * TLS connection establishment
       * @returns Promise
       */
      async tlsConnect(secureContext, connStream) {
        this.stream.removeAllListeners();
        let connectErrCause, sni = null;
        if (this.atts.useSNI)
          sni = this.generateSNI();
        const tlsOptions = {
          host: this.host,
          socket: connStream,
          servername: sni,
          rejectUnauthorized: true,
          secureContext,
          enableTrace: false,
          checkServerIdentity: this.dnMatch.bind(this)
        };
        await new Promise((resolve3) => {
          this.stream = tls.connect(tlsOptions, () => {
            if (!this.stream.authorized) {
              connectErrCause = "server certificate unauthorized";
            }
            resolve3();
          }).on("error", (err) => {
            connectErrCause = err.message;
            resolve3();
          });
        });
        if (connectErrCause)
          errors.throwErr(errors.ERR_TLS_AUTH_FAILURE, this.host, this.port, this.atts.connectionId, connectErrCause);
        this.connStream = connStream;
      }
      /**
       * TCP connection establishment
       * @returns Promise
       */
      async ntConnect(address) {
        if (!address.port) {
          address.port = DEFAULT_PORT;
        }
        let connectErrCause, proxyConnectErrCause, req;
        const httpsProxy = address.httpsProxy || this.atts.httpsProxy;
        let httpsProxyPort = address.httpsProxyPort || this.atts.httpsProxyPort;
        await new Promise((resolve3) => {
          if (httpsProxy) {
            if (!httpsProxyPort) {
              httpsProxyPort = DEFAULT_HTTPS_PROXY_PORT;
            }
            req = http.request({
              host: httpsProxy,
              port: httpsProxyPort,
              method: "CONNECT",
              path: address.host + ":" + address.port
            });
            req.once("connect", (res, socket) => {
              if (res.statusCode == 200) {
                this.connected = true;
                this.stream = socket;
              } else {
                proxyConnectErrCause = res.statusCode;
              }
              resolve3();
            });
            req.once("error", (err) => {
              proxyConnectErrCause = err.message;
              resolve3();
            });
            req.end();
          } else {
            this.stream = net.connect(address.port, address.host, () => {
              this.connected = true;
              resolve3();
            });
            this.stream.once("error", (err) => {
              connectErrCause = err.message;
              resolve3();
            });
          }
        });
        if (req)
          req.removeAllListeners();
        if (!this.connected) {
          if (proxyConnectErrCause) {
            errors.throwErr(errors.ERR_PROXY_CONNECTION_FAILURE, httpsProxy, httpsProxyPort, this.atts.connectionId, proxyConnectErrCause);
          } else {
            errors.throwErr(errors.ERR_CONNECTION_INCOMPLETE, this.host, this.port, this.atts.connectionId, connectErrCause);
          }
        }
      }
      /**
       * Network Transport connection establishment
       * @returns Promise
       */
      async connect(address) {
        this.originHost = address.originHost;
        this.host = address.host;
        this.hostName = address.hostname;
        this.port = address.port;
        try {
          await this.ntConnect(address);
          if (this.atts.expireTime || this.atts.enableDCD) {
            if (this.atts.expireTime) {
              this.stream.setKeepAlive(true, this.atts.expireTime);
            } else {
              this.stream.setKeepAlive(true);
            }
          }
          if (this.atts.tcpNoDelay) {
            this.stream.setNoDelay(true);
          }
          if (address.protocol.toUpperCase() == "TCPS") {
            let secureContext;
            this.secure = true;
            if (this.atts.sslAllowWeakDNMatch)
              this.doDNMatch = false;
            try {
              secureContext = tls.createSecureContext({
                cert: this.atts.wallet,
                key: this.atts.wallet,
                passphrase: this.atts.walletPassword,
                ca: this.atts.wallet
              });
            } catch (err) {
              errors.throwErr(errors.ERR_TLS_INIT_FAILURE, err.message);
            }
            await this.tlsConnect(secureContext, this.stream);
          }
        } finally {
          if (this.stream) {
            this.setupEventHandlers();
          }
        }
      }
      /**
       * Disconnect Network Transoprt
       * @param {int} type
       * @returns Promise
       */
      disconnect(type) {
        if (this.connected && !this.err) {
          if (type == constants.NSFIMM)
            this.stream.destroy();
          else
            this.stream.end();
        }
        this.stream = null;
        this.connected = false;
        this.drainWaiter = null;
        this.readWaiter = null;
      }
      /**
       * Get the string containing a packet dump.
       * @param {Buffer} buffer containing packet data
       */
      getPacketDump(buffer) {
        const lines = [];
        for (let i = 0; i < buffer.length; i += 8) {
          const address = i.toString().padStart(4, "0");
          const block = buffer.slice(i, i + 8);
          const hexDumpValues = [];
          const printableValues = [];
          for (const hexByte of block) {
            hexDumpValues.push(hexByte.toString(16).toUpperCase().padStart(2, "0"));
            if (hexByte > 32 && hexByte < 127) {
              printableValues.push(String.fromCharCode(hexByte));
            } else {
              printableValues.push(".");
            }
          }
          while (hexDumpValues.length < 8) {
            hexDumpValues.push("  ");
            printableValues.push(" ");
          }
          const hexValuesBlock = hexDumpValues.join(" ");
          const printableBlock = printableValues.join("");
          lines.push(`${address} : ${hexValuesBlock} |${printableBlock}|`);
        }
        return lines.join("\n");
      }
      /**
       * Print the packet to the console.
       * @param {String} operation which was performed
       * @param {Buffer} buffer containing packet data
       */
      printPacket(operation, buffer) {
        const now = /* @__PURE__ */ new Date();
        const formattedDate = `${now.getFullYear()}-${now.getMonth().toString().padStart(2, "0")}-${now.getDay().toString().padStart(2, "0")} ${now.getHours().toString().padStart(2, "0")}:${now.getMinutes().toString().padStart(2, "0")}:${now.getSeconds().toString().padStart(2, "0")}.${now.getMilliseconds().toString().padStart(3, "0")}`;
        const packetDump = this.getPacketDump(buffer);
        console.log(`${formattedDate} ${operation}:
${packetDump}
`);
      }
      /**
       * Check for errors
       */
      checkErr() {
        if (!this.connected || this.err) {
          let err;
          if (this.savedErr) {
            err = errors.getErr(
              errors.ERR_CONNECTION_LOSTCONTACT,
              this.host,
              this.port,
              this.atts.connectionId,
              this.savedErr.message
            );
          } else {
            err = errors.getErr(errors.ERR_CONNECTION_EOF, this.host, this.port, this.atts.connectionId);
          }
          const newErr = errors.getErr(errors.ERR_CONNECTION_CLOSED);
          newErr.message = newErr.message + "\n" + err.message;
          throw newErr;
        }
      }
      /**
       * Transport Send
       * @param {Buffer} buf Buffer to send
       * @returns Promise
       */
      send(buf) {
        this.checkErr();
        if (process2.env.NODE_ORACLEDB_DEBUG_PACKETS)
          this.printPacket(`Sending packet ${this.packetNum} on stream ${this.streamNum}`, buf);
        const result = this.stream.write(buf, (err) => {
          if (err) {
            this.savedErr = err;
            this.err = true;
            this._notifyWaiters();
          }
        });
        if (!result) {
          this.needsDrain = true;
        }
        this.numPacketsSinceLastWait++;
        this.packetNum++;
      }
      /**
       * Should writing to the transport be paused? This occurs if draining is
       * required or if the number of packets written since the last pause exceeds
       * 100 (in order to avoid starvation of the event loop during large writes).
       */
      shouldPauseWrite() {
        return this.needsDrain || this.numPacketsSinceLastWait >= 100;
      }
      /**
       * Perform a wait -- if draining is required, then until the drain event is
       * emitted or if draining is not required, then a simple setImmediate() that
       * ensures that the event loop is not starved.
       */
      async pauseWrite() {
        this.checkErr();
        if (this.needsDrain) {
          await new Promise((resolve3) => {
            this.drainWaiter = resolve3;
          });
          this.checkErr();
        } else {
          await new Promise((resolve3) => Timers.setImmediate(resolve3));
        }
        this.numPacketsSinceLastWait = 0;
      }
      /**
       * Start Async reads
       */
      startRead() {
        let tempBuf;
        this.packets = [];
        this.stream.on("data", (chunk) => {
          if (tempBuf) {
            tempBuf = Buffer2.concat([tempBuf, chunk]);
          } else {
            tempBuf = chunk;
          }
          while (tempBuf.length >= PACKET_HEADER_SIZE) {
            let len;
            if (this.largeSDU) {
              len = tempBuf.readUInt32BE();
            } else {
              len = tempBuf.readUInt16BE();
            }
            if (len > tempBuf.length)
              break;
            const packet = {
              buf: tempBuf.subarray(0, len),
              type: tempBuf[4],
              flags: tempBuf[5],
              num: this.packetNum++
            };
            this.packets.push(packet);
            if (this.readWaiter) {
              this.readWaiter();
              this.readWaiter = null;
            }
            if (process2.env.NODE_ORACLEDB_DEBUG_PACKETS)
              this.printPacket(`Receiving packet ${packet.num} on stream ${this.streamNum}`, packet.buf);
            if (len === tempBuf.length) {
              tempBuf = null;
              break;
            } else {
              tempBuf = tempBuf.subarray(len);
            }
          }
        });
      }
      /**
       * Synchronous receive
       * @returns a single packet or undefined if no packets are available
       */
      syncReceive() {
        return this.packets.shift();
      }
      /**
       * Asynchronous receive
       * @returns a single packet
       */
      async receive() {
        if (this.packets.length === 0) {
          this.checkErr();
          await new Promise((resolve3) => {
            this.readWaiter = resolve3;
            this.numPacketsSinceLastWait = 0;
          });
          this.checkErr();
        }
        return this.packets.shift();
      }
      /**
       * TLS renegotiate
       * @returns Promise
       */
      async renegTLS() {
        let initTLSDone = false;
        this.checkErr();
        try {
          this.doDNMatch = true;
          const secureContext = tls.createSecureContext({
            cert: this.atts.wallet,
            key: this.atts.wallet,
            passphrase: this.atts.walletPassword,
            ca: this.atts.wallet
          });
          initTLSDone = true;
          await this.tlsConnect(secureContext, this.connStream);
        } catch (err) {
          if (!initTLSDone)
            errors.throwErr(errors.ERR_TLS_INIT_FAILURE, err.message);
          else throw err;
        } finally {
          this.setupEventHandlers();
        }
      }
      /**
       * Setup handling of events
       */
      setupEventHandlers() {
        this.stream.removeAllListeners();
        this.stream.on("error", (err) => {
          this.savedErr = err;
          this.err = true;
          this._notifyWaiters();
        });
        this.stream.on("end", () => {
          this.err = true;
          this._notifyWaiters();
        });
        this.stream.on("close", () => {
          this.connected = false;
          this._notifyWaiters();
        });
        this.stream.on("drain", () => {
          this.needsDrain = false;
          if (this.drainWaiter) {
            this.drainWaiter();
            this.drainWaiter = null;
          }
        });
      }
      /**
       * Get Transport Attributes
       * @param {int} opcode type of attribute
       * @returns attribute value
       */
      getOption(opcode) {
        this.checkErr();
        switch (opcode) {
          case constants.NT_MOREDATA:
            return this.packets.length > 0;
          case constants.REMOTEADDR: {
            const socket = this.secure ? this.connStream : this.stream;
            return socket.remoteAddress + ":" + socket.remotePort;
          }
          default:
            errors.throwErr(errors.ERR_INTERNAL, "getOption not supported for opcode " + opcode);
        }
      }
      /**
       * Notify the waiters (drain and read) and reset them, if applicable.
       */
      _notifyWaiters() {
        if (this.drainWaiter) {
          this.drainWaiter();
          this.drainWaiter = null;
        }
        if (this.readWaiter) {
          this.readWaiter();
          this.readWaiter = null;
        }
      }
      /**
       * Generate SNI data.
       */
      generateSNI() {
        if (findValue(this.atts.cDataNVPair, ["DESCRIPTION", "SOURCE_ROUTE"]) == "yes" || findValue(this.atts.cDataNVPair, ["DESCRIPTION", "ADDRESS_LIST", "SOURCE_ROUTE"]) == "yes")
          return null;
        const cdnvp = findNVPair(this.atts.cDataNVPair, "CONNECT_DATA");
        for (let i = 0; i < cdnvp.getListSize(); i++) {
          const child = cdnvp.getListElement(i);
          if (!sniAllowedCDParams.includes(child.name.toUpperCase()))
            return null;
        }
        let value, sni = "";
        for (let i = 0; i < sniParams.length; i++) {
          if (value = findValue(this.atts.cDataNVPair, ["DESCRIPTION", "CONNECT_DATA", sniParams[i]])) {
            if (sniParams[i] == "SERVER")
              sni += sniMap[i] + "1." + value[0] + ".";
            else
              sni += sniMap[i] + value.length + "." + value + ".";
          }
        }
        sni += "V3." + constants.TNS_VERSION_DESIRED;
        const match_pattern = new RegExp("^[A-Za-z0-9._-]+$");
        if (!sni.match(match_pattern))
          return null;
        if (sni.length > SNI_MAX_BYTES)
          return null;
        return sni;
      }
    };
    module2.exports = NTTCP;
  }
});

// node_modules/oracledb/lib/thin/sqlnet/ANO.js
var require_ANO = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/ANO.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var constants = require_constants4();
    var AUTHENTICATION = 1;
    var ENCRYPTION = 2;
    var DATAINTEGRITY = 3;
    var SUPERVISOR = 4;
    var MAGIC = 3735928559;
    var NO_ERROR = 0;
    var SUPERVISOR_OK = 31;
    var AUTHENTICATION_OK = 64255;
    var AUTHENTICATION_DONT_USE_AUTH = 64511;
    var HEADER_SIZE = 4 + 2 + 4 + 2 + 1;
    var SERVICE_HEADER_SIZE = 2 + 2 + 4;
    var ARRAY_PACKET_SIZE = 4 + 2 + 4;
    var SUBPACKET_SIZE = 4;
    var VERSION_LENGTH = 4;
    var VERSION = 393216e3;
    var STRING_TYPE = 0;
    var RAW_TYPE = 1;
    var UB1_TYPE = 2;
    var UB2_TYPE = 3;
    var VERSION_TYPE = 5;
    var STATUS_TYPE = 6;
    var CID_SIZE = 8;
    var CLIENT_SERVER = 57569;
    var AUTH_NOT_REQUIRED = 64767;
    var AUTH_TCPS_ID = 2;
    var AUTH_TCPS_NAME = "tcps";
    var serviceMap = [-1, 0, 1, 2, 3];
    var NetworkService = class {
      constructor(sAtts) {
        this.flags = constants.NSINAWANTED;
        this.sAtts = sAtts;
      }
      getDataSize() {
        return SERVICE_HEADER_SIZE + SUBPACKET_SIZE + VERSION_LENGTH + SUBPACKET_SIZE;
      }
      sendHeader(buf, pos) {
        pos = buf.writeUInt16BE(this.service, pos);
        pos = buf.writeUInt16BE(this.numSubPackets, pos);
        pos = buf.writeUInt32BE(0, pos);
        return pos;
      }
      sendVersion(buf, pos) {
        pos = buf.writeUInt16BE(4, pos);
        pos = buf.writeUInt16BE(VERSION_TYPE, pos);
        pos = buf.writeUInt32BE(VERSION, pos);
        return pos;
      }
      sendRaw(buf, rawData, length, pos) {
        pos = buf.writeUInt16BE(length, pos);
        pos = buf.writeUInt16BE(RAW_TYPE, pos);
        pos += rawData.copy(buf, pos, 0, length);
        return pos;
      }
      sendArray(buf, array, pos) {
        pos = buf.writeUInt16BE(ARRAY_PACKET_SIZE + array.length * 2, pos);
        pos = buf.writeUInt16BE(RAW_TYPE, pos);
        pos = buf.writeUInt32BE(MAGIC, pos);
        pos = buf.writeUInt16BE(UB2_TYPE, pos);
        pos = buf.writeUInt32BE(array.length, pos);
        for (let i = 0; i < array.length; i++) {
          pos = buf.writeUInt16BE(array[i], pos);
        }
        return pos;
      }
      sendStatus(buf, status, pos) {
        pos = buf.writeUInt16BE(2, pos);
        pos = buf.writeUInt16BE(STATUS_TYPE, pos);
        pos = buf.writeUInt16BE(status, pos);
        return pos;
      }
      sendString(buf, string, pos) {
        pos = buf.writeUInt16BE(string.length, pos);
        pos = buf.writeUInt16BE(STRING_TYPE, pos);
        pos += buf.write(string, pos);
        return pos;
      }
      sendUB1(buf, data, pos) {
        pos = buf.writeUInt16BE(1, pos);
        pos = buf.writeUInt16BE(UB1_TYPE, pos);
        pos = buf.writeUInt8(data, pos);
        return pos;
      }
      sendUB2(buf, data, pos) {
        pos = buf.writeUInt16BE(2, pos);
        pos = buf.writeUInt16BE(UB2_TYPE, pos);
        pos = buf.writeUInt16BE(data, pos);
        return pos;
      }
      static receiveHeader(pkt, ret, pos) {
        ret[0] = pkt.readUInt16BE(pos);
        pos += 2;
        ret[1] = pkt.readUInt16BE(pos);
        pos += 2;
        ret[2] = pkt.readUInt32BE(pos);
        pos += 4;
        return pos;
      }
      receiveType(pkt, type, ret, pos) {
        const len = pkt.readUInt16BE(pos);
        pos += 2;
        const receivedType = pkt.readUInt16BE(pos);
        pos += 2;
        if (receivedType != type) {
          errors.throwErr(errors.ERR_ANO_PACKET);
        }
        let version, status;
        switch (type) {
          case VERSION_TYPE:
            version = pkt.readUInt32BE(pos);
            pos += 4;
            ret[0] = version;
            return pos;
          case STATUS_TYPE:
            status = pkt.readUInt16BE(pos);
            pos += 2;
            ret[0] = status;
            return pos;
          case RAW_TYPE:
            ret[0] = len;
            return pos;
          case STRING_TYPE:
            ret[0] = len;
            return pos;
        }
      }
      receiveUB2Array(pkt, ret, pos) {
        const ret1 = [];
        pos = this.receiveType(pkt, RAW_TYPE, ret1, pos);
        if (pkt.readUInt32BE(pos) != MAGIC) {
          errors.throwErr(errors.ERR_ANO_PACKET);
        }
        pos += 4;
        const type = pkt.readUInt16BE(pos);
        pos += 2;
        if (type != UB2_TYPE) {
          errors.throwErr(errors.ERR_ANO_PACKET);
        }
        const arrayLen = pkt.readUInt32BE(pos);
        pos += 4;
        for (let i = 0; i < arrayLen; i++) {
          ret[i] = pkt.readUInt16BE(pos);
          pos += 2;
        }
        return pos;
      }
      receiveString(pkt, ret, pos) {
        const ret1 = [];
        pos = this.receiveType(pkt, STRING_TYPE, ret1, pos);
        const string = pkt.toString("utf8", pos, pos + ret1[0]);
        pos += ret1[0];
        ret[0] = string;
        return pos;
      }
      receiveServiceData(pkt, numSubPakcets, pos) {
        const ret = [];
        ret[0] = pkt.readUInt16BE(pos);
        pos += 2;
        ret[1] = pkt.readUInt16BE(pos);
        pos += 2;
        ret[2] = pkt.readUInt32BE(pos);
        pos += 4;
        ret[3] = pkt.readUInt16BE(pos);
        pos += 2;
        ret[4] = pkt.readUInt16BE(pos);
        pos += 2;
        ret[5] = pkt.readUInt8(pos);
        pos += 1;
        return pos;
      }
    };
    var SupervisorService = class extends NetworkService {
      constructor(sAtts) {
        super(sAtts);
        this.service = SUPERVISOR;
        this.serviceList = [AUTHENTICATION, ENCRYPTION, DATAINTEGRITY, SUPERVISOR];
        this.numSubPackets = 3;
      }
      getDataSize() {
        return SERVICE_HEADER_SIZE + SUBPACKET_SIZE + VERSION_LENGTH + SUBPACKET_SIZE + CID_SIZE + SUBPACKET_SIZE + ARRAY_PACKET_SIZE + this.serviceList.length * 2;
      }
      sendServiceData(buf, pos) {
        pos = this.sendHeader(buf, pos);
        pos = this.sendVersion(buf, pos);
        pos = this.sendRaw(buf, Buffer.from(this.sAtts.uuid, "base64"), 8, pos);
        pos = this.sendArray(buf, this.serviceList, pos);
        return pos;
      }
      receiveServiceData(pkt, numSubPackets, pos) {
        const serverServices = [], version = [], status = [];
        pos = this.receiveType(pkt, VERSION_TYPE, version, pos);
        pos = this.receiveType(pkt, STATUS_TYPE, status, pos);
        if (status[0] != SUPERVISOR_OK) {
          errors.throwErr(errors.ERR_ANO_STATUS, "Supervisor");
        }
        pos = this.receiveUB2Array(pkt, serverServices, pos);
        return pos;
      }
    };
    var AuthenticationService = class extends NetworkService {
      constructor(sAtts) {
        super(sAtts);
        this.service = AUTHENTICATION;
        this.status = AUTH_NOT_REQUIRED;
        this.numSubPackets = 3 + 1 * 2;
        this.serviceList = [AUTH_TCPS_NAME];
        this.authActivated = false;
      }
      getDataSize() {
        let len = SERVICE_HEADER_SIZE + SUBPACKET_SIZE + VERSION_LENGTH + SUBPACKET_SIZE + 2 + SUBPACKET_SIZE + 2;
        for (let i = 0; i < this.serviceList.length; i++) {
          len += SUBPACKET_SIZE + 1;
          len += SUBPACKET_SIZE + this.serviceList[i].length;
        }
        return len;
      }
      sendServiceData(buf, pos) {
        pos = this.sendHeader(buf, pos);
        pos = this.sendVersion(buf, pos);
        pos = this.sendUB2(buf, CLIENT_SERVER, pos);
        pos = this.sendStatus(buf, this.status, pos);
        pos = this.sendUB1(buf, AUTH_TCPS_ID, pos);
        pos = this.sendString(buf, AUTH_TCPS_NAME, pos);
        return pos;
      }
      receiveServiceData(pkt, numSubPackets, pos) {
        const version = [], status = [], service = [];
        pos = this.receiveType(pkt, VERSION_TYPE, version, pos);
        pos = this.receiveType(pkt, STATUS_TYPE, status, pos);
        if (status[0] == AUTHENTICATION_OK && numSubPackets > 2) {
          pos += 5;
          pos = this.receiveString(pkt, service, pos);
          this.authActivated = true;
        } else if (status[0] == AUTHENTICATION_DONT_USE_AUTH) {
          this.authActivated = false;
        } else {
          errors.throwErr(errors.ERR_ANO_STATUS, "Authentication");
        }
        return pos;
      }
    };
    var EncryptionService = class extends NetworkService {
      constructor(sAtts) {
        super(sAtts);
        this.service = ENCRYPTION;
        this.numSubPackets = 2;
      }
      getDataSize() {
        return SERVICE_HEADER_SIZE + SUBPACKET_SIZE + VERSION_LENGTH + SUBPACKET_SIZE + 1;
      }
      sendServiceData(buf, pos) {
        pos = this.sendHeader(buf, pos);
        pos = this.sendVersion(buf, pos);
        const drivers = Buffer.from([0]);
        pos = this.sendRaw(buf, drivers, 1, pos);
        return pos;
      }
    };
    var DataIntegrityService = class extends NetworkService {
      constructor(sAtts) {
        super(sAtts);
        this.service = DATAINTEGRITY;
        this.numSubPackets = 2;
      }
      getDataSize() {
        return SERVICE_HEADER_SIZE + SUBPACKET_SIZE + VERSION_LENGTH + SUBPACKET_SIZE + 1;
      }
      sendServiceData(buf, pos) {
        pos = this.sendHeader(buf, pos);
        pos = this.sendVersion(buf, pos);
        const drivers = Buffer.from([0]);
        pos = this.sendRaw(buf, drivers, 1, pos);
        return pos;
      }
    };
    var ANO = class {
      constructor(sAtts) {
        this.serviceList = [
          new AuthenticationService(sAtts),
          new EncryptionService(sAtts),
          new DataIntegrityService(sAtts),
          new SupervisorService(sAtts)
        ];
      }
      sendPacket() {
        let bufSize = HEADER_SIZE;
        for (let i = 0; i < this.serviceList.length; i++) {
          bufSize += this.serviceList[i].getDataSize();
        }
        const buf = Buffer.allocUnsafe(bufSize).fill(0);
        let pos = buf.writeUInt32BE(MAGIC);
        pos = buf.writeUInt16BE(bufSize, pos);
        pos = buf.writeUInt32BE(VERSION, pos);
        pos = buf.writeUInt16BE(this.serviceList.length, pos);
        pos = buf.writeUInt8(0, pos);
        pos = this.serviceList[3].sendServiceData(buf, pos);
        pos = this.serviceList[0].sendServiceData(buf, pos);
        pos = this.serviceList[1].sendServiceData(buf, pos);
        this.serviceList[2].sendServiceData(buf, pos);
        return buf;
      }
      processPacket(pkt) {
        let pos = 10;
        if (pkt.readUInt32BE(pos) != MAGIC) {
          errors.throwErr(errors.ERR_ANO_PACKET);
        }
        pos += 4;
        pos += 2;
        pos += 4;
        const services = pkt.readUInt16BE(pos);
        pos += 2;
        pos += 1;
        const ret = [];
        for (let i = 0; i < services; i++) {
          pos = NetworkService.receiveHeader(pkt, ret, pos);
          if (ret[2] != NO_ERROR) {
            errors.throwErrWithORAError(errors.ERR_ANO_NEGOTIATION, ret[2]);
          }
          const serviceId = serviceMap[ret[0]];
          pos = this.serviceList[serviceId].receiveServiceData(pkt, ret[1], pos);
        }
      }
    };
    function getFlags(protocol, userConfig) {
      if (protocol.toUpperCase() == "TCPS" && userConfig.externalAuth && !userConfig.token)
        return constants.NSINAWANTED;
      else
        return constants.NSINANOSERVICES;
    }
    module2.exports = { ANO, getFlags };
  }
});

// node_modules/oracledb/lib/thin/sqlnet/sessionAtts.js
var require_sessionAtts = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/sessionAtts.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var path8 = require("path");
    var constants = require_constants4();
    var fs4 = require("fs");
    var { getFlags } = require_ANO();
    async function genuuid() {
      return await new Promise((resolve3, reject) => {
        crypto.randomBytes(16, (err, buf) => {
          if (err) {
            reject(err);
          } else {
            resolve3(buf);
          }
        });
      });
    }
    var SessionAtts = class {
      constructor(uuid) {
        this.largeSDU = false;
        this.tdu = constants.NSPDFTDULN;
        this.nt = {};
        this.nt.tcpNoDelay = true;
        this.uuid = uuid;
        this.nt.sslServerDNMatch = true;
        this.nt.sslAllowWeakDNMatch = false;
        this.nt.useSNI = false;
        this.networkCompressionThreshold = 1024;
      }
      /**
       * Update Session attributes with input Parameters
       * @param {object} Params Input paramters
       */
      setFrom(params) {
        if (params) {
          if (params.sdu > 0) {
            this.sdu = parseInt(params.sdu);
          }
          if (typeof params.networkCompression == "boolean") {
            this.networkCompression = params.networkCompression;
            this.networkCompressionLevels = [];
            if (params.networkCompressionLevels) {
              if (params.networkCompressionLevels.includes("high"))
                this.networkCompressionLevels.push("high");
              if (params.networkCompressionLevels.length == 0)
                this.networkCompressionLevels.push("high");
            }
          }
          if (params.networkCompressionThreshold >= 200) {
            this.networkCompressionThreshold = parseInt(params.networkCompressionThreshold);
          }
          if (typeof params.walletLocation === "string") {
            this.nt.walletFile = path8.join(params.walletLocation, constants.PEM_WALLET_FILE_NAME);
          }
          if (typeof params.walletPassword === "string") {
            this.nt.walletPassword = params.walletPassword;
          }
          if (typeof params.walletContent === "string") {
            this.nt.wallet = params.walletContent;
          }
          if (params.expireTime > 0) {
            this.nt.expireTime = params.expireTime * 1e3 * 60;
          }
          if (params.connectTimeout > 0) {
            this.connectTimeout = params.connectTimeout * 1e3;
          }
          if (params.transportConnectTimeout > 0) {
            this.transportConnectTimeout = params.transportConnectTimeout * 1e3;
          }
          if (params.recvTimeout > 0) {
            this.recvTimeout = params.recvTimeout * 1e3;
          }
          if (params.sendTimeout > 0) {
            this.sendTimeout = params.sendTimeout * 1e3;
          }
          if (typeof params.connectionIdPrefix === "string") {
            this.connectionIdPrefix = params.connectionIdPrefix;
          }
          if (typeof params.tcpNoDelay === "boolean") {
            this.nt.tcpNoDelay = params.tcpNoDelay;
          }
          if (typeof params.sslServerDNMatch === "boolean") {
            this.nt.sslServerDNMatch = params.sslServerDNMatch;
          }
          if (typeof params.sslAllowWeakDNMatch === "boolean") {
            this.nt.sslAllowWeakDNMatch = params.sslAllowWeakDNMatch;
          }
          if (typeof params.sslServerCertDN === "string") {
            this.nt.sslServerCertDN = params.sslServerCertDN;
          }
          if (typeof params.enable === "string" && params.enable.toUpperCase() == "BROKEN") {
            this.nt.enabledDCD = true;
          }
          if (typeof params.httpsProxy === "string") {
            this.nt.httpsProxy = params.httpsProxy;
          }
          if (params.httpsProxyPort >= 0) {
            this.nt.httpsProxyPort = parseInt(params.httpsProxyPort);
          }
          if (typeof params.useSNI === "boolean") {
            this.nt.useSNI = params.useSNI;
          }
        }
      }
      /**
       * Read wallet
       * @returns Promise
       */
      readWalletFile() {
        return new Promise((resolve3, reject) => {
          fs4.readFile(this.nt.walletFile, (err, data) => {
            if (err) {
              reject(err);
            } else {
              resolve3(data);
            }
          });
        });
      }
      /**
       * Clear wallet
       */
      clearWallet() {
        if (this.nt.wallet && Buffer.isBuffer(this.nt.wallet))
          this.nt.wallet.fill(0);
        this.nt.wallet = null;
      }
      /**
       * Prepare attributes for connection, Generate Connection ID and read Wallet file
       *
       */
      async prepare(protocol, userConfig) {
        if (!this.uuid) {
          this.uuid = await genuuid();
          this.uuid = this.uuid.toString("base64");
        }
        if (this.connectionIdPrefix) {
          this.connectionId = this.connectionIdPrefix + this.uuid;
        } else {
          this.connectionId = this.uuid;
        }
        this.nt.connectionId = this.connectionId;
        if (protocol && (protocol.toUpperCase() == "TCPS" && !this.nt.wallet && this.nt.walletFile)) {
          this.nt.wallet = await this.readWalletFile();
        }
        if (!this.connectTimeout && !this.transportConnectTimeout)
          this.transportConnectTimeout = constants.DEFAULT_TRANSPORT_CONNECT_TIMEOUT;
        this.NAFlags = getFlags(protocol, userConfig);
      }
    };
    module2.exports = SessionAtts;
  }
});

// node_modules/oracledb/lib/thin/util.js
var require_util2 = __commonJS({
  "node_modules/oracledb/lib/thin/util.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var errors = require_errors();
    var os = require("os");
    var nodbUtil = require_util();
    function populateClientInfo() {
      this.program = nodbUtil.sanitize(process.argv0);
      this.terminal = "unknown";
      this.pid = process.pid.toString();
      try {
        this.userName = nodbUtil.sanitize(os.userInfo().username);
      } catch {
        this.userName = "unknown";
      }
      this.hostName = nodbUtil.sanitize(os.hostname());
    }
    var CLIENT_INFO = new populateClientInfo();
    function getMetadataMany(vars) {
      const metadata = [];
      for (const queryVar of vars) {
        metadata.push(queryVar.fetchInfo);
      }
      return metadata;
    }
    function getOutBindValues(bindVars, pos) {
      const bindByPos = bindVars[0].name === void 0;
      const outBindValues = bindByPos ? [] : {};
      for (let i = 0; i < bindVars.length; i++) {
        if (bindByPos) {
          outBindValues.push(bindVars[i].values[pos]);
        } else {
          outBindValues[bindVars[i].name] = bindVars[i].values[pos];
        }
      }
      return outBindValues;
    }
    function getOutBinds(statement, numIters, executeManyFlag) {
      const bindVars = statement.bindInfoList.map((i) => i.bindVar);
      const outBinds = bindVars.filter((v) => v.dir !== constants.BIND_IN);
      if (outBinds.length > 0) {
        if (executeManyFlag) {
          const outBindValues = new Array(numIters);
          for (let i = 0; i < numIters; i++) {
            outBindValues[i] = getOutBindValues(outBinds, i);
          }
          return outBindValues;
        }
        return getOutBindValues(outBinds, 0);
      }
    }
    function checkProxyUserValidity(userName) {
      let schemaUser = "", proxyUser = "";
      let quoteFound = false, openSquareBracketFound = false;
      let lastQuoteFoundIndex = 0;
      const result = {
        status: -1,
        proxyUser: "",
        schemaUser: ""
      };
      const userNameLength = userName.length;
      let index = 0, i, j;
      while (index < userNameLength) {
        if (userName.charAt(index) === '"') {
          quoteFound = !quoteFound;
          lastQuoteFoundIndex = index;
        }
        if (userName.charAt(index) === "[" && !quoteFound) {
          openSquareBracketFound = true;
          if (lastQuoteFoundIndex != 0) {
            for (i = lastQuoteFoundIndex + 1; i < index; i++) {
              if (userName.charAt(i) !== " ") {
                return result;
              }
            }
            for (i = 0; i <= lastQuoteFoundIndex; i++) {
              proxyUser += userName.charAt(i);
            }
          } else {
            for (i = 0; i < index; i++) {
              if (userName.charAt(i) !== " ") {
                proxyUser += userName.charAt(i);
              } else {
                break;
              }
            }
          }
          break;
        }
        index++;
      }
      if (proxyUser.length != 0) {
        result.proxyUser = proxyUser;
      }
      index = index + 1;
      quoteFound = false;
      const schemaUserStartIndex = index;
      lastQuoteFoundIndex = 0;
      while (index < userNameLength) {
        if (userName.charAt(index) === '"') {
          quoteFound = !quoteFound;
          lastQuoteFoundIndex = index;
        }
        if (userName.charAt(index) === "[" && !quoteFound && openSquareBracketFound) {
          return result;
        }
        if (userName.charAt(index) === "]" && !quoteFound) {
          if (lastQuoteFoundIndex != schemaUserStartIndex && lastQuoteFoundIndex != 0) {
            for (i = schemaUserStartIndex; i <= lastQuoteFoundIndex; i++) {
              schemaUser += userName.charAt(i);
            }
            for (i = lastQuoteFoundIndex + 1; i < index; i++) {
              if (userName.charAt(i) != " ") {
                return result;
              }
            }
          } else {
            for (i = schemaUserStartIndex; i < index; i++) {
              if (userName.charAt(i) != " ") {
                break;
              }
            }
            if (i == index) {
              return result;
            }
            for (j = i; j < index; j++) {
              schemaUser += userName[j];
            }
          }
          for (i = index + 1; i < userNameLength; i++) {
            if (userName[i] != " ") {
              return result;
            }
          }
        }
        index++;
      }
      if (schemaUser.length === 0) {
        return result;
      } else {
        result.schemaUser = schemaUser;
      }
      result.status = 0;
      return result;
    }
    function checkCredentials(params) {
      if (params.externalAuth === false) {
        if (params.password === void 0) {
          errors.throwErr(errors.ERR_MISSING_CREDENTIALS);
        }
      }
    }
    function normalizePrivateKey(privateKey) {
      return "-----BEGIN PRIVATE KEY-----\n" + privateKey + "\n-----END PRIVATE KEY-----";
    }
    module2.exports = {
      getMetadataMany,
      CLIENT_INFO,
      getOutBinds,
      checkProxyUserValidity,
      checkCredentials,
      normalizePrivateKey
    };
  }
});

// node_modules/oracledb/lib/thin/sqlnet/navNodes.js
var require_navNodes = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/navNodes.js"(exports2, module2) {
    "use strict";
    var { findNVPairRecurse, createNVPair } = require_nvStrToNvPair();
    var errors = require_errors();
    var os = require("os");
    var net = require("net");
    var dns = require("dns");
    var dnsPromises = dns.promises;
    var cInfo = require_util2().CLIENT_INFO;
    var SchemaObjectFactoryInterface = {
      ADDR: 0,
      ADDR_LIST: 1,
      DESC: 2,
      DESC_LIST: 3
    };
    var Address = class {
      /** return the type of this SchemaObject */
      isS() {
        return SchemaObjectFactoryInterface.ADDR;
      }
      /** initialize this object from the given string
       * @param string the string
       *  Error thrown if invalid NV-string format (ie, bad parens)
       *  Error thrown if invalid syntax
       *               (ie, "(ADDRESS=(DESCRIPTION=...)) and  ")
       */
      initFromString(s) {
        const nvp = createNVPair(s);
        this.initFromNVPair(nvp);
      }
      /** initialize this object from an NVPair
       * @param nvp the NVPair
       * Error thrown if invalid syntax
       *               (ie, "(ADDRESS=(DESCRIPTION=...))")
       */
      initFromNVPair(nvp) {
        if (nvp == null || !(nvp.name.toUpperCase() == "ADDRESS"))
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        const protnvp = findNVPairRecurse(nvp, "protocol");
        const portnvp = findNVPairRecurse(nvp, "port");
        const hostnvp = findNVPairRecurse(nvp, "host");
        const httpsProxyNVP = findNVPairRecurse(nvp, "https_proxy");
        const httpsProxyPortNVP = findNVPairRecurse(nvp, "https_proxy_port");
        if (portnvp)
          this.port = Number(portnvp.atom);
        if (hostnvp)
          this.host = hostnvp.atom;
        if (protnvp)
          this.prot = protnvp.atom;
        if (httpsProxyNVP)
          this.httpsProxy = httpsProxyNVP.atom;
        if (httpsProxyPortNVP)
          this.httpsProxyPort = Number(httpsProxyPortNVP.atom);
        this.addr = nvp.toString();
      }
      /** return the string representation of this object */
      toString() {
        return this.addr;
      }
    };
    var AddressList = class {
      constructor() {
        this.children = new Array();
        this.sourceRoute = false;
        this.loadBalance = false;
        this.failover = true;
      }
      /** return the type of this SchemaObject */
      isS() {
        return SchemaObjectFactoryInterface.ADDR_LIST;
      }
      /** initialize this object from the given string
       * @param string the string
       *  Error thrown if invalid NV-string format (ie, bad parens)
       *  Error thrown if invalid syntax
       *               (ie, "(ADDRESS=(DESCRIPTION=...))")
       */
      initFromString(s) {
        const nvp = createNVPair(s);
        this.initFromNVPair(nvp);
      }
      /** initialize this object from an NVPair
       * @param nvp the NVPair
       * Error thrown if invalid syntax
       *               (ie, "(ADDRESS=(DESCRIPTION=...))")
       */
      initFromNVPair(nvp) {
        this.children = [];
        let childnv, child;
        const listsize = nvp.getListSize();
        if (listsize == 0)
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        for (let i = 0; i < listsize; i++) {
          childnv = nvp.getListElement(i);
          if (childnv.name.toUpperCase() == "SOURCE_ROUTE") {
            this.sourceRoute = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "LOAD_BALANCE") {
            this.loadBalance = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "FAILOVER") {
            this.failover = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "ADDRESS") {
            child = new NavAddress();
            child.initFromNVPair(childnv);
            this.children.push(child);
          } else if (childnv.name.toUpperCase() == "ADDRESS_LIST") {
            child = new NavAddressList();
            child.initFromNVPair(childnv);
            this.children.push(child);
          } else errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        if (this.children.length == 0) errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
      }
      /** return the string representation of this object */
      toString() {
        let s = new String("");
        if (this.children.size() < 1)
          return s;
        s += "(ADDRESS_LIST=";
        for (let i = 0; i < this.children.size(); i++)
          s += this.children[i].toString();
        if (this.sourceRoute) s += "(SOURCE_ROUTE=yes)" + NavSchemaObject.HC;
        if (this.loadBalance) s += "(LOAD_BALANCE=yes)";
        if (!this.failover) s += "(FAILOVER=false)";
        s += ")";
        return s;
      }
    };
    var Description = class {
      // description-level stuff
      constructor() {
        this.children = new Array();
        this.sourceRoute = false;
        this.loadBalance = false;
        this.failover = true;
        this.delayInMillis = -1;
        this.params = {};
      }
      /**
        * Return the type of this SchemaObject
       */
      isS() {
        return SchemaObjectFactoryInterface.DESC;
      }
      /**
        * Initialize this object from the given string
        *
        * @param string
        *          the string
        * Error rhrown if invalid NV-string format (ie, bad parens)
        * Error thrown if invalid syntax (ie, "(ADDRESS=(DESCRIPTION=...))")
      */
      initFromString(s) {
        const nvp = createNVPair(s);
        this.initFromNVPair(nvp);
      }
      /** initialize this object from an NVPair
       * @param nvp the NVPair
       * Error thrown if invalid syntax
       *               (ie, "(ADDRESS=(DESCRIPTION=...))")
       */
      //errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
      initFromNVPair(nvp) {
        const listsize = nvp.getListSize();
        let childnv, child;
        if (listsize == 0)
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        for (let i = 0; i < listsize; i++) {
          childnv = nvp.getListElement(i);
          if (childnv.name.toUpperCase() == "SOURCE_ROUTE") {
            this.sourceRoute = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "LOAD_BALANCE") {
            this.loadBalance = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "FAILOVER") {
            this.failover = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "USE_SNI") {
            this.params.useSNI = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "ADDRESS_LIST") {
            child = new NavAddressList();
            child.initFromNVPair(childnv);
            this.children.push(child);
          } else if (childnv.name.toUpperCase() == "ADDRESS") {
            child = new NavAddress();
            child.initFromNVPair(childnv);
            this.children.push(child);
          } else if (childnv.name.toUpperCase() == "CONNECT_DATA") {
            let tmpnv;
            const listsize2 = childnv.getListSize();
            for (let i2 = 0; i2 < listsize2; i2++) {
              tmpnv = childnv.getListElement(i2);
              if (tmpnv.name.toUpperCase() == "CONNECTION_ID_PREFIX") {
                this.params.connectionIdPrefix = tmpnv.atom;
                childnv.removeListElement(i2);
                break;
              }
            }
            this.connectData = childnv.valueToString();
          } else if (childnv.name.toUpperCase() == "RETRY_DELAY") {
            if (childnv.atom > 0)
              this.delayInMillis = childnv.atom * 1e3;
          } else if (childnv.name.toUpperCase() == "RETRY_COUNT") {
            this.retryCount = childnv.atom;
          } else if (childnv.name.toUpperCase() == "CONNECTION_ID_PREFIX") {
            this.conidPrefix = childnv.atom;
          } else if (childnv.name.toUpperCase() == "CONNECT_TIMEOUT") {
            if (childnv.atom > 0)
              this.params.connectTimeout = childnv.atom;
          } else if (childnv.name.toUpperCase() == "TRANSPORT_CONNECT_TIMEOUT") {
            if (childnv.atom > 0)
              this.params.transportConnectTimeout = childnv.atom;
          } else if (childnv.name.toUpperCase() == "ENABLE") {
            this.params.enable = childnv.atom;
          } else if (childnv.name.toUpperCase() == "RECV_TIMEOUT") {
            if (childnv.atom > 0) {
              this.params.recvTimeout = childnv.atom;
            }
          } else if (childnv.name.toUpperCase() == "SDU") {
            this.params.sdu = childnv.atom;
          } else if (childnv.name.toUpperCase() == "COMPRESSION") {
            this.params.networkCompression = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
            this.params.networkCompressionLevels = [];
          } else if (childnv.name.toUpperCase() == "COMPRESSION_LEVELS") {
            const listsize2 = childnv.getListSize();
            for (let i2 = 0; i2 < listsize2; i2++) {
              const tmpnv = childnv.getListElement(i2);
              if (tmpnv.name.toUpperCase() == "LEVEL") {
                this.params.networkCompressionLevels.push(tmpnv.atom.toLowerCase());
              }
            }
          } else if (childnv.name.toUpperCase() == "EXPIRE_TIME") {
            if (childnv.atom > 0)
              this.params.expireTime = childnv.atom;
          } else if (childnv.name.toUpperCase() == "SECURITY") {
            const listsize2 = childnv.getListSize();
            let tmpnv;
            for (let i2 = 0; i2 < listsize2; i2++) {
              tmpnv = childnv.getListElement(i2);
              if (tmpnv.name.toUpperCase() == "SSL_SERVER_CERT_DN") {
                this.params.sslServerCertDN = tmpnv.valueToString();
              } else if (tmpnv.name.toUpperCase() == "SSL_SERVER_DN_MATCH") {
                this.params.sslServerDNMatch = tmpnv.atom.toLowerCase() == "yes" || tmpnv.atom.toLowerCase() == "on" || tmpnv.atom.toLowerCase() == "true";
              } else if (tmpnv.name.toUpperCase() == "SSL_ALLOW_WEAK_DN_MATCH") {
                this.params.sslAllowWeakDNMatch = tmpnv.atom.toLowerCase() == "yes" || tmpnv.atom.toLowerCase() == "on" || tmpnv.atom.toLowerCase() == "true";
              } else if (tmpnv.name.toUpperCase() == "WALLET_LOCATION" || tmpnv.name.toUpperCase() == "MY_WALLET_DIRECTORY") {
                this.params.walletLocation = tmpnv.atom;
              }
            }
          }
        }
      }
      toString() {
        let s = new String(""), child;
        child = new String("");
        for (let i = 0; i < this.children.size(); i++) {
          child = this.children[i].toString();
          if (!child == "")
            s += child;
        }
        if (!s == "" && this.sourceRoute)
          s += "(SOURCE_ROUTE=yes)";
        if (!s == "" && this.loadBalance)
          s += "(LOAD_BALANCE=yes)";
        if (!s == "" && !this.failover)
          s += "(FAILOVER=false)";
        if (!s.equals(""))
          s = "(DESCRIPTION=" + s + ")";
        return s;
      }
    };
    var DescriptionList = class {
      constructor() {
        this.children = new Array();
        this.sourceRoute = false;
        this.loadBalance = true;
        this.failover = true;
      }
      /** return the type of this SchemaObject */
      isS() {
        return SchemaObjectFactoryInterface.ADDR_LIST;
      }
      /** initialize this object from the given string
       * @param string the string
       * Error thrown if invalid NV-string format (ie, bad parens)
       * Error thrown if invalid syntax
       *               (ie, "(ADDRESS=(DESCRIPTION=...))")
       */
      initFromString(s) {
        const nvp = createNVPair(s);
        this.initFromNVPair(nvp);
      }
      /** initialize this object from an NVPair
       * @param nvp the NVPair
       * Error thrown if invalid syntax
       *               (ie, "(ADDRESS=(DESCRIPTION=...))")
       */
      initFromNVPair(nvp) {
        const listsize = nvp.getListSize();
        let child, childnv;
        if (listsize == 0)
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        for (let i = 0; i < listsize; i++) {
          childnv = nvp.getListElement(i);
          if (childnv.name.toUpperCase() == "SOURCE_ROUTE") {
            this.sourceRoute = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase == "true";
          } else if (childnv.name.toUpperCase() == "LOAD_BALANCE") {
            this.loadBalance = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "FAILOVER") {
            this.failover = childnv.atom.toLowerCase() == "yes" || childnv.atom.toLowerCase() == "on" || childnv.atom.toLowerCase() == "true";
          } else if (childnv.name.toUpperCase() == "DESCRIPTION") {
            child = new NavDescription();
            child.initFromNVPair(childnv);
            this.children.push(child);
          } else errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
        }
        if (this.children.length == 0) errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);
      }
      /** return the string representation of this object */
      toString() {
        let s = new String("");
        if (this.children.size() < 1)
          return s;
        let child = new String("");
        for (let i = 0; i < this.children.size(); i++) {
          child = this.children[i].toString();
          if (!child.equals(""))
            s += child;
        }
        if (s.equals("") && this.sourceRoute) s += "(SOURCE_ROUTE=yes)";
        if (s.equals("") && !this.loadBalance) s += "(LOAD_BALANCE=no)";
        if (s.equals("") && !this.failover) s += "(FAILOVER=false)";
        if (!s.equals(""))
          s = "(DESCRIPTION_LIST=" + s + ")";
        return s;
      }
    };
    var ConnOption = class {
      constructor() {
        this.CNdata = new Array();
      }
    };
    var NavSchemaObject = {
      DEBUG: false,
      SR: "(SOURCE_ROUTE=yes)",
      HC: "(HOP_COUNT=0)",
      LB: "(LOAD_BALANCE=yes)",
      NFO: "(FAILOVER=false)",
      CD: "(CONNECT_DATA=",
      CONID: "(CONNECTION_ID="
    };
    var options = {
      all: true
    };
    var NavAddress = class extends Address {
      constructor() {
        super();
      }
      /**
       * Set the connection option to this address.
       * @param {object} cs
       */
      async navigate(cs) {
        let addresses;
        let nullHost = false;
        let needToCloseDescription = false;
        if (!this.host) {
          nullHost = true;
          this.host = os.hostname();
          try {
            await dnsPromises.lookup(this.host, options);
          } catch {
            this.host = "localhost";
          }
        }
        if (cs.getcurrentDescription() == null) {
          cs.newConnectionDescription();
          needToCloseDescription = true;
        }
        if (!net.isIP(this.host) && !(cs.httpsProxy || this.httpsProxy)) {
          try {
            addresses = await dnsPromises.lookup(this.host, options);
            for (const addr of addresses) {
              const co = new ConnOption();
              co.hostname = this.host;
              co.port = this.port;
              co.protocol = this.prot;
              co.httpsProxy = this.httpsProxy;
              co.httpsProxyPort = this.httpsProxyPort;
              co.desc = cs.getcurrentDescription();
              co.CNdata.push(cs.sBuf.join(""));
              if (nullHost)
                co.CNdata.push("(address=(protocol=" + this.prot + ")(host=" + this.host + ")(port=" + this.port + "))");
              else
                co.CNdata.push(this.toString());
              co.host = addr.address;
              co.addr = this.addr;
              cs.getcurrentDescription().addConnectOption(co);
            }
          } catch {
          }
        } else {
          const co = new ConnOption();
          co.hostname = this.host;
          co.port = this.port;
          co.protocol = this.prot;
          co.httpsProxy = this.httpsProxy;
          co.httpsProxyPort = this.httpsProxyPort;
          co.desc = cs.getcurrentDescription();
          co.CNdata.push(cs.sBuf.join(""));
          co.CNdata.push(this.toString());
          co.host = this.host;
          co.addr = this.addr;
          cs.getcurrentDescription().addConnectOption(co);
        }
        if (needToCloseDescription) {
          cs.closeDescription();
        }
      }
      /**
       * AddToString is used to construct a string representation of the TNS
       * Address. Constructing a string is mainly needed when source route is ON.
       */
      addToString(cs) {
        const NVString = this.toString();
        let cOpts = new Array();
        cOpts = cs.getcurrentDescription().getConnectOptions();
        for (let i = 0; i < cOpts.length; i++) {
          if (cOpts[i].done) {
            continue;
          }
          cOpts[i].CNdata.push(NVString);
        }
      }
    };
    var NavAddressList = class extends AddressList {
      constructor() {
        super();
        this.activeChildren = new Array();
        this.sBuflength = 0;
      }
      /**
       * Method decides how to traverse and sets the active children based on
       * the loadbalancing, failover values.
       * @param {object} cs
       */
      async navigate(cs) {
        await this.navigate2(cs, 0);
      }
      async navigate2(cs, reCurCnt) {
        reCurCnt++;
        this.sBuflength = cs.sBuf.length;
        cs.sBuf.push("(ADDRESS_LIST=");
        if (this.sourceRoute) {
          this.activeChildren = this.children;
          await this.activeChildren[0].navigate(cs);
          for (let i = 1; i < this.activeChildren.length; i++) {
            this.activeChildren[i].addToString(cs);
          }
        } else {
          this.activeChildren = NavDescriptionList.setActiveChildren(
            this.children,
            this.failover,
            this.loadBalance
          );
          for (let i = 0; i < this.activeChildren.length; i++) {
            if (this.getChildrenType(i) == 1) {
              await this.activeChildren[i].navigate2(cs, reCurCnt);
            } else {
              await this.activeChildren[i].navigate(cs);
            }
          }
        }
        this.closeNVPair(cs);
        cs.sBuf.length = this.sBuflength;
      }
      addToString(cs) {
        const NVString = this.toString();
        let cOpts = new Array();
        cOpts = cs.getcurrentDescription().getConnectOptions();
        for (let i = 0; i < cOpts.length; i++) {
          if (cOpts[i].done) {
            continue;
          }
          cOpts[i].CNdata.push(NVString);
        }
      }
      getChildrenSize() {
        let size = 0;
        for (let i = 0; i < this.activeChildren.length; i++) {
          if (this.getChildrenType(i) == 1) {
            size += this.activeChildren[i].getChildrenSize();
          } else {
            size++;
          }
          if (this.sourceRoute)
            return size;
        }
        return size;
      }
      /**
       * get children type
      */
      getChildrenType(childNum) {
        return this.activeChildren[childNum].isS();
      }
      /**
       *get child at a given pos
      */
      getChild(childNum) {
        return this.children[childNum];
      }
      closeNVPair(cs) {
        let cOpts = new Array();
        const childS = this.getChildrenSize();
        if (cs.getcurrentDescription() != null) {
          cOpts = cs.getcurrentDescription().getConnectOptions();
          let numChildren = 0;
          let prevHost = null;
          let prevPort = null;
          for (let i = cOpts.length - 1; i >= 0 && !cOpts[i].done; i--) {
            if (cOpts[i].hostname != prevHost || cOpts[i].port != prevPort)
              numChildren++;
            prevHost = cOpts[i].hostname;
            prevPort = cOpts[i].port;
            if (numChildren > childS) {
              break;
            }
            if (this.sourceRoute) {
              cOpts[i].CNdata.push(NavSchemaObject.SR);
              cOpts[i].CNdata.push(NavSchemaObject.HC);
              cOpts[i].done = true;
            }
            cOpts[i].CNdata.push(")");
          }
        }
      }
    };
    var NavDescription = class extends Description {
      constructor() {
        super();
        this.activeChildren = new Array();
        this.descProcessed = 0;
      }
      /**
      * Method decides how to traverse and sets the active children based on
      * the loadbalancing, failover values. Also creates connection description
      * object.
      * @param {object} cs
      */
      async navigate(cs) {
        cs.sBuf.length = 0;
        cs.sBuf.push("(DESCRIPTION=");
        const desc = cs.newConnectionDescription();
        if (this.retryCount != null) {
          cs.retryCount = this.getIntValue(this.retryCount, cs.retryCount);
          desc.retryCount = cs.retryCount;
        }
        if (this.delayInMillis != -1) {
          desc.delayInMillis = this.delayInMillis;
        }
        desc.params = this.params;
        if ("connectTimeout" in this.params) {
          cs.sBuf.push("(CONNECT_TIMEOUT=" + this.params.connectTimeout + ")");
        }
        if ("transportConnectTimeout" in this.params) {
          cs.sBuf.push("(TRANSPORT_CONNECT_TIMEOUT=" + this.params.transportConnectTimeout + ")");
        }
        if ("recvTimeout" in this.params) {
          cs.sBuf.push("(RECV_TIMEOUT=" + this.params.recvTimeout + ")");
        }
        if ("sdu" in this.params) {
          cs.sBuf.push("(SDU=" + this.params.sdu + ")");
        }
        if ("expireTime" in this.params) {
          cs.sBuf.push("(EXPIRE_TIME=" + this.params.expireTime + ")");
        }
        if ("enable" in this.params) {
          cs.sBuf.push("(ENABLE=" + this.params.enable + ")");
        }
        if ("useSNI" in this.params) {
          cs.sBuf.push("(USE_SNI=" + this.params.useSNI + ")");
        }
        if ("sslServerCertDN" in this.params || "sslServerDNMatch" in this.params || "walletLocation" in this.params || "sslAllowWeakDNMatch" in this.params) {
          cs.sBuf.push("(SECURITY=");
          if ("sslServerCertDN" in this.params) {
            cs.sBuf.push("(SSL_SERVER_CERT_DN=" + this.params.sslServerCertDN + ")");
          }
          if ("sslServerDNMatch" in this.params) {
            cs.sBuf.push("(SSL_SERVER_DN_MATCH=" + this.params.sslServerDNMatch + ")");
          }
          if ("sslAllowWeakDNMatch" in this.params) {
            cs.sBuf.push("(SSL_ALLOW_WEAK_DN_MATCH=" + this.params.sslAllowWeakDNMatch + ")");
          }
          if ("walletLocation" in this.params) {
            cs.sBuf.push("(WALLET_LOCATION=" + this.params.walletLocation + ")");
          }
          cs.sBuf.push(")");
        }
        if ("httpsProxyPort" in this.params) {
          cs.sBuf.push("(HTTPS_PROXY_PORT=" + this.params.httpsProxyPort + ")");
        }
        if ("httpsProxy" in this.params) {
          cs.sBuf.push("(HTTPS_PROXY=" + this.params.httpsProxy + ")");
        }
        if (!this.failover) {
          cs.sBuf.push(NavSchemaObject.NFO);
        }
        if (!this.sourceRoute) {
          this.activeChildren = NavDescriptionList.setActiveChildren(
            this.children,
            this.failover,
            this.loadBalance
          );
          for (let i = 0; i < this.activeChildren.length; i++) {
            await this.activeChildren[i].navigate(cs);
          }
          this.closeNVPair(cs);
        } else {
          this.activeChildren = this.children;
          await this.activeChildren[0].navigate(cs);
          for (let i = 1; i < this.activeChildren.length; i++) {
            this.activeChildren[i].addToString(cs);
          }
          this.closeNVPair(cs);
        }
        cs.closeDescription();
      }
      closeNVPair(cs) {
        if (cs.getcurrentDescription() == null)
          return;
        let cOpts = new Array();
        cOpts = cs.getcurrentDescription().getConnectOptions();
        for (let i = 0; i < cOpts.length; ++i) {
          if (this.sourceRoute) {
            cOpts[i].CNdata.push(NavSchemaObject.SR);
          }
          if (this.connectData == null) {
            this.connectData = "(SERVICE_NAME=)";
          }
          let pgmName = cInfo.program;
          if (cs.program) {
            pgmName = cs.program;
          }
          let hostName = cInfo.hostName;
          if (cs.machine) {
            hostName = cs.machine;
          }
          let userName = cInfo.userName;
          if (cs.osUser) {
            userName = cs.osUser;
          }
          const cid = `(CID=(PROGRAM=${pgmName})(HOST=${hostName})(USER=${userName}))`;
          cOpts[i].CNdata.push(NavSchemaObject.CD);
          cOpts[i].CNdata.push(this.connectData);
          cOpts[i].CNdata.push(cid);
          cOpts[i].CNdata.push(")");
          if (this.SID != null) {
            cOpts[i].sid = this.SID;
          }
          if (this.serviceName != null) {
            cOpts[i].service_name = this.serviceName;
          }
          if (this.instanceName != null) {
            cOpts[i].instance_name = this.instanceName;
          }
          cOpts[i].CNdata.push(")");
          cOpts[i].done = true;
        }
      }
      getIntValue(stringInt, defaultValue) {
        if (/^\d+$/.test(stringInt))
          return parseInt(stringInt);
        return defaultValue;
      }
    };
    var NavDescriptionList = class _NavDescriptionList extends DescriptionList {
      constructor(activeChildren = new Array(), descProcessed = 0, done = 0) {
        super();
        this.activeChildren = activeChildren;
        this.descProcessed = descProcessed;
        this.done = done;
      }
      /**
      * Method decides how to traverse and sets the active children based on
      * the loadbalancing, failover values.
      * @param {object} cs
      */
      async navigate(cs) {
        cs.sBuf.push("(DESCRIPTION_LIST=");
        this.activeChildren = _NavDescriptionList.setActiveChildren(this.children, this.failover, this.loadBalance);
        while (this.descProcessed < this.activeChildren.length) {
          await this.activeChildren[this.descProcessed].navigate(cs);
          this.descProcessed++;
        }
      }
      /** set active children based on lb and failover values.
       * @param children
       * @param failover
       * @param loadBalance
       */
      static setActiveChildren(children, failover, loadBalance) {
        let randNumber;
        const listSize = children.length;
        let tmpChildren = new Array();
        const rand = Math.floor(Math.random() * 10);
        const arr = new Array(listSize).fill(false);
        if (failover) {
          if (loadBalance) {
            for (let i = 0; i < listSize; i++) {
              do {
                randNumber = Math.abs(Math.floor(Math.random() * 10)) % listSize;
              } while (arr[randNumber]);
              arr[randNumber] = true;
              tmpChildren.push(children[randNumber]);
            }
          } else {
            tmpChildren = children;
          }
        } else {
          if (loadBalance) {
            randNumber = Math.abs(rand) % listSize;
            tmpChildren.push(children[randNumber]);
          } else {
            tmpChildren.push(children[0]);
          }
        }
        return tmpChildren;
      }
    };
    module2.exports = { NavAddress, NavAddressList, NavDescription, NavDescriptionList };
  }
});

// node_modules/oracledb/lib/thin/sqlnet/connStrategy.js
var require_connStrategy = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/connStrategy.js"(exports2, module2) {
    "use strict";
    var { NavAddress, NavAddressList, NavDescription, NavDescriptionList } = require_navNodes();
    var { createNVPair } = require_nvStrToNvPair();
    var errors = require_errors();
    var constants = require_constants4();
    var ConnectDescription = class {
      constructor() {
        this.cOpts = new Array();
      }
      addConnectOption(opt) {
        this.cOpts.push(opt);
      }
      getConnectOptions() {
        return this.cOpts;
      }
    };
    var ConnStrategy = class {
      constructor() {
        this.reset();
        this.retryCount = 0;
        this.currentDescription = null;
        this.descriptionList = new Array();
        this.sBuf = new Array();
      }
      reset() {
        this.nextOptToTry = 0;
        this.lastRetryCounter = 0;
        this.lastRetryConnectDescription = 0;
        this.reorderDescriptionList = 0;
      }
      hasMoreOptions() {
        let cOptsSize = 0;
        for (let i = 0; i < this.descriptionList.length; ++i) {
          cOptsSize += this.descriptionList[i].getConnectOptions().length;
        }
        return this.nextOptToTry < cOptsSize;
      }
      newConnectionDescription() {
        this.currentDescription = new ConnectDescription();
        return this.currentDescription;
      }
      getcurrentDescription() {
        return this.currentDescription;
      }
      closeDescription() {
        this.descriptionList.push(this.currentDescription);
        this.currentDescription = null;
      }
      /**
      * Execute the Connection Options from the array.  When a refuse packet is received from
      * server this method is called again and the next connect option is tried.
      */
      async execute(config) {
        if (config != null) {
          if (this.retryCount == 0 && config.retryCount > 0) {
            this.retryCount = config.retryCount;
          }
        }
        if (!this.reorderDescriptionList) {
          this.descriptionList = SOLE_INST_DHCACHE.reorderDescriptionList(this.descriptionList);
          this.reorderDescriptionList = true;
        }
        for (let d = this.lastRetryConnectDescription; d < this.descriptionList.length; d++) {
          const desc = this.descriptionList[d];
          let cOpts = new Array();
          cOpts = desc.getConnectOptions();
          let delay = desc.delayInMillis;
          if (config != null) {
            if ((delay == 0 || delay == void 0) && config.retryDelay > 0) {
              delay = config.retryDelay * 1e3;
            } else if (!delay) {
              delay = constants.DEFAULT_RETRY_DELAY;
            }
          }
          for (let i = this.lastRetryCounter; i <= this.retryCount; ++i) {
            if (this.nextOptToTry == 0) {
              cOpts = SOLE_INST_DHCACHE.reorderAddresses(cOpts);
            }
            while (this.nextOptToTry < cOpts.length) {
              const copt = cOpts[this.nextOptToTry];
              this.lastRetryCounter = i;
              this.lastRetryConnectDescription = d;
              this.nextOptToTry++;
              return copt;
            }
            this.nextOptToTry = 0;
            if (delay > 0 && i < this.retryCount) {
              await sleep(delay);
            }
          }
          this.lastRetryCounter = 0;
        }
        this.nextOptToTry = 1e3;
        this.lastRetryCounter = 1e3;
        throw new Error("All options tried");
      }
      // sleep time expects milliseconds
    };
    function sleep(time) {
      return new Promise((resolve3) => setTimeout(resolve3, time));
    }
    async function createNode(str, userConfig) {
      let nvpair;
      if (typeof str === "string")
        nvpair = createNVPair(str);
      else
        nvpair = str;
      const arg = nvpair.name.toUpperCase();
      let navobj = null;
      switch (arg) {
        case "ADDRESS":
          navobj = new NavAddress();
          break;
        case "ADDRESS_LIST":
          navobj = new NavAddressList();
          break;
        case "DESCRIPTION":
          navobj = new NavDescription();
          break;
        case "DESCRIPTION_LIST":
          navobj = new NavDescriptionList();
          break;
        default:
          errors.throwErr(
            errors.ERR_INVALID_CONNECT_STRING_PARAMETERS,
            `unknown top element ${arg}`
          );
      }
      navobj.initFromNVPair(nvpair);
      const cs = new ConnStrategy();
      cs.driverName = userConfig.driverName;
      cs.machine = userConfig.machine;
      cs.terminal = userConfig.terminal;
      cs.osUser = userConfig.osUser;
      cs.program = userConfig.program;
      cs.httpsProxy = userConfig.httpsProxy;
      await navobj.navigate(cs);
      return cs;
    }
    var DownHostsCache = class {
      constructor() {
        this.DOWN_HOSTS_TIMEOUT = 600;
        this.MIN_TIME_BETWEEN_REFRESH = 60;
        this.downHostsCacheMap = /* @__PURE__ */ new Map();
        this.lastRefreshTime = 0;
      }
      /**
       * Add an address to the cache
       *
       * @param connOption
       *            address to be cached
       * @return Map with address as key and time of insertion as value
       */
      markDownHost(addr) {
        return this.downHostsCacheMap.set(addr, Date.now());
      }
      // Remove elements older than DownHostsTimeout
      refreshCache() {
        if (Date.now() - this.MIN_TIME_BETWEEN_REFRESH * 1e3 > this.lastRefreshTime) {
          this.downHostsCacheMap.forEach((value, key) => {
            const entryTime = value;
            if (entryTime != null && Date.now() - this.DOWN_HOSTS_TIMEOUT * 1e3 > entryTime) {
              this.downHostsCacheMap.delete(key);
            }
          });
          this.lastRefreshTime = Date.now();
        }
      }
      /**
       * Reorder addresses such that cached elements
       * occur at the end of the array.
       */
      reorderAddresses(cOpts) {
        this.refreshCache();
        let topIdx = 0, btmIdx = cOpts.length - 1;
        while (topIdx < btmIdx) {
          while (topIdx <= btmIdx && !this.isDownHostsCached(cOpts[topIdx]))
            topIdx++;
          while (btmIdx >= topIdx && this.isDownHostsCached(cOpts[btmIdx]))
            btmIdx--;
          if (topIdx < btmIdx)
            [cOpts[topIdx], cOpts[btmIdx]] = [cOpts[btmIdx], cOpts[topIdx]];
        }
        return cOpts;
      }
      /**
       * Return if a desc is cached.
       * A desc is cached if all the connection options(addresses)
       * in that description are cached.
       */
      isDownDescCached(desc) {
        const cOpts = desc.getConnectOptions();
        for (let i = 0; i < cOpts.length; i++) {
          if (!this.isDownHostsCached(cOpts[i]))
            return false;
        }
        return true;
      }
      /**
       * Reorder description list such that description with all connection options in downcache
       * is pushed to the end of the description list
       */
      reorderDescriptionList(descs) {
        this.refreshCache();
        let topIdx = 0, btmIdx = descs.length - 1;
        while (topIdx < btmIdx) {
          while (topIdx <= btmIdx && !this.isDownDescCached(descs[topIdx]))
            topIdx++;
          while (btmIdx >= topIdx && this.isDownDescCached(descs[btmIdx]))
            btmIdx--;
          if (topIdx < btmIdx) {
            [descs[topIdx], descs[btmIdx]] = [descs[btmIdx], descs[topIdx]];
          }
        }
        return descs;
      }
      // Return if a host is cached
      isDownHostsCached(copt) {
        return this.downHostsCacheMap.has(copt.host);
      }
    };
    var SOLE_INST_DHCACHE = new DownHostsCache();
    module2.exports = { createNode, SOLE_INST_DHCACHE };
  }
});

// node_modules/oracledb/lib/thin/sqlnet/ezConnectResolver.js
var require_ezConnectResolver = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/ezConnectResolver.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var HOSTNAMES_PATTERN = new RegExp("((?=(?<hostnames>(((\\[[A-z0-9:]+\\])|([A-z0-9][A-z0-9._-]+))[,]?)+)))\\k<hostnames>(:(?<port>\\d+)?)?", "g");
    var EZ_URL_PATTERN = new RegExp("^(((?<protocol>[A-z0-9]+):)?//)?(?<hostinfo>(" + HOSTNAMES_PATTERN.source + "(?=([,]|[;]|[/]|[:]|$))([,]|[;])?)+)(/(?<servicename>[A-z0-9][A-z0-9,-.]+)?)?(:(?<servermode>dedicated|shared|pooled))?(/(?<instance>[A-z0-9][A-z0-9]+))?$", "ig");
    var EXT_DOUBLE_QT = '"';
    var EXT_KEY_VAL_SEP = "=";
    var EXT_PARAM_SEP = "&";
    var DESCRIPTION_PARAMS = [
      "ENABLE",
      "FAILOVER",
      "LOAD_BALANCE",
      "RECV_BUF_SIZE",
      "SEND_BUF_SIZE",
      "SDU",
      "SOURCE_ROUTE",
      "RETRY_COUNT",
      "RETRY_DELAY",
      "CONNECT_TIMEOUT",
      "TRANSPORT_CONNECT_TIMEOUT",
      "RECV_TIMEOUT",
      "USE_SNI",
      "COMPRESSION"
    ];
    var EZConnectResolver = class {
      constructor(url) {
        this.URL_PROPS_ALIAS = this.initializeUrlAlias();
        this.url = url;
        this.resolvedUrl = "";
        this.connectionProps = /* @__PURE__ */ new Map();
        this.urlProps = /* @__PURE__ */ new Map();
        this.lb = false;
      }
      /**
      * Returns the resolved long TNS String.
      * @return Resolved TNS URL.
      */
      getResolvedUrl() {
        this.parse();
        return this.resolvedUrl;
      }
      /**
       * First parse the extended settings part of the given url.
       * After parsing the extended settings if the remaining part of the URL is in
       * EZConnectURL format then resolve it to long TNS url format.
       */
      parse() {
        let parsedUrl = this.parseExtendedSettings(this.url);
        if (this.connectionProps.size === 0 && this.urlProps.size === 0) {
          parsedUrl = this.url;
        }
        this.resolvedUrl = this.resolveToLongURLFormat(parsedUrl);
      }
      /**
      * Translate the given ezconnect url format to Long TNS format.
      * @param url EZConnect URL
      * @return Returns resolved TNS url.
      */
      resolveToLongURLFormat(url) {
        const urlWithoutWhiteSpaces = url.replace(/\s/g, "");
        let bool = 0;
        let protocol = null, hostInfo = null, serviceName = null, serverMode = null, instanceName = null;
        for (const match of urlWithoutWhiteSpaces.matchAll(EZ_URL_PATTERN)) {
          bool = 1;
          protocol = match.groups.protocol;
          hostInfo = match.groups.hostinfo;
          serviceName = match.groups.servicename;
          serverMode = match.groups.servermode;
          instanceName = match.groups.instance;
        }
        if (!bool) {
          errors.throwErr(errors.ERR_INVALID_EZCONNECT_SYNTAX, "input string not in easy connect format", urlWithoutWhiteSpaces);
        }
        if (protocol == null) {
          if (!url.includes("//"))
            protocol = "TCP";
        } else if (protocol.toLowerCase() != "tcp" && protocol.toLowerCase() != "tcps") {
          errors.throwErr(errors.ERR_INVALID_EZCONNECT_SYNTAX, "Unsupported protocol in thin mode", protocol);
        }
        const proxyHost = this.urlProps.get("HTTPS_PROXY");
        const proxyPort = this.urlProps.get("HTTPS_PROXY_PORT");
        const addressInfo = this.buildAddressList(hostInfo, protocol, proxyHost, proxyPort);
        const connectionIdPrefix = this.urlProps.get("CONNECTION_ID_PREFIX");
        const parts = [];
        if (this.lb)
          parts.push("(LOAD_BALANCE=ON)");
        parts.push(this.buildDescriptionParams());
        parts.push(addressInfo);
        parts.push(this.buildConnectData(
          serviceName,
          serverMode,
          instanceName,
          connectionIdPrefix
        ));
        parts.push(this.buildSecurityInfo(protocol));
        return `(DESCRIPTION=${parts.join("")})`;
      }
      /**
       * Returns the CONNECT_DATA part of DESCRIPTION node of the TNS URL.
       * @param serviceName the database service name [optional].
       * @param serverMode dedicated or shared or pooled [optional].
       * @param instanceName the database instance name [optional].
       * @param connectionIdPrefix prefix which will be appended to the connection id [optional].
       * @return CONNECT_DATA as string
       */
      buildConnectData(serviceName, serverMode, instanceName, connectionIdPrefix) {
        const poolConnectionClass = this.urlProps.get("POOL_CONNECTION_CLASS");
        const poolPurity = this.urlProps.get("POOL_PURITY");
        const serviceTag = this.urlProps.get("SERVICE_TAG");
        const poolBoundary = this.urlProps.get("POOL_BOUNDARY");
        const parts = [];
        if (serviceName)
          parts.push(`(SERVICE_NAME=${serviceName})`);
        else
          parts.push("(SERVICE_NAME=)");
        if (serverMode)
          parts.push(`(SERVER=${serverMode})`);
        if (instanceName)
          parts.push(`(INSTANCE_NAME=${instanceName})`);
        if (poolConnectionClass)
          parts.push(`(POOL_CONNECTION_CLASS=${poolConnectionClass})`);
        if (poolPurity)
          parts.push(`(POOL_PURITY=${poolPurity})`);
        if (serviceTag)
          parts.push(`(SERVICE_TAG=${serviceTag})`);
        if (connectionIdPrefix)
          parts.push(`(CONNECTION_ID_PREFIX=${connectionIdPrefix})`);
        if (poolBoundary)
          parts.push(`(POOL_BOUNDARY=${poolBoundary})`);
        return `(CONNECT_DATA=${parts.join("")})`;
      }
      /**
      * Builds the address information of the DESCRIPTION node with the given
      * information.
      * @param hostInfo host and port information separated by comma.
                      hosts can be grouped into a ADDRESS_LIST using semi-colon ';'
      * @param protocol either tcp or tcps [optional].
      * @param proxyHost host name of the proxy server [optional].
      * @param proxyPort proxy server port [optional].
      * @return address information of the DESCRIPTION node.
      */
      buildAddressList(hostInfo, protocol, proxyHost, proxyPort) {
        const builder = new Array();
        let proxyInfo = "";
        if (proxyHost != null) {
          if (proxyPort != null) {
            proxyInfo = `(HTTPS_PROXY=${proxyHost})(HTTPS_PROXY_PORT=${proxyPort})`;
          } else {
            proxyInfo = `(HTTPS_PROXY=${proxyHost})`;
          }
        }
        if (protocol == null) protocol = "TCP";
        let naddr = 0;
        const addressLists = hostInfo.split(";");
        for (const addressList of addressLists) {
          let addressNodeCount = 0;
          const addressListBuilder = new Array();
          for (const match of addressList.matchAll(HOSTNAMES_PATTERN)) {
            const hostnames = match.groups.hostnames.split(",");
            let port = match.groups.port;
            if (port == null) {
              port = "1521";
            }
            for (const hname of hostnames) {
              addressListBuilder.push(this.getAddrStr(hname, port, protocol, proxyInfo));
              addressNodeCount++;
            }
          }
          naddr += addressNodeCount;
          const parts = [];
          if (addressLists.length > 1 && addressNodeCount > 1)
            parts.push("(LOAD_BALANCE=ON)");
          parts.push(addressListBuilder.join(""));
          if (addressLists.length > 1)
            builder.push(`(ADDRESS_LIST=${parts.join("")})`);
          else
            builder.push(parts.join(""));
        }
        if (addressLists.length < 2 && naddr > 1) {
          this.lb = true;
        }
        return builder.join("");
      }
      /**
      * Builds address information using the given hostname, port, protocol and
      * proxyinfo.
      * @param hostName
      * @param port
      * @param protocol
      * @param proxyInfo
      * @return addressInfo
      */
      getAddrStr(hostName, port, protocol, proxyInfo) {
        let host = hostName.trim();
        if (host.startsWith("[") && host.endsWith("]"))
          host = host.substring(1, host.length - 1);
        return `(ADDRESS=(PROTOCOL=${protocol})(HOST=${host})(PORT=${port})${proxyInfo})`;
      }
      /**
      * Builds the parameters for the DESCRIPTION node using the parsed properties
      * from the URL.
      * @return Description Parameters String.
      */
      buildDescriptionParams() {
        if (this.urlProps.size === 0)
          return "";
        const builder = new Array();
        this.urlProps.forEach(function(v, k) {
          if (DESCRIPTION_PARAMS.includes(k))
            builder.push(`(${k}=${v})`);
        });
        return builder.join("");
      }
      /**
      * Builds the security section of the DESCRIPTION node, which contains the information
      * about wallet location, server DN, encryption and checksum options.
      * @return security node of the description as string.
      */
      buildSecurityInfo(protocol) {
        const securityInfo = new Array();
        if (protocol != null && protocol.toLowerCase() == "tcps") {
          const serverDNMatch = this.urlProps.get("SSL_SERVER_DN_MATCH");
          const serverCertDN = this.urlProps.get("SSL_SERVER_CERT_DN");
          const walletDir = this.urlProps.get("MY_WALLET_DIRECTORY");
          if (serverDNMatch != null)
            securityInfo.push(`(SSL_SERVER_DN_MATCH=${serverDNMatch})`);
          if (serverCertDN != null)
            securityInfo.push(`(SSL_SERVER_CERT_DN=${serverCertDN}})`);
          if (walletDir != null)
            securityInfo.push(`(MY_WALLET_DIRECTORY=${walletDir})`);
        }
        if (securityInfo.length === 0)
          return "";
        return `(SECURITY=${securityInfo.join("")})`;
      }
      /**
       * If the URL has extended settings part appended to it, this method takes
       * care of parsing it.
       * Parses the Extended Settings and takes appropriate action based on the
       * settings type.
       * <URL>?<propertyName1>=<propertyValue1>&<propertyName2>=<propertyValue2>.
       * @param urlStr Database URL supplied by the application.
       * @return the parsed URL which does not contain the extended settings part.
       */
      parseExtendedSettings(urlStr) {
        const urlBytes = Array.from(urlStr.trim());
        const extendedSettingsIndex = this.findExtendedSettingPosition(urlBytes);
        if (extendedSettingsIndex == -1) {
          return urlStr;
        }
        this.parseExtendedProperties(urlBytes, extendedSettingsIndex + 1);
        return urlStr.substring(0, extendedSettingsIndex);
      }
      /**
      * Loops through the chars of the extended settings part of the URL and
      * parses the connection properties.
      * @param urlChars URL in char[]
      * @param extIndex the begin index of the extended settings
      */
      parseExtendedProperties(urlChars, extIndex) {
        let key = null;
        let value = null;
        const token = new Array(urlChars.length);
        let tokenIndx = 0;
        let indices = "";
        for (let i = extIndex; i < urlChars.length; i++) {
          if (urlChars[i].trim() == "") {
            continue;
          }
          switch (urlChars[i]) {
            case EXT_DOUBLE_QT:
              indices = this.parseQuotedString(i, urlChars, tokenIndx, token);
              tokenIndx = indices[1];
              i = indices[0];
              break;
            // Hit a '=' assign the value up to this to param key and
            // reset the startIndex
            case EXT_KEY_VAL_SEP:
              if (key != null) {
                errors.throwErr(errors.ERR_INVALID_EZCONNECT_SYNTAX, "unable to parse, invalid syntax", this.url);
              }
              key = token.join("").substring(0, tokenIndx).trim();
              tokenIndx = 0;
              break;
            // Hit a '&' assign the value up to this to param key and
            // reset the startIndex
            case EXT_PARAM_SEP:
              if (key == null) {
                errors.throwErr(errors.ERR_INVALID_EZCONNECT_SYNTAX, "unable to parse, invalid syntax", this.url);
              }
              value = token.join("").substring(0, tokenIndx).trim();
              this.addParam(key, value);
              key = null;
              value = null;
              tokenIndx = 0;
              break;
            default:
              token[tokenIndx++] = urlChars[i];
          }
        }
        if (key != null) {
          value = token.join("").substring(0, tokenIndx).trim();
          this.addParam(key, value);
        }
      }
      /**
       * Parses the quoted string from the given startIndex of the urlChars and
       * return the length of the parsed quoted string.
       * @param startIndex index of the starting '"' in the urlChars
       * @param urlChars char[] of the url string.
       * @param tokenIndex starting index in the token char[] to store the result
       * @param token char[] to store the result
       * @return int[] int[0] - new index for urlChars, int[1] new index for token
       */
      parseQuotedString(startIndex, urlChars, tokenIndex, token) {
        let i = startIndex + 1;
        while (i < urlChars.length) {
          const curChar = urlChars[i];
          if (curChar == EXT_DOUBLE_QT) {
            return [i, tokenIndex];
          } else {
            token[tokenIndex++] = curChar;
          }
          i++;
        }
      }
      /**
       * Adds the given key and value to the connection properties.
       * @param key
       * @param value
       */
      addParam(key, value) {
        const aliasKeyName = key.toLowerCase();
        const propertyName = this.URL_PROPS_ALIAS.get(aliasKeyName);
        if (propertyName != null) {
          this.urlProps.set(propertyName, value);
        } else {
          this.connectionProps.set(propertyName, value);
        }
      }
      findExtendedSettingPosition(urlBytes) {
        let urlNodeDepth = 0;
        for (let i = 0; i < urlBytes.length; i++) {
          if (urlBytes[i] == "(") urlNodeDepth++;
          else if (urlBytes[i] == ")") urlNodeDepth--;
          else if (urlBytes[i] == "?" && urlNodeDepth == 0) return i;
        }
        return -1;
      }
      /**
       * Initialize a Map with URL parameter alias. key is what we get from the
       * URL and the value is what we use while creating the TNS URL.
       * @return url alias map
       */
      initializeUrlAlias() {
        const aliasMap = /* @__PURE__ */ new Map();
        aliasMap.set("enable", "ENABLE");
        aliasMap.set("compression", "COMPRESSION");
        aliasMap.set("failover", "FAILOVER");
        aliasMap.set("load_balance", "LOAD_BALANCE");
        aliasMap.set("recv_buf_size", "RECV_BUF_SIZE");
        aliasMap.set("send_buf_size", "SEND_BUF_SIZE");
        aliasMap.set("sdu", "SDU");
        aliasMap.set("source_route", "SOURCE_ROUTE");
        aliasMap.set("retry_count", "RETRY_COUNT");
        aliasMap.set("retry_delay", "RETRY_DELAY");
        aliasMap.set("https_proxy", "HTTPS_PROXY");
        aliasMap.set("https_proxy_port", "HTTPS_PROXY_PORT");
        aliasMap.set("connect_timeout", "CONNECT_TIMEOUT");
        aliasMap.set("transport_connect_timeout", "TRANSPORT_CONNECT_TIMEOUT");
        aliasMap.set("recv_timeout", "RECV_TIMEOUT");
        aliasMap.set("ssl_server_cert_dn", "SSL_SERVER_CERT_DN");
        aliasMap.set("ssl_server_dn_match", "SSL_SERVER_DN_MATCH");
        aliasMap.set("wallet_location", "MY_WALLET_DIRECTORY");
        aliasMap.set("pool_connection_class", "POOL_CONNECTION_CLASS");
        aliasMap.set("pool_purity", "POOL_PURITY");
        aliasMap.set("service_tag", "SERVICE_TAG");
        aliasMap.set("connection_id_prefix", "CONNECTION_ID_PREFIX");
        aliasMap.set("pool_boundary", "POOL_BOUNDARY");
        aliasMap.set("use_sni", "USE_SNI");
        return aliasMap;
      }
    };
    module2.exports = EZConnectResolver;
  }
});

// node_modules/oracledb/lib/thin/sqlnet/paramParser.js
var require_paramParser = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/paramParser.js"(exports2, module2) {
    "use strict";
    var { createNVPair } = require_nvStrToNvPair();
    var fs4 = require("fs");
    var process2 = require("process");
    var readline = require("readline");
    var errors = require_errors();
    var MAX_IFILE_DEPTH = 4;
    function tnsnamesFilePath(configDir) {
      let filePathVal = null;
      const tnsAdminVal = process2.env.TNS_ADMIN;
      if (configDir) {
        filePathVal = configDir + "/tnsnames.ora";
        if (fs4.existsSync(filePathVal)) {
          return filePathVal;
        } else {
          errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, configDir);
        }
      } else {
        if (!tnsAdminVal) {
          errors.throwErr(errors.ERR_NO_CONFIG_DIR);
        } else {
          filePathVal = tnsAdminVal;
          filePathVal += "/tnsnames.ora";
          if (!fs4.existsSync(filePathVal)) {
            errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, tnsAdminVal);
          }
        }
        return filePathVal;
      }
    }
    var tnsnamesElement = class {
      constructor() {
        this.readInProgress = false;
        this.waiters = [];
        this.aliasht = /* @__PURE__ */ new Map();
        this.modTime = /* @__PURE__ */ new Map();
      }
    };
    var NLParamParser = class {
      constructor() {
        this.tnsnamesHT = /* @__PURE__ */ new Map();
      }
      /**
      * Reads the given file line by line and stores the
      * network service names mapped to connect descriptors in the hashtable.
      * @param {string} file_path
      * @returns {Promise}
      */
      async initializeNlpa(file_path) {
        let tnsFileStruct;
        if (this.tnsnamesHT.has(file_path))
          tnsFileStruct = this.tnsnamesHT.get(file_path);
        else
          tnsFileStruct = new tnsnamesElement();
        if (tnsFileStruct.readInProgress) {
          await new Promise((resolve3) => {
            tnsFileStruct.waiters.push(resolve3);
          });
        }
        if (!this.checkModfTime(tnsFileStruct)) {
          return tnsFileStruct.aliasht;
        }
        tnsFileStruct.readInProgress = true;
        await this.start(file_path, 0, tnsFileStruct);
        this.tnsnamesHT.set(file_path, tnsFileStruct);
        return tnsFileStruct.aliasht;
      }
      async start(file_path, depth, tnsFileStruct) {
        if (depth > MAX_IFILE_DEPTH)
          return;
        const stat = fs4.statSync(file_path);
        tnsFileStruct.modTime.set(file_path, stat.mtime);
        const file = readline.createInterface({
          input: fs4.createReadStream(file_path),
          output: process2.stdout,
          terminal: false
        });
        let nvElem = "";
        for await (let line of file) {
          if (line.length == 0) {
            continue;
          } else if (line[0] == "#") {
            continue;
          } else if (line[0] == " " || // continued input on new line
          line[0] == "	" || line[0] == ")" || line[0] == "(") {
            line = line.replace(/\s+/g, "");
            line = this.checkNLPforComments(line);
            if (line.length == 0)
              continue;
            else {
              nvElem = nvElem + line;
            }
          } else {
            if (nvElem.length == 0) {
              line = this.checkNLPforComments(line);
              nvElem = nvElem + line;
            } else if (nvElem.length != 0) {
              await this.addNLPListElement(nvElem, depth, tnsFileStruct);
              nvElem = "";
              line = this.checkNLPforComments(line);
              nvElem = nvElem + line;
            }
          }
        }
        if (nvElem.length != 0) {
          await this.addNLPListElement(nvElem, depth, tnsFileStruct);
          nvElem = "";
        }
        tnsFileStruct.readInProgress = false;
        let waiter;
        while (waiter = tnsFileStruct.waiters.pop()) {
          waiter();
        }
      }
      /**
       * Given a string, this method looks if the '#' character is present.
       * If true, the line is truncated from that point onwards until the end
       * of the line; else, the original line is returned unchanged.
       *
       * @param  str     The String that is going to be tested for inline comments
       * @return String  The modified String returned
       */
      checkNLPforComments(str) {
        const str1 = new Array(str.length);
        for (let i = 0; i < str.length; i++) {
          const current_char = str[i];
          if (current_char == "#") {
            if (i != 0) {
              break;
            } else {
              return "";
            }
          } else
            str1.push(current_char);
        }
        return str1.join("");
      }
      // check if any of the IFiles has been changed
      checkModfTime(tnsFileStruct) {
        if (tnsFileStruct.modTime.size != 0) {
          for (const [key, value] of tnsFileStruct.modTime) {
            if (fs4.existsSync(key)) {
              const stat = fs4.statSync(key);
              if (stat.mtime - value > 0) {
                return true;
              }
            } else
              return true;
          }
        } else {
          return true;
        }
        return false;
      }
      /**
        * adds name value pairs from the input buffer into the hash table.
        * @param {string} ibuf
        */
      async addNLPListElement(ibuf, depth, tnsFileStruct) {
        const res = ibuf.split(/\r?\n/).filter((element) => element);
        for (let i = 0; i < res.length; i++) {
          if (res[i].charAt(0) != "(") {
            res[i] = "(" + res[i] + ")";
          }
          const nvp = createNVPair(res[i]);
          const name = nvp.name;
          const uname = name.toUpperCase();
          nvp.name = uname;
          if (uname == "IFILE") {
            await this.start(nvp.atom, depth + 1, tnsFileStruct);
          } else {
            const unames = uname.split(",");
            for (let i2 = 0; i2 < unames.length; i2++) {
              tnsFileStruct.aliasht.set(unames[i2], nvp);
            }
          }
        }
      }
    };
    module2.exports = {
      NLParamParser,
      tnsnamesFilePath
    };
  }
});

// node_modules/oracledb/lib/thin/sqlnet/networkSession.js
var require_networkSession = __commonJS({
  "node_modules/oracledb/lib/thin/sqlnet/networkSession.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var Packet = require_packet2();
    var NTTCP = require_ntTcp();
    var SessionAtts = require_sessionAtts();
    var constants = require_constants4();
    var { createNode } = require_connStrategy();
    var errors = require_errors();
    var { findNVPairRecurse, createNVPair, findValue } = require_nvStrToNvPair();
    var { Buffer: Buffer2 } = require("buffer");
    var EzConnect = require_ezConnectResolver();
    var { NLParamParser, tnsnamesFilePath } = require_paramParser();
    var process2 = require("process");
    var downHostInstance = require_connStrategy().SOLE_INST_DHCACHE;
    var { ANO } = require_ANO();
    async function getConnectionInfo(userConfig) {
      const connStr = await resolveConnectStr(userConfig.connectString, userConfig.configDir);
      const addressNode = await createNode(connStr, userConfig);
      let nvpair;
      if (typeof connStr === "string")
        nvpair = createNVPair(connStr);
      else
        nvpair = connStr;
      const serverVal = findValue(nvpair, ["DESCRIPTION", "CONNECT_DATA", "SERVER"]);
      const connClass = findValue(nvpair, ["DESCRIPTION", "CONNECT_DATA", "POOL_CONNECTION_CLASS"]);
      const svcname = findValue(nvpair, ["DESCRIPTION", "CONNECT_DATA", "SERVICE_NAME"]);
      const sid = findValue(nvpair, ["DESCRIPTION", "CONNECT_DATA", "SID"]);
      const poolPurity = findValue(nvpair, ["DESCRIPTION", "CONNECT_DATA", "POOL_PURITY"]);
      return [serverVal, connClass, svcname, poolPurity, sid, addressNode];
    }
    var nlParamParser = new NLParamParser();
    async function resolveConnectStr(connectString, configDir) {
      const connStr = connectString.trim();
      let resolvedVal = connStr;
      if (connStr.indexOf(")") == -1 || connStr.indexOf("(") != 0) {
        if (connStr.indexOf(":") != -1 || connStr.indexOf("/") != -1) {
          const ezcnObj = new EzConnect(connStr);
          resolvedVal = ezcnObj.getResolvedUrl();
          return resolvedVal;
        } else {
          const namesFilePath = tnsnamesFilePath(configDir);
          const p = await nlParamParser.initializeNlpa(namesFilePath);
          resolvedVal = p.get(connStr.toUpperCase());
          if (!resolvedVal)
            errors.throwErr(errors.ERR_TNS_ENTRY_NOT_FOUND, connStr, configDir ? configDir + "/tnsnames.ora" : process2.env.TNS_ADMIN + "/tnsnames.ora");
          if (resolvedVal.rhsType == 1) {
            const rString = resolvedVal.atom;
            if (rString.indexOf(":") != -1 || rString.indexOf("/") != -1) {
              return new EzConnect(rString).getResolvedUrl();
            }
          }
          resolvedVal = resolvedVal.getListElement(0);
        }
      }
      return resolvedVal;
    }
    async function resolveAddress(connStr, userConfig) {
      const connstr = await resolveConnectStr(connStr, userConfig.configDir);
      return createNode(connstr, userConfig);
    }
    function timeout(asyncPromise, timeVal, oper, address, connID) {
      let timer;
      const timeoutPromise = new Promise((resolve3, reject) => {
        if (timeVal > 2147483647)
          timeVal = 2147483647;
        timer = setTimeout(() => reject(errors.getErr(errors.ERR_CONNECTION_TIMEDOUT, address.host, address.port, oper, timeVal / 1e3, connID)), timeVal);
      });
      return Promise.race([asyncPromise, timeoutPromise]).then((result) => {
        clearTimeout(timer);
        return result;
      }).catch((err) => {
        clearTimeout(timer);
        throw err;
      });
    }
    var NetworkSession = class {
      constructor() {
        this.connected = false;
        this.isBreak = false;
        this.isReset = false;
        this.breakPosted = false;
        this.compressionEnabled = false;
      }
      async getAddress(addressNode, userConfig) {
        const address = await addressNode.execute(userConfig);
        const uuid = this.sAtts ? this.sAtts.uuid : null;
        this.sAtts = new SessionAtts(uuid);
        this.sAtts.setFrom(userConfig);
        this.sAtts.setFrom(address.desc.params);
        await this.sAtts.prepare(address.protocol, userConfig);
        const rootNVPair = createNVPair(address.CNdata.join(""));
        const cdataNVPair = findNVPairRecurse(rootNVPair, "CONNECT_DATA");
        const connidStr = `(CONNECTION_ID=${this.sAtts.connectionId})`;
        const childNVPair = createNVPair(connidStr);
        cdataNVPair.addListElement(childNVPair);
        this.cData = Buffer2.from(rootNVPair.toString(), "ascii");
        this.cDataNVPair = rootNVPair;
        this.sAtts.nt.cDataNVPair = rootNVPair;
        return address;
      }
      /**
       * Make the transport level connection
       */
      async transportConnect(address) {
        if (address.protocol.toUpperCase() == "TCP" && address.httpsProxy) {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, "https proxy requires protocol as", "tcps ");
        }
        if (address.protocol && (address.protocol.toUpperCase() == "TCP" || address.protocol.toUpperCase() == "TCPS")) {
          this.ntAdapter = new NTTCP(this.sAtts.nt);
        } else {
          errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, address.protocol + " protocol not supported");
        }
        await this.ntAdapter.connect(address);
        this.ntAdapter.startRead();
        this.sAtts.ntCha = this.ntAdapter.cha;
        this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);
        this.rcvDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);
      }
      /**
       * Send the NSPTCN(connect) packet
       * @param {object} connectPkt Connect Packet
       */
      _sendConnect(connectPkt) {
        this.sendPacket(connectPkt.buf);
        if (connectPkt.overflow) {
          this._send(connectPkt.connectData, 0, connectPkt.connectDataLen);
          this.flush();
        }
      }
      /**
       * Establish network session. Make transport level connection, send
       * NSPTCN(connect packet) and read the response. @returns NetError.
       * (connection successfully established(NetError.CONNECTED)
       * or reason for failure)
       */
      async connect2(address, userConfig) {
        if (this.sAtts.sdu) {
          if (this.sAtts.sdu > constants.NSPABSSDULN) {
            this.sAtts.sdu = constants.NSPABSSDULN;
          } else if (this.sAtts.sdu < constants.NSPMNSDULN) {
            this.sAtts.sdu = constants.NSPMNSDULN;
          }
        } else {
          this.sAtts.sdu = constants.NSPDFSDULN;
        }
        if (this.sAtts.transportConnectTimeout) {
          const asyncPromise = this.transportConnect(address);
          await timeout(asyncPromise, this.sAtts.transportConnectTimeout, "transportConnectTimeout", address, this.sAtts.connectionId);
        } else {
          await this.transportConnect(address);
        }
        let connectPkt = new Packet.ConnectPacket(this.cData, this.sAtts);
        this._sendConnect(connectPkt);
        while (true) {
          const packet = await this._recvPacket();
          if (packet.type === constants.NSPTAC)
            break;
          if (packet.type === constants.NSPTRF) {
            if (this.refusePkt.overflow) {
              await this._recvPacket();
              this.refusePkt.dataBuf = this.rcvDatapkt.buf.subarray(this.rcvDatapkt.offset, this.rcvDatapkt.len).toString();
            }
            const nvpair = createNVPair(this.refusePkt.dataBuf);
            this.refusePkt = null;
            const err = findValue(nvpair, ["DESCRIPTION", "ERR"]);
            if (err == "12514") {
              errors.throwErr(errors.ERR_INVALID_SERVICE_NAME, this.getOption(constants.SVCNAME), address.host, address.port, this.sAtts.connectionId);
            } else if (err == "12505") {
              errors.throwErr(errors.ERR_INVALID_SID, this.getOption(constants.SID), address.host, address.port, this.sAtts.connectionId);
            } else if (err) {
              errors.throwErr(errors.ERR_CONNECTION_REFUSED, address.host, address.port, this.sAtts.connectionId, "ORA-" + err);
            } else {
              errors.throwErr(errors.ERR_CONNECTION_REFUSED, address.host, address.port, this.sAtts.connectionId, "refused");
            }
          } else if (packet.type === constants.NSPTRS) {
            if ((packet.flags & constants.NSPFSRN) == constants.NSPFSRN) {
              await this.ntAdapter.renegTLS();
              this.ntAdapter.startRead();
            }
            this._sendConnect(connectPkt);
          } else if (packet.type === constants.NSPTRD) {
            let adrLen, adrStr, redirConnData;
            if (this.redirectPkt.overflow) {
              await this._recvPacket();
              this.redirectPkt.dataBuf = this.rcvDatapkt.buf.subarray(this.rcvDatapkt.offset, this.rcvDatapkt.len);
            }
            if (this.redirectPkt.flags & constants.NSPFRDS) {
              adrLen = this.redirectPkt.dataBuf.indexOf("\0", 0, "ascii");
              adrStr = this.redirectPkt.dataBuf.toString("ascii", 0, adrLen);
              redirConnData = this.redirectPkt.dataBuf.subarray(adrLen + 1, this.redirectPkt.dataLen);
            } else {
              adrStr = this.redirectPkt.dataBuf.toString("ascii");
              redirConnData = this.cData;
            }
            const redirAddressNode = await resolveAddress(adrStr, userConfig);
            const host = address.hostname;
            address = await redirAddressNode.execute();
            if (address.desc)
              this.sAtts.setFrom(address.desc.params);
            address.originHost = host;
            this.redirectPkt = null;
            this.ntAdapter.disconnect(constants.NSFIMM);
            if (this.sAtts.transportConnectTimeout) {
              const asyncPromise = this.transportConnect(address);
              await timeout(asyncPromise, this.sAtts.transportConnectTimeout, "transportConnectTimeout", address, this.sAtts.connectionId);
            } else {
              await this.transportConnect(address);
            }
            connectPkt = new Packet.ConnectPacket(redirConnData, this.sAtts, constants.NSPFRDR);
            this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);
            this._sendConnect(connectPkt);
          }
        }
        this.cData = null;
        this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);
        this.markerPkt = new Packet.MarkerPacket(this.sAtts.largeSDU);
        this.controlPkt = new Packet.ControlPacket();
        this.ntAdapter.largeSDU = this.sAtts.largeSDU;
        this.sAtts.clearWallet();
        this.sAtts.nt.walletPassword = null;
        if (!this.sAtts.noNA) {
          const NAContext = new ANO(this.sAtts);
          const buf = NAContext.sendPacket();
          this._send(buf, 0, buf.length);
          this.flush();
          const packet = await this._recvPacket();
          NAContext.processPacket(packet.buf);
        }
        this.sndDatapkt.createPacket(constants.NSPDADAT);
        this.sndDatapkt.offset = this.sndDatapkt.dataPtr;
        this.sndDatapkt.len = this.sndDatapkt.bufLen;
        this.connected = true;
        return true;
      }
      /**
       * Try all available addresses for connection establishment
       */
      async connect1(address, addressNode, userConfig) {
        let connected, savedErr;
        do {
          try {
            if (this.sAtts.connectTimeout) {
              const asyncPromise = this.connect2(address, userConfig);
              connected = await timeout(asyncPromise, this.sAtts.connectTimeout, "connectTimeout", address, this.sAtts.connectionId);
            } else {
              connected = await this.connect2(address, userConfig);
            }
          } catch (err) {
            if (err.message.startsWith("NJS-510") && !this.ntAdapter.connected) {
              downHostInstance.markDownHost(address.host, Date.now());
              this.ntAdapter.connected = true;
            }
            if (this.ntAdapter) {
              this.ntAdapter.disconnect(constants.NSFIMM);
              this.ntAdapter = null;
            }
            this.sAtts.clearWallet();
            connected = false;
            savedErr = err;
            try {
              address = await this.getAddress(addressNode, userConfig);
            } catch (err2) {
              break;
            }
          }
        } while (!connected);
        if (connected) {
          return;
        } else {
          throw savedErr;
        }
      }
      /**
       * Process packet (Internal)
       */
      _processPacket(packet) {
        switch (packet.type) {
          case constants.NSPTDA: {
            const size = packet.buf.length;
            const dataFlags = packet.buf.readUInt16BE(constants.NSPDAFLG);
            if ((dataFlags & constants.NSPDAFCMP) != 0) {
              const packetHeader = packet.buf.subarray(0, constants.NSPDADAT);
              const buffertoDeCompress = packet.buf.subarray(constants.NSPDADAT, size);
              let deCompressedDataBuffer;
              try {
                if (this.sAtts.firstRecvCompressedPacket) {
                  deCompressedDataBuffer = zlib.inflateSync(buffertoDeCompress, { finishFlush: zlib.constants.Z_SYNC_FLUSH });
                  this.sAtts.firstRecvCompressedPacket = 0;
                } else {
                  deCompressedDataBuffer = zlib.inflateRawSync(buffertoDeCompress, { finishFlush: zlib.constants.Z_SYNC_FLUSH });
                }
              } catch (err) {
                errors.throwErr(errors.ERR_DATA_COMPRESSION, err.message);
              }
              const resultLength = deCompressedDataBuffer.length;
              packet.buf = Buffer2.concat([packetHeader, deCompressedDataBuffer]);
              const length = resultLength + constants.NSPDADAT;
              if (this.sAtts.largeSDU) {
                packet.buf.writeUInt32BE(length, constants.NSPHDLEN);
              } else {
                packet.buf.writeUInt16BE(length, constants.NSPHDLEN);
              }
            }
            this.rcvDatapkt.fromPacket(packet);
            break;
          }
          case constants.NSPTMK:
            this.markerPkt.fromPacket(packet, this);
            break;
          case constants.NSPTCNL:
            this.controlPkt.fromPacket(packet);
            break;
          case constants.NSPTAC:
            Packet.AcceptPacket(packet, this.sAtts);
            if (this.sAtts.version >= constants.TNS_VERSION_MIN_END_OF_RESPONSE && packet.flags & constants.TNS_ACCEPT_FLAG_HAS_END_OF_REQUEST) {
              this.endOfRequestSupport = true;
            }
            if (packet.flags & constants.TNS_ACCEPT_FLAG_FAST_AUTH) {
              this.supportsFastAuth = true;
            }
            break;
          case constants.NSPTRF:
            this.refusePkt = new Packet.RefusePacket(packet);
            break;
          case constants.NSPTRS:
            break;
          case constants.NSPTRD:
            this.redirectPkt = new Packet.RedirectPacket(packet);
            break;
          default:
            errors.throwErr(errors.ERR_CONNECTION_INVALID_PACKET);
        }
      }
      /**
       * Receive packet (Internal)
       * Control packets are consumed internally and discarded
       */
      async _recvPacket() {
        while (true) {
          const packet = await this.ntAdapter.receive();
          if (!packet)
            break;
          this._processPacket(packet);
          if (packet.type !== constants.NSPTCNL) {
            return packet;
          }
        }
      }
      /**
       * Send data (Internal)
       */
      sendPacket(buf) {
        const packetType = buf.readUInt8(constants.NSPHDTYP);
        if (packetType == constants.NSPTDA) {
          const size = buf.length;
          let dataFlags = buf.readUInt16BE(constants.NSPDAFLG);
          if (this.sAtts.networkCompressionEnabled && size > this.sAtts.networkCompressionThreshold) {
            this.compressionEnabled = true;
            const buffertoCompress = buf.subarray(constants.NSPDADAT, size);
            const bufferHeader = buf.subarray(0, constants.NSPDADAT);
            let compressedDataBuffer;
            try {
              if (this.sAtts.firstSendCompressedPacket) {
                compressedDataBuffer = zlib.deflateSync(buffertoCompress, { finishFlush: zlib.constants.Z_SYNC_FLUSH });
                this.sAtts.firstSendCompressedPacket = 0;
              } else {
                compressedDataBuffer = zlib.deflateRawSync(buffertoCompress, { finishFlush: zlib.constants.Z_SYNC_FLUSH });
              }
            } catch (err) {
              errors.throwErr(errors.ERR_DATA_COMPRESSION, err.message);
            }
            const resultLength = compressedDataBuffer.length;
            if (resultLength < size - constants.NSPDADAT) {
              dataFlags |= constants.NSPDAFCMP;
              buf = Buffer2.concat([bufferHeader, compressedDataBuffer]);
              buf.writeUInt16BE(dataFlags, constants.NSPDAFLG);
              const pktOffset = resultLength + constants.NSPDADAT;
              if (this.sAtts.largeSDU) {
                buf.writeUInt32BE(pktOffset, constants.NSPHDLEN);
              } else {
                buf.writeUInt16BE(pktOffset, constants.NSPHDLEN);
              }
            }
          }
        }
        this.ntAdapter.send(buf);
      }
      /**
       * Break ongoing operation
       */
      sendBreak() {
        if (this.isBreak)
          return;
        if (!this.connected) {
          this.isBreak = true;
          this.breakPosted = true;
          return;
        }
        this.isBreak = true;
        this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQIMARK);
        this.sendPacket(this.markerPkt.buf);
      }
      /**
       * Reset the connection
       */
      async reset() {
        if (this.breakPosted) {
          this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQBMARK);
          this.sendPacket(this.markerPkt.buf);
          this.breakPosted = false;
        }
        this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQRMARK);
        this.sendPacket(this.markerPkt.buf);
        while (!this.isReset) {
          await this._recvPacket();
        }
        this.sndDatapkt.dataPtr = this.sndDatapkt.dataLen = constants.NSPDADAT;
        this.sndDatapkt.offset = this.sndDatapkt.dataPtr;
        this.sndDatapkt.len = this.sndDatapkt.bufLen;
        this.isBreak = this.isReset = false;
      }
      /**
      * Receive packet
      */
      async recvPacket() {
        return await this._recvPacket();
      }
      syncRecvPacket() {
        while (this.ntAdapter.packets.length > 0) {
          const packet = this.ntAdapter.syncReceive();
          if (!packet)
            break;
          this._processPacket(packet);
          if (packet.type !== constants.NSPTCNL)
            return packet;
        }
      }
      /**
       * Send data
       * @param {Buffer} userBuf User provided buffer
       * @param {*} offset from which to send data
       * @param {*} len number of bytes to send
       */
      _send(userBuf, offset, len) {
        if (this.isBreak) {
          return;
        }
        let bytesCopied = 0;
        this.sndDatapkt.dataLen = this.sndDatapkt.offset;
        if (this.sndDatapkt.dataLen < this.sndDatapkt.bufLen || !this.sndDatapkt.bufLen) {
          bytesCopied = this.sndDatapkt.fillBuf(userBuf, offset, len);
          len -= bytesCopied;
          offset += bytesCopied;
          this.sndDatapkt.offset = this.sndDatapkt.dataLen;
        }
        while (len) {
          this.sendPacket(this.sndDatapkt.dataBuf);
          if (this.isBreak) {
            return;
          }
          this.sndDatapkt.dataLen = this.sndDatapkt.dataPtr;
          this.sndDatapkt.offset = this.sndDatapkt.dataPtr;
          bytesCopied = this.sndDatapkt.fillBuf(userBuf, offset, len);
          len -= bytesCopied;
          offset += bytesCopied;
          this.sndDatapkt.offset = this.sndDatapkt.dataLen;
        }
      }
      /**
       * Flush send buffers
       */
      flush() {
        if (this.isBreak) {
          return;
        }
        this.sndDatapkt.dataLen = this.sndDatapkt.offset;
        this.sndDatapkt.prepare2Send();
        this.sendPacket(Buffer2.from(this.sndDatapkt.dataBuf));
        this.sndDatapkt.dataLen = this.sndDatapkt.dataPtr;
        this.sndDatapkt.offset = this.sndDatapkt.dataPtr;
      }
      /**
       * Establish network connection
      */
      async connect(userConfig) {
        const connStr = userConfig.connectString ? userConfig.connectString : userConfig.connectionString;
        let addressNode;
        if (userConfig._connInfo) {
          addressNode = userConfig._connInfo[5];
          addressNode.reset();
        } else {
          addressNode = await resolveAddress(connStr, userConfig);
        }
        let address;
        try {
          address = await this.getAddress(addressNode, userConfig);
        } catch (err) {
          if (err.message == "All options tried")
            errors.throwErr(errors.ERR_HOST_NOT_FOUND);
          else
            errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, err.message);
        }
        await this.connect1(address, addressNode, userConfig);
      }
      /**
       * Force Disconnect the stream, primarily used
       * to disconnect dead/hung connections.
       */
      forceDisconnect(err) {
        if (!this.connected) {
          return;
        }
        this.ntAdapter.stream.destroy(err);
        this.connected = false;
      }
      /**
       * Disconnect
       * @param {int} type of disconnect
       */
      disconnect(type) {
        if (!this.connected) {
          return;
        }
        if (type != constants.NSFIMM && !this.ntAdapter.err) {
          this.sndDatapkt.dataLen = this.sndDatapkt.offset;
          this.sndDatapkt.prepare2Send(constants.NSPDAFEOF);
          this.sendPacket(this.sndDatapkt.dataBuf);
        }
        this.ntAdapter.disconnect(type);
        this.ntAdapter = null;
        this.connected = false;
      }
      /**
       * Get connection attributes
       * @param {int} opcode type of attribute
       * @returns attribute value
       */
      getOption(opcode) {
        switch (opcode) {
          case constants.NS_MOREDATA:
            return this.ntAdapter.packets.length > 0;
          case constants.SVCNAME:
            return findValue(this.cDataNVPair, ["DESCRIPTION", "CONNECT_DATA", "SERVICE_NAME"]);
          case constants.SID:
            return findValue(this.cDataNVPair, ["DESCRIPTION", "CONNECT_DATA", "SID"]);
          case constants.SERVERTYPE:
            return findValue(this.cDataNVPair, ["DESCRIPTION", "CONNECT_DATA", "SERVER"]);
          case constants.REMOTEADDR:
            if (this.ntAdapter) {
              return this.ntAdapter.getOption(opcode);
            } else {
              return null;
            }
          case constants.CONNCLASS:
            return findValue(this.cDataNVPair, ["DESCRIPTION", "CONNECT_DATA", "POOL_CONNECTION_CLASS"]);
          case constants.PURITY:
            return findValue(this.cDataNVPair, ["DESCRIPTION", "CONNECT_DATA", "POOL_PURITY"]);
          case constants.HEALTHCHECK:
            return this.connected && this.ntAdapter.connected && !this.ntAdapter.err;
          default:
            errors.throwErr(errors.ERR_INTERNAL, "getOption not supported for opcode " + opcode);
        }
      }
      /**
       * receive inband notification
       * @param {Object} obj Return the notification into user provided object
       * @returns Error number sent from server, or error on the connection.
       * returns 0 if healthy connection
       */
      recvInbandNotif() {
        let error = 0;
        if (this.controlPkt.errno) {
          error = this.controlPkt.errno;
          return error;
        } else if (!this.getOption(constants.HEALTHCHECK)) {
          return errors.ERR_CONNECTION_CLOSED;
        } else {
          if (this.getOption(constants.NS_MOREDATA)) {
            const packet = this.ntAdapter.syncReceive();
            if (packet.type == constants.NSPTCNL) {
              this.controlPkt.fromPacket(packet);
              error = this.controlPkt.errno;
              return error;
            } else {
              this.ntAdapter.packets.unshift(packet);
              return 0;
            }
          } else
            return 0;
        }
      }
    };
    module2.exports = {
      NetworkSession,
      resolveAddress,
      getConnectionInfo
    };
  }
});

// node_modules/oracledb/lib/thin/statement.js
var require_statement = __commonJS({
  "node_modules/oracledb/lib/thin/statement.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants();
    var errors = require_errors();
    var protoConstants = require_constants3();
    var BindInfo = class {
      constructor(name, isReturnBind = false) {
        this.bindName = name;
        this.isReturnBind = isReturnBind;
        this.maxSize = 0;
        this.numElements = 0;
        this.maxArraySize = 0;
        this.type = null;
        this.isArray = false;
        this.dir = constants.BIND_IN;
        this.bindVar = null;
      }
    };
    module2.exports.BindInfo = BindInfo;
    var Parser = class {
      constructor() {
        this.returningKeywordFound = false;
        this.pos = 0;
        this.maxPos = 0;
        this.sqlData = "";
      }
      /**
       * Bind variables are identified as follows:
       *  - Quoted and non-quoted bind names are allowed.
       *  - Quoted bind names can contain any characters.
       *  - Non-quoted bind names must begin with an alphabetic character.
       *  - Non-quoted bind names can only contain alphanumeric characters, the
       *    underscore, the dollar sign and the pound sign.
       *  - Non-quoted bind names cannot be Oracle Database Reserved Names (this
       *    is left to the server to detect and return an appropriate error).
       */
      _parseBindName(stmt) {
        let quotedName = false;
        let inBind = false;
        let digitsOnly = false;
        let startPos = 0;
        let pos = this.pos + 1;
        let bindName;
        let ch;
        while (pos <= this.maxPos) {
          ch = this.sqlData[pos];
          if (!inBind) {
            if (/\p{space}/u.test(ch)) {
              pos += 1;
              continue;
            } else if (ch === '"') {
              quotedName = true;
            } else if (/\p{N}/u.test(ch)) {
              digitsOnly = true;
            } else if (!/\p{Alpha}/u.test(ch)) {
              break;
            }
            inBind = true;
            startPos = pos;
          } else if (digitsOnly && !/\p{N}/u.test(ch)) {
            this.pos = pos - 1;
            break;
          } else if (quotedName && ch === '"') {
            this.pos = pos;
            break;
          } else if (!digitsOnly && !quotedName && !/[\p{L}\p{N}]/u.test(ch) && !["$", "_", "#"].includes(ch)) {
            this.pos = pos - 1;
            break;
          }
          pos += 1;
        }
        if (inBind) {
          if (quotedName) {
            bindName = stmt.sql.substring(startPos + 1, pos);
          } else if (digitsOnly) {
            bindName = stmt.sql.substring(startPos, pos);
          } else {
            bindName = stmt.sql.substring(startPos, pos).toUpperCase();
          }
          stmt._addBind(bindName);
        }
      }
      /**
       * Multiple line comments consist of the characters /* followed by all
       * characters up until * followed by /. This method is called when the first
       * slash is detected and checks for the subsequent asterisk. If found,
       * the comment is traversed and the current position is updated; otherwise,
       * the current position is left untouched.
       */
      _parseMultiLineComment() {
        let inComment = false;
        let exitingComment = false;
        let pos = this.pos + 1;
        let ch;
        while (pos <= this.maxPos) {
          ch = this.sqlData[pos];
          if (!inComment) {
            if (ch !== "*") {
              break;
            }
            inComment = true;
          } else if (ch === "*") {
            exitingComment = true;
          } else if (exitingComment) {
            if (ch === "/") {
              this.pos = pos;
              break;
            }
            exitingComment = false;
          }
          pos += 1;
        }
      }
      /** Parses a q-string which consists of the characters "q" and a single
       * quote followed by a start separator, any text that does not contain the
       * end seprator and the end separator and ending quote. The following are
       * examples that demonstrate this:
       *   - q'[...]'
       *   - q'{...}'
       *   - q'<...>'
       *   - q'(...)'
       *   - q'?...?' (where ? is any character)
       */
      _parseQstring() {
        let exitingQstring = false;
        let inQstring = false;
        let sep;
        let ch;
        this.pos += 1;
        while (this.pos <= this.maxPos) {
          ch = this.sqlData[this.pos];
          if (!inQstring) {
            if (ch === "[") {
              sep = "]";
            } else if (ch === "{") {
              sep = "}";
            } else if (ch === "(") {
              sep = ")";
            } else if (ch === "<") {
              sep = ">";
            } else {
              sep = ch;
            }
            inQstring = true;
          } else if (!exitingQstring && ch === sep) {
            exitingQstring = true;
          } else if (exitingQstring) {
            if (ch === "'") {
              break;
            } else if (ch !== sep) {
              exitingQstring = false;
            }
          }
          this.pos += 1;
        }
      }
      /**
       * Parses a quoted string with the given separator. All characters until
       * the separate is detected are discarded.
       */
      _parseQuotedString(sep) {
        let ch;
        this.pos += 1;
        while (this.pos <= this.maxPos) {
          ch = this.sqlData[this.pos];
          if (ch === sep) {
            break;
          }
          this.pos += 1;
        }
      }
      /**
       * Single line comments consist of two dashes and all characters up to the
       * next line break (or the end of the data). This method is called when
       * the first dash is detected and checks for the subsequent dash. If found,
       * the single line comment is traversed and the current position is updated;
       * otherwise, the current position is left untouched.
       */
      _parseSingleLineComment() {
        let inComment = false;
        let pos = this.pos + 1;
        let ch;
        while (pos <= this.maxPos) {
          ch = this.sqlData[pos];
          if (!inComment) {
            if (ch !== "-") {
              return;
            }
            inComment = true;
          } else if (ch === "\n") {
            break;
          }
          pos += 1;
        }
        this.pos = pos;
      }
      /**
       * Parses the SQL stored in the statement in order to determine the
       * keyword that identifies the type of SQL being executed as well as a
       * list of bind variable names. A check is also made for DML returning
       * statements since the bind variables following the "INTO" keyword are
       * treated differently from other bind variables.
       */
      parse(stmt) {
        let initialKeywordFound = false;
        let lastWasString = false;
        let ch, lastCh = "", alphaStartCh = "";
        let alphaStartPos = 0, alphaLen;
        let isAlpha, lastWasAlpha = false;
        let keyword;
        this.pos = 0;
        this.maxPos = stmt.sql.length - 1;
        this.sqlData = stmt.sql;
        while (this.pos <= this.maxPos) {
          ch = this.sqlData[this.pos];
          isAlpha = /\p{L}/u.test(ch);
          if (isAlpha && !lastWasAlpha) {
            alphaStartPos = this.pos;
            alphaStartCh = ch;
          } else if (!isAlpha && lastWasAlpha) {
            alphaLen = this.pos - alphaStartPos;
            if (!initialKeywordFound) {
              keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();
              stmt._determineStatementType(keyword);
              initialKeywordFound = true;
              if (stmt.isDdl) {
                break;
              }
            } else if (stmt.isDml && !this.returningKeywordFound && (alphaLen === 9 || alphaLen === 6) && ["r", "R"].includes(alphaStartCh)) {
              keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();
              if (["RETURNING", "RETURN"].includes(keyword)) {
                this.returningKeywordFound = true;
              }
            } else if (this.returningKeywordFound && alphaLen === 4 && ["i", "I"].includes(alphaStartCh)) {
              keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();
              if (keyword === "INTO") {
                stmt.isReturning = true;
              }
            }
          }
          if (ch === "'") {
            lastWasString = true;
            if (["q", "Q"].includes(lastCh)) {
              this._parseQstring();
            } else {
              this._parseQuotedString(ch);
            }
          } else if (!/\p{space}/u.test(ch)) {
            if (ch === "-") {
              this._parseSingleLineComment();
            } else if (ch === "/") {
              this._parseMultiLineComment();
            } else if (ch === '"') {
              this._parseQuotedString(ch);
            } else if (ch === ":" && !lastWasString) {
              this._parseBindName(stmt);
            }
            lastWasString = false;
          }
          this.pos += 1;
          lastWasAlpha = isAlpha;
          lastCh = ch;
        }
        if (!initialKeywordFound) {
          stmt._determineStatementType(stmt.sql.toUpperCase());
        }
      }
    };
    var Statement = class _Statement {
      constructor() {
        this.sql = "";
        this.sqlBytes = [];
        this.sqlLength = 0;
        this.cursorId = 0;
        this.requiresDefine = false;
        this.isQuery = false;
        this.isPlSql = false;
        this.isDml = false;
        this.isDdl = false;
        this.isReturning = false;
        this.bindInfoList = [];
        this.queryVars = [];
        this.bindInfoDict = /* @__PURE__ */ new Map();
        this.requiresFullExecute = false;
        this.noPrefetch = false;
        this.returnToCache = false;
        this.numColumns = 0;
        this.lastRowIndex;
        this.lastRowid;
        this.moreRowsToFetch = true;
        this.inUse = false;
        this.bufferRowIndex = 0;
        this.bufferRowCount = 0;
        this.pendingClear = false;
        this.statementType = constants.STMT_TYPE_UNKNOWN;
      }
      //---------------------------------------------------------------------------
      // _copy()
      //
      // Copying existing statement into new statement object required by drcp
      //---------------------------------------------------------------------------
      _copy() {
        const copiedStatement = new _Statement();
        copiedStatement.sql = this.sql;
        copiedStatement.sqlBytes = this.sqlBytes;
        copiedStatement.sqlLength = this.sqlLength;
        copiedStatement.isQuery = this.isQuery;
        copiedStatement.isPlSql = this.isPlSql;
        copiedStatement.isDml = this.isDml;
        copiedStatement.isDdl = this.isDdl;
        copiedStatement.isReturning = this.isReturning;
        copiedStatement.bindInfoList = [];
        for (const bindInfo of this.bindInfoList) {
          const newBindInfo = new BindInfo(bindInfo.bindName, bindInfo.isReturnBind);
          copiedStatement.bindInfoList.push(newBindInfo);
        }
        const bindInfoDict = copiedStatement.bindInfoDict = /* @__PURE__ */ new Map();
        for (const bindInfo of copiedStatement.bindInfoList) {
          if (bindInfoDict.has(bindInfo.bindName)) {
            bindInfoDict.get(bindInfo.bindName).push(bindInfo);
          } else {
            bindInfoDict.set(bindInfo.bindName, [bindInfo]);
          }
        }
        copiedStatement.returnToCache = false;
        return copiedStatement;
      }
      //---------------------------------------------------------------------------
      // _determineStatementType(sql)
      //
      // Determine the type of the SQL statement by examining the first keyword
      // found in the statement
      //---------------------------------------------------------------------------
      _determineStatementType(sqlKeyword) {
        switch (sqlKeyword) {
          case "DECLARE":
            this.isPlSql = true;
            this.statementType = constants.STMT_TYPE_DECLARE;
            break;
          case "CALL":
            this.isPlSql = true;
            this.statementType = constants.STMT_TYPE_CALL;
            break;
          case "BEGIN":
            this.isPlSql = true;
            this.statementType = constants.STMT_TYPE_BEGIN;
            break;
          case "SELECT":
            this.isQuery = true;
            this.statementType = constants.STMT_TYPE_SELECT;
            break;
          case "WITH":
            this.isQuery = true;
            break;
          case "INSERT":
            this.isDml = true;
            this.statementType = constants.STMT_TYPE_INSERT;
            break;
          case "UPDATE":
            this.isDml = true;
            this.statementType = constants.STMT_TYPE_UPDATE;
            break;
          case "DELETE":
            this.isDml = true;
            this.statementType = constants.STMT_TYPE_DELETE;
            break;
          case "MERGE":
            this.isDml = true;
            this.statementType = constants.STMT_TYPE_MERGE;
            break;
          case "ALTER":
            this.isDdl = true;
            this.statementType = constants.STMT_TYPE_ALTER;
            break;
          case "CREATE":
            this.isDdl = true;
            this.statementType = constants.STMT_TYPE_CREATE;
            break;
          case "DROP":
            this.isDdl = true;
            this.statementType = constants.STMT_TYPE_DROP;
            break;
          case "ANALYZE":
          case "AUDIT":
          case "COMMENT":
          case "GRANT":
          case "REVOKE":
          case "TRUNCATE":
            this.isDdl = true;
            break;
          case "COMMIT":
            this.statementType = constants.STMT_TYPE_COMMIT;
            break;
          case "ROLLBACK":
            this.statementType = constants.STMT_TYPE_ROLLBACK;
            break;
          default:
            this.statementType = constants.STMT_TYPE_UNKNOWN;
            break;
        }
      }
      //---------------------------------------------------------------------------
      // prepare(sql)
      //
      // Prepare the SQL for execution by determining the list of bind names
      // that are found within it. The length of the SQL text is also calculated
      // at this time.
      //---------------------------------------------------------------------------
      _prepare(sql) {
        this.sql = sql;
        this.sqlBytes = Buffer2.from(this.sql, "utf8");
        this.sqlLength = this.sqlBytes.length;
        const parser = new Parser();
        parser.parse(this);
      }
      //---------------------------------------------------------------------------
      // _addBinds(sql)
      //
      // Add bind information to the statement by examining the passed SQL for
      // bind variable names.
      //---------------------------------------------------------------------------
      _addBind(name) {
        if (!this.isPlSql || !this.bindInfoDict.has(name)) {
          const info = new BindInfo(name, this.isReturning);
          this.bindInfoList.push(info);
          if (this.bindInfoDict.has(info.bindName)) {
            if (this.isReturning) {
              const origInfo = this.bindInfoDict.get(info.bindName)[0];
              if (!origInfo.isReturnBind) {
                errors.throwErr(errors.ERR_DML_RETURNING_DUP_BINDS, name);
              }
            }
            this.bindInfoDict.get(info.bindName).push(info);
          } else {
            this.bindInfoDict.set(info.bindName, [info]);
          }
        }
      }
      //---------------------------------------------------------------------------
      // _setVariable(sql)
      //
      // Set the variable on the bind information and copy across metadata that
      // will be used for binding. If the bind metadata has changed, mark the
      // statement as requiring a full execute. In addition, binding a REF
      // cursor also requires a full execute.
      //---------------------------------------------------------------------------
      _setVariable(bindInfo, variable) {
        if (variable.type._oraTypeNum === protoConstants.TNS_DATA_TYPE_CURSOR) {
          this.requiresFullExecute = true;
        }
        if (variable.maxSize !== bindInfo.maxSize || variable.dir !== bindInfo.dir || variable.isArray !== bindInfo.isArray || variable.values.length > bindInfo.numElements || variable.type != bindInfo.type || variable.maxArraySize != bindInfo.maxArraySize) {
          bindInfo.isArray = variable.isArray;
          bindInfo.numElements = variable.values.length;
          bindInfo.maxSize = variable.maxSize;
          bindInfo.type = variable.type;
          bindInfo.dir = variable.dir;
          bindInfo.maxArraySize = variable.maxArraySize;
          this.requiresFullExecute = true;
        }
        bindInfo.bindVar = variable;
      }
      //---------------------------------------------------------------------------
      // _clearAllState
      //
      // clear all state associated with the cursor
      //---------------------------------------------------------------------------
      _clearAllState() {
        this.cursorId = 0;
        this.requiresDefine = false;
        this.noPrefetch = false;
        this.requiresFullExecute = false;
        this.queryVars = [];
        this.numQueryVars = 0;
        this.bufferRowCount = 0;
        this.bufferRowIndex = 0;
      }
      //---------------------------------------------------------------------------
      // _clearState
      //
      // clear some state associated with the cursor
      //---------------------------------------------------------------------------
      _clearState() {
        this.cursorId = 0;
        this.requiresDefine = false;
        this.noPrefetch = false;
        this.requiresFullExecute = false;
      }
    };
    module2.exports.Statement = Statement;
  }
});

// node_modules/oracledb/lib/thin/protocol/encryptDecrypt.js
var require_encryptDecrypt = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/encryptDecrypt.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var crypto = require("crypto");
    var algorithm = "aes-256-cbc";
    var _appendBuffer = Buffer2.from([0, 1]);
    var EncryptDecrypt = class {
      // Key length is dependent on the algorithm. In this case for aes192, it is
      // 24 bytes (192 bits).
      decrypt(key, val) {
        const iv = Buffer2.alloc(16, 0);
        const decipher = crypto.createDecipheriv(algorithm, key, iv);
        decipher.setAutoPadding(false);
        let decrypted = decipher.update(val);
        decrypted = Buffer2.concat([decrypted, decipher.final()]);
        return decrypted;
      }
      _encrypt(key, val, padding) {
        const block_size = 16;
        const iv = Buffer2.alloc(block_size, 0);
        const n = block_size - val.length % block_size;
        const nv = Buffer2.alloc(n, n);
        if (n > 0) {
          if (padding) {
            val += Buffer2.alloc(n);
          } else {
            val = Buffer2.concat([val, nv]);
          }
        }
        const cipher = crypto.createCipheriv(algorithm, key, iv);
        let encrypted = cipher.update(val);
        encrypted = Buffer2.concat([encrypted, cipher.final()]);
        if (!padding) {
          encrypted = encrypted.slice(0, val.length);
        }
        val.fill(0);
        return encrypted;
      }
      // Encrypt password and newPassword using comboKey
      _setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, comboKey, authObj) {
        const salt = Buffer2.alloc(16);
        crypto.randomFillSync(salt, 0, 16);
        const temp = Buffer2.concat([salt, passwordBytes]);
        authObj.encodedPassword = this._encrypt(comboKey, temp);
        temp.fill(0);
        authObj.encodedPassword = authObj.encodedPassword.slice().toString("hex").toUpperCase();
        if (newPasswordBytes) {
          const newPasswordWithSalt = Buffer2.concat([salt, newPasswordBytes]);
          authObj.encodedNewPassword = this._encrypt(comboKey, newPasswordWithSalt);
          newPasswordWithSalt.fill(0);
          authObj.encodedNewPassword = authObj.encodedNewPassword.slice().toString("hex").toUpperCase();
        }
        passwordBytes.fill(0);
        if (newPasswordBytes) {
          newPasswordBytes.fill(0);
        }
      }
      /**
       * updates authObject with required data.
       *
       * @param {object} sessionData The key/value pairs returned from OSESS key rpc
       * @param {string} password    Current Password of user
       * @param {string} newPassword New password to be updated
       * @param {boolean} verifier11G Verifier type 11g or not(12c)
       */
      updateVerifierData(sessionData, password, newPassword, verifier11G, authObj) {
        let keyLen = 32;
        let hashAlg = "sha512";
        const verifierData = Buffer2.from(sessionData["AUTH_VFR_DATA"], "hex");
        const encodedServerKey = Buffer2.from(sessionData["AUTH_SESSKEY"], "hex");
        let iterations = Number(sessionData["AUTH_PBKDF2_VGEN_COUNT"]);
        const passwordBytes = Buffer2.from(password, "utf8");
        let passwordHash;
        let passwordKey;
        if (verifier11G) {
          algorithm = "aes-192-cbc";
          keyLen = 24;
          hashAlg = "sha1";
          const h = crypto.createHash(hashAlg);
          h.update(passwordBytes);
          h.update(verifierData);
          const ph = h.digest();
          passwordHash = Buffer2.alloc(ph.length + 4);
          ph.copy(passwordHash, 0, 0, ph.length);
        } else {
          algorithm = "aes-256-cbc";
          const temp = Buffer2.from("AUTH_PBKDF2_SPEEDY_KEY", "utf8");
          const salt2 = Buffer2.concat([verifierData, temp]);
          passwordKey = crypto.pbkdf2Sync(passwordBytes, salt2, iterations, 64, "sha512");
          const h = crypto.createHash(hashAlg);
          h.update(passwordKey);
          h.update(verifierData);
          passwordHash = h.digest().slice(0, keyLen);
        }
        let newPasswordBytes;
        if (newPassword) {
          newPasswordBytes = Buffer2.from(newPassword, "utf8");
        }
        const sessionKeyParta = this.decrypt(passwordHash, encodedServerKey);
        const sessionKeyPartb = Buffer2.alloc(sessionKeyParta.length);
        crypto.randomFillSync(sessionKeyPartb);
        const encodedClientKey = this._encrypt(passwordHash, sessionKeyPartb);
        if (sessionKeyParta.length === 48) {
          authObj.sessionKey = encodedClientKey.slice().toString("hex").toUpperCase().slice(0, 96);
          const buf = Buffer2.alloc(24);
          for (let i = 16; i <= 40; i++) {
            buf[i - 16] = sessionKeyParta[i] ^ sessionKeyPartb[i];
          }
          const part1 = crypto.createHash("md5").update(buf.subarray(0, 16)).digest();
          const part2 = crypto.createHash("md5").update(buf.subarray(16)).digest();
          authObj.comboKey = Buffer2.concat([part1, part2]).slice(0, keyLen);
        } else {
          authObj.sessionKey = encodedClientKey.slice().toString("hex").toUpperCase().slice(0, 64);
          const mixingSalt = Buffer2.from(sessionData["AUTH_PBKDF2_CSK_SALT"], "hex");
          iterations = Number(sessionData["AUTH_PBKDF2_SDER_COUNT"]);
          const partABKey = Buffer2.concat([sessionKeyPartb.slice(0, keyLen), sessionKeyParta.slice(0, keyLen)]);
          const partABKeyStr = partABKey.toString("hex").toUpperCase();
          const partABKeyBuffer = Buffer2.from(partABKeyStr, "utf8");
          authObj.comboKey = crypto.pbkdf2Sync(
            partABKeyBuffer,
            mixingSalt,
            iterations,
            keyLen,
            "sha512"
          );
        }
        const salt = Buffer2.alloc(16);
        if (!verifier11G) {
          crypto.randomFillSync(salt, 0, 16);
          const temp = Buffer2.concat([salt, passwordKey]);
          authObj.speedyKey = this._encrypt(authObj.comboKey, temp);
          authObj.speedyKey = authObj.speedyKey.slice(0, 80).toString("hex").toUpperCase();
        }
        this._setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, authObj.comboKey, authObj);
      }
      getEncryptedJSWPData(sessionKey, jdwpData) {
        let buf = this._encrypt(sessionKey, jdwpData, true);
        buf = buf.slice().toString("hex").toUpperCase();
        buf = Buffer2.concat([buf, _appendBuffer]);
        return buf;
      }
      updatePasswordsWithComboKey(password, newPassword, comboKey, authObj) {
        const passwordBytes = Buffer2.from(password, "utf8");
        let newPasswordBytes;
        if (newPassword) {
          newPasswordBytes = Buffer2.from(newPassword, "utf8");
        }
        this._setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, comboKey, authObj);
      }
    };
    var encryptDecryptInst = new EncryptDecrypt();
    module2.exports = encryptDecryptInst;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/auth.js
var require_auth = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/auth.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var constants = require_constants3();
    var errors = require_errors();
    var process2 = require("process");
    var ED = require_encryptDecrypt();
    var Message = require_base2();
    var util = require_util2();
    var cInfo = util.CLIENT_INFO;
    var crypto = require("crypto");
    var AuthMessage = class extends Message {
      /**
       * Represents the data required for OAUTH and OSESSKEY rpc.
       *
       * @param {object} conn Connection object
       * @param {object} config Dynamic Configuration like change password config after connection is established
       */
      constructor(conn, config) {
        super(conn);
        this.functionCode = constants.TNS_FUNC_AUTH_PHASE_ONE;
        this.messageType = constants.TNS_MSG_TYPE_FUNCTION;
        this.sessionData = {};
        this.conn = conn;
        this.sessionKey = "";
        this.encodedPassword = "";
        this.changePassword = false;
        Object.defineProperty(this, "password", {
          enumerable: false,
          value: config.password
        });
        this.username = config.user;
        if (this.username === void 0) {
          this.username = "";
        } else {
          this.username = this.username.trim();
        }
        this.schemaUser = "";
        this.proxyUser = "";
        this.proxyStatus = -1;
        if (this.username.length !== 0) {
          this.proxyStatusObj = util.checkProxyUserValidity(this.username);
          if (this.proxyStatusObj.status === 0) {
            this.proxyStatus = 0;
            this.proxyUser = this.proxyStatusObj.proxyUser;
            this.schemaUser = this.proxyStatusObj.schemaUser;
            this.username = this.proxyUser;
          }
        }
        this.newPassword = config.newPassword;
        if (config.changePassword) {
          this.changePassword = true;
          this.functionCode = constants.TNS_FUNC_AUTH_PHASE_TWO;
        }
        if (this.username) {
          this.userByteLen = Buffer2.byteLength(this.username);
        } else {
          this.userByteLen = 0;
        }
        this.token = config.token;
        if (config.externalAuth) {
          this.functionCode = constants.TNS_FUNC_AUTH_PHASE_TWO;
          this.externalAuth = true;
        }
        this.privateKey = config.privateKey;
        if (this.privateKey) {
          this.privateKey = util.normalizePrivateKey(this.privateKey);
        }
        this.serviceName = this.conn.serviceName;
        this.remoteAddress = this.conn.remoteAddress;
        this.driverName = config.driverName;
        this.machine = config.machine;
        this.osUser = config.osUser;
        this.program = config.program;
        this.terminal = config.terminal;
        if (config.edition) {
          this.edition = config.edition;
        } else if (process2.env.ORA_EDITION) {
          this.edition = process2.env.ORA_EDITION;
        }
        this.appContext = config.appContext;
        this.setAuthMode(config);
      }
      setAuthMode(config) {
        if (!this.newPassword) {
          this.authMode = constants.TNS_AUTH_MODE_LOGON;
        }
        if (config.privilege & constants.SYSDBA) {
          this.authMode |= constants.TNS_AUTH_MODE_SYSDBA;
        }
        if (config.privilege & constants.SYSOPER) {
          this.authMode |= constants.TNS_AUTH_MODE_SYSOPER;
        }
        if (config.privilege & constants.SYSASM) {
          this.authMode |= constants.TNS_AUTH_MODE_SYSASM;
        }
        if (config.privilege & constants.SYSBKP) {
          this.authMode |= constants.TNS_AUTH_MODE_SYSBKP;
        }
        if (config.privilege & constants.SYSDG) {
          this.authMode |= constants.TNS_AUTH_MODE_SYSDGD;
        }
        if (config.privilege & constants.SYSKM) {
          this.authMode |= constants.TNS_AUTH_MODE_SYSKMT;
        }
        if (config.privilege & constants.SYSRAC) {
          this.authMode |= constants.TNS_AUTH_MODE_SYSRAC;
        }
        if (this.privateKey) {
          this.authMode |= constants.TNS_AUTH_MODE_IAM_TOKEN;
        }
        if (this.newPassword) {
          this.authMode |= constants.TNS_AUTH_MODE_CHANGE_PASSWORD;
        }
        if (!config.externalAuth) {
          this.authMode |= constants.TNS_AUTH_MODE_WITH_PASSWORD;
        }
      }
      getAlterTimezoneStatement() {
        let sign, tzRepr;
        if (process2.env.ORA_SDTZ) {
          tzRepr = process2.env.ORA_SDTZ;
        } else {
          const date = /* @__PURE__ */ new Date();
          const timezoneMinutes = date.getTimezoneOffset();
          let tzHour = Math.trunc(timezoneMinutes / 60);
          const tzMinutes = Math.abs((timezoneMinutes - tzHour * 60) % 60);
          if (tzHour < 0) {
            sign = "+";
            tzHour = -tzHour;
          } else {
            sign = "-";
          }
          tzHour = tzHour.toLocaleString("en-US", { minimumIntegerDigits: 2 });
          tzRepr = `${sign}${tzHour}:${tzMinutes}`;
        }
        return `ALTER SESSION SET TIME_ZONE ='${tzRepr}'\0`;
      }
      encode(buf) {
        let verifier11G = false;
        this.writeFunctionHeader(buf);
        if (this.userByteLen > 0) {
          buf.writeUInt8(1);
        } else {
          buf.writeUInt8(0);
        }
        buf.writeUB4(this.userByteLen);
        buf.writeUB4(this.authMode);
        if (this.functionCode === constants.TNS_FUNC_AUTH_PHASE_ONE) {
          buf.writeUInt8(1);
          buf.writeUB4(5);
          buf.writeUInt8(0);
          buf.writeUInt8(1);
          if (this.userByteLen > 0) {
            buf.writeBytesWithLength(Buffer2.from(this.username));
          }
          buf.writeKeyValue("AUTH_TERMINAL", this.terminal ?? cInfo.terminal);
          buf.writeKeyValue("AUTH_PROGRAM_NM", this.program ?? cInfo.program);
          buf.writeKeyValue("AUTH_MACHINE", this.machine ?? cInfo.hostName);
          buf.writeKeyValue("AUTH_PID", cInfo.pid);
          buf.writeKeyValue("AUTH_SID", this.osUser ?? cInfo.userName);
        } else {
          let numPairs = 0;
          if (this.changePassword) {
            ED.updatePasswordsWithComboKey(this.password, this.newPassword, this.conn.comboKey, this);
            numPairs = 2;
          } else {
            numPairs = 4;
            if (this.externalAuth) {
              numPairs += 5;
              if (this.token)
                numPairs += 1;
            } else {
              numPairs += 2;
              if (this.verifierType === constants.TNS_VERIFIER_TYPE_11G_1 || this.verifierType === constants.TNS_VERIFIER_TYPE_11G_2) {
                verifier11G = true;
              } else if (this.verifierType !== constants.TNS_VERIFIER_TYPE_12C) {
                errors.throwErr(
                  errors.ERR_UNSUPPORTED_VERIFIER_TYPE,
                  this.verifierType.toString(16)
                );
              } else {
                numPairs += 1;
              }
              ED.updateVerifierData(this.sessionData, this.password, this.newPassword, verifier11G, this);
              this.conn.comboKey = this.comboKey;
              if (this.newPassword) {
                numPairs += 1;
              }
            }
            if (this.privateKey) {
              numPairs += 2;
            }
            if (this.conn.connectionClass) {
              numPairs += 1;
            }
            if (this.conn.purity) {
              numPairs += 1;
            }
            if (this.conn.jdwpData) {
              this.encryptedJDWPData = ED.getEncryptedJSWPData(this.sessionKey, this.conn.jdwpData);
              numPairs += 1;
            }
            if (this.edition) {
              numPairs += 1;
            }
            if (this.appContext) {
              numPairs += this.appContext.length * 3;
            }
            if (this.schemaUser.length !== 0) {
              numPairs += 1;
            }
          }
          buf.writeUInt8(1);
          buf.writeUB4(numPairs);
          buf.writeUInt8(1);
          buf.writeUInt8(1);
          if (this.userByteLen > 0)
            buf.writeBytesWithLength(Buffer2.from(this.username));
          if (this.externalAuth) {
            buf.writeKeyValue("AUTH_TERMINAL", this.terminal ?? cInfo.terminal);
            buf.writeKeyValue("AUTH_PROGRAM_NM", this.program ?? cInfo.program);
            buf.writeKeyValue("AUTH_MACHINE", this.machine ?? cInfo.hostName);
            buf.writeKeyValue("AUTH_PID", cInfo.pid);
            buf.writeKeyValue("AUTH_SID", this.osUser ?? cInfo.userName);
          }
          if (this.token) {
            buf.writeKeyValue("AUTH_TOKEN", this.token);
          } else {
            if (!this.changePassword && !this.externalAuth) {
              buf.writeKeyValue("AUTH_SESSKEY", this.sessionKey, 1);
              if (!verifier11G) {
                buf.writeKeyValue("AUTH_PBKDF2_SPEEDY_KEY", this.speedyKey);
              }
            }
          }
          if (!this.changePassword) {
            buf.writeKeyValue("SESSION_CLIENT_CHARSET", "873");
            buf.writeKeyValue(
              "SESSION_CLIENT_DRIVER_NAME",
              this.driverName ?? constants.DRIVER_NAME
            );
            buf.writeKeyValue(
              "SESSION_CLIENT_VERSION",
              constants.CLIENT_VERSION.toString()
            );
            buf.writeKeyValue("AUTH_ALTER_SESSION", this.getAlterTimezoneStatement(), 1);
          }
          if (this.encodedPassword) {
            buf.writeKeyValue("AUTH_PASSWORD", this.encodedPassword);
          }
          if (this.proxyStatus === 0) {
            buf.writeKeyValue("PROXY_CLIENT_NAME", this.schemaUser);
          }
          if (this.encodedNewPassword) {
            buf.writeKeyValue("AUTH_NEWPASSWORD", this.encodedNewPassword);
          }
          if (this.conn.connectionClass) {
            buf.writeKeyValue("AUTH_KPPL_CONN_CLASS", this.conn.connectionClass);
          }
          if (this.conn.purity) {
            buf.writeKeyValue("AUTH_KPPL_PURITY", "" + this.conn.purity);
          }
          if (this.privateKey) {
            const currentDate = /* @__PURE__ */ new Date();
            const currentDateFormatted = currentDate.toGMTString();
            const header = "date: " + currentDateFormatted + "\n(request-target): " + this.serviceName + "\nhost: " + this.remoteAddress;
            const signature = crypto.createSign("RSA-SHA256").update(header).sign(this.privateKey, "base64");
            buf.writeKeyValue("AUTH_HEADER", header);
            buf.writeKeyValue("AUTH_SIGNATURE", signature);
          }
          if (this.conn.jdwpData) {
            buf.writeKeyValue("AUTH_ORA_DEBUG_JDWP", this.encryptedJDWPData);
          }
          if (this.edition) {
            buf.writeKeyValue("AUTH_ORA_EDITION", this.edition);
          }
          if (this.appContext) {
            for (const entry of this.appContext) {
              buf.writeKeyValue("AUTH_APPCTX_NSPACE\0", entry[0]);
              buf.writeKeyValue("AUTH_APPCTX_ATTR\0", entry[1]);
              buf.writeKeyValue("AUTH_APPCTX_VALUE\0", entry[2]);
            }
          }
        }
      }
      processReturnParameter(buf) {
        const numParams = buf.readUB2();
        for (let i = 0; i < numParams; i++) {
          buf.skipUB4();
          const key = buf.readStr(constants.CSFRM_IMPLICIT);
          let value = "";
          const numBytes = buf.readUB4();
          if (numBytes > 0) {
            value = buf.readStr(constants.CSFRM_IMPLICIT);
          }
          const flag = buf.readUB4();
          if (key === "AUTH_VFR_DATA") {
            this.verifierType = flag;
          }
          this.sessionData[key] = value;
        }
        if (this.functionCode === constants.TNS_FUNC_AUTH_PHASE_ONE) {
          this.functionCode = constants.TNS_FUNC_AUTH_PHASE_TWO;
        } else if (!this.changePassword && this.comboKey) {
          const value = this.sessionData.AUTH_SVR_RESPONSE;
          let response;
          if (value) {
            const encodedResponse = Buffer2.from(value, "hex");
            response = ED.decrypt(this.comboKey, encodedResponse);
          }
          if (!response || !response.subarray(16, 32).equals(Buffer2.from("SERVER_TO_CLIENT"))) {
            errors.throwErr(errors.ERR_INVALID_SERVER_RESPONSE);
          }
        }
      }
    };
    module2.exports = AuthMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/commit.js
var require_commit = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/commit.js"(exports2, module2) {
    "use strict";
    var Message = require_base2();
    var constants = require_constants3();
    var CommitMessage = class extends Message {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_COMMIT;
      }
      //-------------------------------------------------------------------------
      // encode()
      //
      // Write the RPC to perform commit operation in the database
      //-------------------------------------------------------------------------
      encode(pkt) {
        this.writeFunctionHeader(pkt);
      }
    };
    module2.exports = CommitMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/dataType.js
var require_dataType = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/dataType.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var Message = require_base2();
    var DataTypeMessage = class extends Message {
      processMessage(buf, messageType) {
        if (messageType === constants.TNS_MSG_TYPE_DATA_TYPES) {
          while (true) {
            const dataType = buf.readUInt16BE();
            if (dataType === 0)
              break;
            const convDataType = buf.readUInt16BE();
            if (convDataType !== 0)
              buf.skipBytes(4);
          }
          this.endOfResponse = !this.connection.nscon.endOfRequestSupport;
        } else {
          super.processMessage(buf, messageType);
        }
      }
      encode(buf) {
        buf.writeUInt8(constants.TNS_MSG_TYPE_DATA_TYPES);
        buf.writeUInt16LE(constants.TNS_CHARSET_UTF8);
        buf.writeUInt16LE(constants.TNS_CHARSET_UTF8);
        buf.writeUInt8(constants.TNS_ENCODING_MULTI_BYTE | constants.TNS_ENCODING_CONV_LENGTH);
        buf.writeBytesWithLength(buf.caps.compileCaps);
        buf.writeBytesWithLength(buf.caps.runtimeCaps);
        for (const val of dataTypes) {
          buf.writeUInt16BE(val[0]);
          buf.writeUInt16BE(val[1]);
          buf.writeUInt16BE(val[2]);
          buf.writeUInt16BE(0);
        }
        buf.writeUInt16BE(0);
      }
    };
    var dataTypes = [
      [constants.TNS_DATA_TYPE_VARCHAR, constants.TNS_DATA_TYPE_VARCHAR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_NUMBER, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_LONG, constants.TNS_DATA_TYPE_LONG, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DATE, constants.TNS_DATA_TYPE_DATE, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_RAW, constants.TNS_DATA_TYPE_RAW, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_LONG_RAW, constants.TNS_DATA_TYPE_LONG_RAW, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UB2, constants.TNS_DATA_TYPE_UB2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UB4, constants.TNS_DATA_TYPE_UB4, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SB1, constants.TNS_DATA_TYPE_SB1, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_SB2, constants.TNS_DATA_TYPE_SB2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SB4, constants.TNS_DATA_TYPE_SB4, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SWORD, constants.TNS_DATA_TYPE_SWORD, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UWORD, constants.TNS_DATA_TYPE_UWORD, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PTRB, constants.TNS_DATA_TYPE_PTRB, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PTRW, constants.TNS_DATA_TYPE_PTRW, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TIDDEF, constants.TNS_DATA_TYPE_TIDDEF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ROWID, constants.TNS_DATA_TYPE_ROWID, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AMS, constants.TNS_DATA_TYPE_AMS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_BRN, constants.TNS_DATA_TYPE_BRN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CWD, constants.TNS_DATA_TYPE_CWD, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OAC122, constants.TNS_DATA_TYPE_OAC122, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OER8, constants.TNS_DATA_TYPE_OER8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_FUN, constants.TNS_DATA_TYPE_FUN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AUA, constants.TNS_DATA_TYPE_AUA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RXH7, constants.TNS_DATA_TYPE_RXH7, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_NA6, constants.TNS_DATA_TYPE_NA6, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_BRP, constants.TNS_DATA_TYPE_BRP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_BRV, constants.TNS_DATA_TYPE_BRV, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KVA, constants.TNS_DATA_TYPE_KVA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CLS, constants.TNS_DATA_TYPE_CLS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CUI, constants.TNS_DATA_TYPE_CUI, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DFN, constants.TNS_DATA_TYPE_DFN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DQR, constants.TNS_DATA_TYPE_DQR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSC, constants.TNS_DATA_TYPE_DSC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_EXE, constants.TNS_DATA_TYPE_EXE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_FCH, constants.TNS_DATA_TYPE_FCH, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_GBV, constants.TNS_DATA_TYPE_GBV, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_GEM, constants.TNS_DATA_TYPE_GEM, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_GIV, constants.TNS_DATA_TYPE_GIV, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OKG, constants.TNS_DATA_TYPE_OKG, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_HMI, constants.TNS_DATA_TYPE_HMI, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_INO, constants.TNS_DATA_TYPE_INO, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_LNF, constants.TNS_DATA_TYPE_LNF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ONT, constants.TNS_DATA_TYPE_ONT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OPE, constants.TNS_DATA_TYPE_OPE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OSQ, constants.TNS_DATA_TYPE_OSQ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SFE, constants.TNS_DATA_TYPE_SFE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SPF, constants.TNS_DATA_TYPE_SPF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_VSN, constants.TNS_DATA_TYPE_VSN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UD7, constants.TNS_DATA_TYPE_UD7, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSA, constants.TNS_DATA_TYPE_DSA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PIN, constants.TNS_DATA_TYPE_PIN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PFN, constants.TNS_DATA_TYPE_PFN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PPT, constants.TNS_DATA_TYPE_PPT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_STO, constants.TNS_DATA_TYPE_STO, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ARC, constants.TNS_DATA_TYPE_ARC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_MRS, constants.TNS_DATA_TYPE_MRS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_MRT, constants.TNS_DATA_TYPE_MRT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_MRG, constants.TNS_DATA_TYPE_MRG, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_MRR, constants.TNS_DATA_TYPE_MRR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_MRC, constants.TNS_DATA_TYPE_MRC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_VER, constants.TNS_DATA_TYPE_VER, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_LON2, constants.TNS_DATA_TYPE_LON2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_INO2, constants.TNS_DATA_TYPE_INO2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ALL, constants.TNS_DATA_TYPE_ALL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UDB, constants.TNS_DATA_TYPE_UDB, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQI, constants.TNS_DATA_TYPE_AQI, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ULB, constants.TNS_DATA_TYPE_ULB, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ULD, constants.TNS_DATA_TYPE_ULD, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SID, constants.TNS_DATA_TYPE_SID, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_NA7, constants.TNS_DATA_TYPE_NA7, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AL7, constants.TNS_DATA_TYPE_AL7, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_K2RPC, constants.TNS_DATA_TYPE_K2RPC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XDP, constants.TNS_DATA_TYPE_XDP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OKO8, constants.TNS_DATA_TYPE_OKO8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UD12, constants.TNS_DATA_TYPE_UD12, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AL8, constants.TNS_DATA_TYPE_AL8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_LFOP, constants.TNS_DATA_TYPE_LFOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_FCRT, constants.TNS_DATA_TYPE_FCRT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DNY, constants.TNS_DATA_TYPE_DNY, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OPR, constants.TNS_DATA_TYPE_OPR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PLS, constants.TNS_DATA_TYPE_PLS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XID, constants.TNS_DATA_TYPE_XID, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TXN, constants.TNS_DATA_TYPE_TXN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DCB, constants.TNS_DATA_TYPE_DCB, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CCA, constants.TNS_DATA_TYPE_CCA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_WRN, constants.TNS_DATA_TYPE_WRN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TLH, constants.TNS_DATA_TYPE_TLH, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TOH, constants.TNS_DATA_TYPE_TOH, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_FOI, constants.TNS_DATA_TYPE_FOI, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SID2, constants.TNS_DATA_TYPE_SID2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TCH, constants.TNS_DATA_TYPE_TCH, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PII, constants.TNS_DATA_TYPE_PII, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PFI, constants.TNS_DATA_TYPE_PFI, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PPU, constants.TNS_DATA_TYPE_PPU, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PTE, constants.TNS_DATA_TYPE_PTE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RXH8, constants.TNS_DATA_TYPE_RXH8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_N12, constants.TNS_DATA_TYPE_N12, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AUTH, constants.TNS_DATA_TYPE_AUTH, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KVAL, constants.TNS_DATA_TYPE_KVAL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_FGI, constants.TNS_DATA_TYPE_FGI, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSY, constants.TNS_DATA_TYPE_DSY, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYR8, constants.TNS_DATA_TYPE_DSYR8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYH8, constants.TNS_DATA_TYPE_DSYH8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYL, constants.TNS_DATA_TYPE_DSYL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYT8, constants.TNS_DATA_TYPE_DSYT8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYV8, constants.TNS_DATA_TYPE_DSYV8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYP, constants.TNS_DATA_TYPE_DSYP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYF, constants.TNS_DATA_TYPE_DSYF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYK, constants.TNS_DATA_TYPE_DSYK, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYY, constants.TNS_DATA_TYPE_DSYY, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYQ, constants.TNS_DATA_TYPE_DSYQ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYC, constants.TNS_DATA_TYPE_DSYC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYA, constants.TNS_DATA_TYPE_DSYA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OT8, constants.TNS_DATA_TYPE_OT8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYTY, constants.TNS_DATA_TYPE_DSYTY, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQE, constants.TNS_DATA_TYPE_AQE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KV, constants.TNS_DATA_TYPE_KV, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQD, constants.TNS_DATA_TYPE_AQD, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQ8, constants.TNS_DATA_TYPE_AQ8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RFS, constants.TNS_DATA_TYPE_RFS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RXH10, constants.TNS_DATA_TYPE_RXH10, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPN, constants.TNS_DATA_TYPE_KPN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDNR, constants.TNS_DATA_TYPE_KPDNR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYD, constants.TNS_DATA_TYPE_DSYD, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYS, constants.TNS_DATA_TYPE_DSYS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYR, constants.TNS_DATA_TYPE_DSYR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYH, constants.TNS_DATA_TYPE_DSYH, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYT, constants.TNS_DATA_TYPE_DSYT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DSYV, constants.TNS_DATA_TYPE_DSYV, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQM, constants.TNS_DATA_TYPE_AQM, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OER11, constants.TNS_DATA_TYPE_OER11, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQL, constants.TNS_DATA_TYPE_AQL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OTC, constants.TNS_DATA_TYPE_OTC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KFNO, constants.TNS_DATA_TYPE_KFNO, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KFNP, constants.TNS_DATA_TYPE_KFNP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KGT8, constants.TNS_DATA_TYPE_KGT8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RASB4, constants.TNS_DATA_TYPE_RASB4, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RAUB2, constants.TNS_DATA_TYPE_RAUB2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RAUB1, constants.TNS_DATA_TYPE_RAUB1, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RATXT, constants.TNS_DATA_TYPE_RATXT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RSSB4, constants.TNS_DATA_TYPE_RSSB4, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RSUB2, constants.TNS_DATA_TYPE_RSUB2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RSUB1, constants.TNS_DATA_TYPE_RSUB1, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RSTXT, constants.TNS_DATA_TYPE_RSTXT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RIDL, constants.TNS_DATA_TYPE_RIDL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_GLRDD, constants.TNS_DATA_TYPE_GLRDD, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_GLRDG, constants.TNS_DATA_TYPE_GLRDG, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_GLRDC, constants.TNS_DATA_TYPE_GLRDC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OKO, constants.TNS_DATA_TYPE_OKO, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DPP, constants.TNS_DATA_TYPE_DPP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DPLS, constants.TNS_DATA_TYPE_DPLS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DPMOP, constants.TNS_DATA_TYPE_DPMOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_STAT, constants.TNS_DATA_TYPE_STAT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RFX, constants.TNS_DATA_TYPE_RFX, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_FAL, constants.TNS_DATA_TYPE_FAL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CKV, constants.TNS_DATA_TYPE_CKV, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DRCX, constants.TNS_DATA_TYPE_DRCX, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KGH, constants.TNS_DATA_TYPE_KGH, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQO, constants.TNS_DATA_TYPE_AQO, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OKGT, constants.TNS_DATA_TYPE_OKGT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPFC, constants.TNS_DATA_TYPE_KPFC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_FE2, constants.TNS_DATA_TYPE_FE2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SPFP, constants.TNS_DATA_TYPE_SPFP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DPULS, constants.TNS_DATA_TYPE_DPULS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQA, constants.TNS_DATA_TYPE_AQA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPBF, constants.TNS_DATA_TYPE_KPBF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TSM, constants.TNS_DATA_TYPE_TSM, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_MSS, constants.TNS_DATA_TYPE_MSS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPC, constants.TNS_DATA_TYPE_KPC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CRS, constants.TNS_DATA_TYPE_CRS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KKS, constants.TNS_DATA_TYPE_KKS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KSP, constants.TNS_DATA_TYPE_KSP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KSPTOP, constants.TNS_DATA_TYPE_KSPTOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KSPVAL, constants.TNS_DATA_TYPE_KSPVAL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PSS, constants.TNS_DATA_TYPE_PSS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_NLS, constants.TNS_DATA_TYPE_NLS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ALS, constants.TNS_DATA_TYPE_ALS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KSDEVTVAL, constants.TNS_DATA_TYPE_KSDEVTVAL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KSDEVTTOP, constants.TNS_DATA_TYPE_KSDEVTTOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPSPP, constants.TNS_DATA_TYPE_KPSPP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KOL, constants.TNS_DATA_TYPE_KOL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_LST, constants.TNS_DATA_TYPE_LST, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ACX, constants.TNS_DATA_TYPE_ACX, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SCS, constants.TNS_DATA_TYPE_SCS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RXH, constants.TNS_DATA_TYPE_RXH, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDNS, constants.TNS_DATA_TYPE_KPDNS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDCN, constants.TNS_DATA_TYPE_KPDCN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPNNS, constants.TNS_DATA_TYPE_KPNNS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPNCN, constants.TNS_DATA_TYPE_KPNCN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPS, constants.TNS_DATA_TYPE_KPS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_APINF, constants.TNS_DATA_TYPE_APINF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TEN, constants.TNS_DATA_TYPE_TEN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSSCS, constants.TNS_DATA_TYPE_XSSCS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSSSO, constants.TNS_DATA_TYPE_XSSSO, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSSAO, constants.TNS_DATA_TYPE_XSSAO, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KSRPC, constants.TNS_DATA_TYPE_KSRPC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KVL, constants.TNS_DATA_TYPE_KVL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSSDEF, constants.TNS_DATA_TYPE_XSSDEF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PDQCINV, constants.TNS_DATA_TYPE_PDQCINV, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PDQIDC, constants.TNS_DATA_TYPE_PDQIDC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDQCSTA, constants.TNS_DATA_TYPE_KPDQCSTA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPRS, constants.TNS_DATA_TYPE_KPRS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDQIDC, constants.TNS_DATA_TYPE_KPDQIDC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RTSTRM, constants.TNS_DATA_TYPE_RTSTRM, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SESSGET, constants.TNS_DATA_TYPE_SESSGET, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SESSREL, constants.TNS_DATA_TYPE_SESSREL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SESSRET, constants.TNS_DATA_TYPE_SESSRET, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SCN6, constants.TNS_DATA_TYPE_SCN6, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KECPA, constants.TNS_DATA_TYPE_KECPA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KECPP, constants.TNS_DATA_TYPE_KECPP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SXA, constants.TNS_DATA_TYPE_SXA, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KVARR, constants.TNS_DATA_TYPE_KVARR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPNGN, constants.TNS_DATA_TYPE_KPNGN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_BINARY_INTEGER, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_FLOAT, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_STR, constants.TNS_DATA_TYPE_VARCHAR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_VNU, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_PDN, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_VCS, constants.TNS_DATA_TYPE_VARCHAR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_VBI, constants.TNS_DATA_TYPE_VARCHAR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OAC9, constants.TNS_DATA_TYPE_OAC9, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UIN, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_SLS, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_LVC, constants.TNS_DATA_TYPE_VARCHAR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_LVB, constants.TNS_DATA_TYPE_RAW, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CHAR, constants.TNS_DATA_TYPE_CHAR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AVC, constants.TNS_DATA_TYPE_CHAR, constants.TNS_TYPE_REP_UNIVERSAL],
      [
        constants.TNS_DATA_TYPE_BINARY_FLOAT,
        constants.TNS_DATA_TYPE_BINARY_FLOAT,
        constants.TNS_TYPE_REP_UNIVERSAL
      ],
      [
        constants.TNS_DATA_TYPE_BINARY_DOUBLE,
        constants.TNS_DATA_TYPE_BINARY_DOUBLE,
        constants.TNS_TYPE_REP_UNIVERSAL
      ],
      [constants.TNS_DATA_TYPE_CURSOR, constants.TNS_DATA_TYPE_CURSOR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RDD, constants.TNS_DATA_TYPE_ROWID, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OSL, constants.TNS_DATA_TYPE_OSL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_EXT_NAMED, constants.TNS_DATA_TYPE_INT_NAMED, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_INT_NAMED, constants.TNS_DATA_TYPE_INT_NAMED, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_EXT_REF, constants.TNS_DATA_TYPE_INT_REF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_INT_REF, constants.TNS_DATA_TYPE_INT_REF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CLOB, constants.TNS_DATA_TYPE_CLOB, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_BLOB, constants.TNS_DATA_TYPE_BLOB, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_BFILE, constants.TNS_DATA_TYPE_BFILE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CFILE, constants.TNS_DATA_TYPE_CFILE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_RSET, constants.TNS_DATA_TYPE_CURSOR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_JSON, constants.TNS_DATA_TYPE_JSON, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DJSON, constants.TNS_DATA_TYPE_DJSON, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CLV, constants.TNS_DATA_TYPE_CLV, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DTR, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_DUN, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_DOP, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_VST, constants.TNS_DATA_TYPE_VARCHAR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ODT, constants.TNS_DATA_TYPE_DATE, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_DOL, constants.TNS_DATA_TYPE_NUMBER, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_TIME, constants.TNS_DATA_TYPE_TIME, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TIME_TZ, constants.TNS_DATA_TYPE_TIME_TZ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TIMESTAMP, constants.TNS_DATA_TYPE_TIMESTAMP, constants.TNS_TYPE_REP_UNIVERSAL],
      [
        constants.TNS_DATA_TYPE_TIMESTAMP_TZ,
        constants.TNS_DATA_TYPE_TIMESTAMP_TZ,
        constants.TNS_TYPE_REP_UNIVERSAL
      ],
      [
        constants.TNS_DATA_TYPE_INTERVAL_YM,
        constants.TNS_DATA_TYPE_INTERVAL_YM,
        constants.TNS_TYPE_REP_UNIVERSAL
      ],
      [
        constants.TNS_DATA_TYPE_INTERVAL_DS,
        constants.TNS_DATA_TYPE_INTERVAL_DS,
        constants.TNS_TYPE_REP_UNIVERSAL
      ],
      [constants.TNS_DATA_TYPE_EDATE, constants.TNS_DATA_TYPE_DATE, constants.TNS_TYPE_REP_ORACLE],
      [constants.TNS_DATA_TYPE_ETIME, constants.TNS_DATA_TYPE_ETIME, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ETTZ, constants.TNS_DATA_TYPE_ETTZ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ESTAMP, constants.TNS_DATA_TYPE_ESTAMP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_ESTZ, constants.TNS_DATA_TYPE_ESTZ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_EIYM, constants.TNS_DATA_TYPE_EIYM, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_EIDS, constants.TNS_DATA_TYPE_EIDS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DCLOB, constants.TNS_DATA_TYPE_CLOB, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DBLOB, constants.TNS_DATA_TYPE_BLOB, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_DBFILE, constants.TNS_DATA_TYPE_BFILE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UROWID, constants.TNS_DATA_TYPE_UROWID, constants.TNS_TYPE_REP_UNIVERSAL],
      [
        constants.TNS_DATA_TYPE_TIMESTAMP_LTZ,
        constants.TNS_DATA_TYPE_TIMESTAMP_LTZ,
        constants.TNS_TYPE_REP_UNIVERSAL
      ],
      [constants.TNS_DATA_TYPE_ESITZ, constants.TNS_DATA_TYPE_TIMESTAMP_LTZ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UB8, constants.TNS_DATA_TYPE_UB8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_PNTY, constants.TNS_DATA_TYPE_INT_NAMED, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_BOOLEAN, constants.TNS_DATA_TYPE_BOOLEAN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSNSOP, constants.TNS_DATA_TYPE_XSNSOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSATTR, constants.TNS_DATA_TYPE_XSATTR, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSNS, constants.TNS_DATA_TYPE_XSNS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UB1ARRAY, constants.TNS_DATA_TYPE_UB1ARRAY, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SESSSTATE, constants.TNS_DATA_TYPE_SESSSTATE, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AC_REPLAY, constants.TNS_DATA_TYPE_AC_REPLAY, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AC_CONT, constants.TNS_DATA_TYPE_AC_CONT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_IMPLRES, constants.TNS_DATA_TYPE_IMPLRES, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OER19, constants.TNS_DATA_TYPE_OER19, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TXT, constants.TNS_DATA_TYPE_TXT, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSSESSNS, constants.TNS_DATA_TYPE_XSSESSNS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSATTOP, constants.TNS_DATA_TYPE_XSATTOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSCREOP, constants.TNS_DATA_TYPE_XSCREOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSDETOP, constants.TNS_DATA_TYPE_XSDETOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSDESOP, constants.TNS_DATA_TYPE_XSDESOP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSSETSP, constants.TNS_DATA_TYPE_XSSETSP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSSIDP, constants.TNS_DATA_TYPE_XSSIDP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSPRIN, constants.TNS_DATA_TYPE_XSPRIN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSKVL, constants.TNS_DATA_TYPE_XSKVL, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSSSDEF2, constants.TNS_DATA_TYPE_XSSSDEF2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSNSOP2, constants.TNS_DATA_TYPE_XSNSOP2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_XSNS2, constants.TNS_DATA_TYPE_XSNS2, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDNREQ, constants.TNS_DATA_TYPE_KPDNREQ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDNRNF, constants.TNS_DATA_TYPE_KPDNRNF, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPNGNC, constants.TNS_DATA_TYPE_KPNGNC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPNRI, constants.TNS_DATA_TYPE_KPNRI, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQENQ, constants.TNS_DATA_TYPE_AQENQ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQDEQ, constants.TNS_DATA_TYPE_AQDEQ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_AQJMS, constants.TNS_DATA_TYPE_AQJMS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDNRPAY, constants.TNS_DATA_TYPE_KPDNRPAY, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDNRACK, constants.TNS_DATA_TYPE_KPDNRACK, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDNRMP, constants.TNS_DATA_TYPE_KPDNRMP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_KPDNRDQ, constants.TNS_DATA_TYPE_KPDNRDQ, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SCN, constants.TNS_DATA_TYPE_SCN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SCN8, constants.TNS_DATA_TYPE_SCN8, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_CHUNKINFO, constants.TNS_DATA_TYPE_CHUNKINFO, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UD21, constants.TNS_DATA_TYPE_UD21, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_UDS, constants.TNS_DATA_TYPE_UDS, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_TNP, constants.TNS_DATA_TYPE_TNP, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OER, constants.TNS_DATA_TYPE_OER, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_OAC, constants.TNS_DATA_TYPE_OAC, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_SESSSIGN, constants.TNS_DATA_TYPE_SESSSIGN, constants.TNS_TYPE_REP_UNIVERSAL],
      [constants.TNS_DATA_TYPE_VECTOR, constants.TNS_DATA_TYPE_VECTOR, constants.TNS_TYPE_REP_UNIVERSAL]
    ];
    module2.exports = DataTypeMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/logOff.js
var require_logOff = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/logOff.js"(exports2, module2) {
    "use strict";
    var Message = require_base2();
    var constants = require_constants3();
    var LogOffMessage = class extends Message {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_LOGOFF;
      }
      encode(buf) {
        this.writeFunctionHeader(buf);
      }
    };
    module2.exports = LogOffMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/ping.js
var require_ping = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/ping.js"(exports2, module2) {
    "use strict";
    var Message = require_base2();
    var constants = require_constants3();
    var PingMessage = class extends Message {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_PING;
      }
      //-------------------------------------------------------------------------
      // encode()
      //
      // Write the RPC to Ping the database
      //-------------------------------------------------------------------------
      encode(buf) {
        this.writeFunctionHeader(buf);
      }
    };
    module2.exports = PingMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/protocol.js
var require_protocol2 = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/protocol.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var Message = require_base2();
    var ProtocolMessage = class extends Message {
      /**
       * Serializes the ProtocolMessage function arguments
       *
       * @param {object} buf input arguments
       */
      encode(buf) {
        buf.writeUInt8(constants.TNS_MSG_TYPE_PROTOCOL);
        buf.writeUInt8(6);
        buf.writeUInt8(0);
        buf.writeStr("node-oracledb");
        buf.writeUInt8(0);
      }
      processMessage(buf, messageType) {
        if (messageType === constants.TNS_MSG_TYPE_PROTOCOL) {
          this.processProtocolInfo(buf);
          this.endOfResponse = !this.connection.nscon.endOfRequestSupport;
        } else {
          super.processMessage(buf, messageType);
        }
      }
      processProtocolInfo(buf) {
        this.serverVersion = buf.readUInt8();
        buf.skipUB1();
        this.serverBanner = buf.readNullTerminatedBytes(48);
        buf.caps.charSetID = buf.readUInt16LE();
        this.serverFlags = buf.readUInt8();
        const num_elem = buf.readUInt16LE();
        if (num_elem > 0) {
          buf.skipBytes(num_elem * 5);
        }
        const fdoLen = buf.readUInt16BE();
        const fdo = buf.readBytes(fdoLen);
        const ix = 6 + fdo[5] + fdo[6];
        buf.caps.nCharsetId = (fdo[ix + 3] << 8) + fdo[ix + 4];
        const serverCompileCaps = buf.readBytesWithLength();
        if (serverCompileCaps) {
          this.serverCompileCaps = Buffer.from(serverCompileCaps);
          buf.caps.adjustForServerCompileCaps(this.serverCompileCaps, this.connection.nscon);
          if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_23_1) {
            this.connection._osonMaxFieldNameSize = 65535;
          } else {
            this.connection._osonMaxFieldNameSize = 255;
          }
        }
        const serverRunTimeCaps = buf.readBytesWithLength();
        if (serverRunTimeCaps) {
          this.serverRunTimeCaps = Buffer.from(serverRunTimeCaps);
          buf.caps.adjustForServerRuntimeCaps(this.serverRunTimeCaps);
        }
      }
    };
    module2.exports = ProtocolMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/rollback.js
var require_rollback = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/rollback.js"(exports2, module2) {
    "use strict";
    var Message = require_base2();
    var constants = require_constants3();
    var RollbackMessage = class extends Message {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_ROLLBACK;
      }
      //-------------------------------------------------------------------------
      // encode()
      //
      // Write the RPC to perform Rollback operation in the database
      //-------------------------------------------------------------------------
      encode(buf) {
        this.writeFunctionHeader(buf);
      }
    };
    module2.exports = RollbackMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/sessionRelease.js
var require_sessionRelease = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/sessionRelease.js"(exports2, module2) {
    "use strict";
    var Message = require_base2();
    var constants = require_constants3();
    var SessionReleaseMessage = class extends Message {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_SESSION_RELEASE;
        this.messageType = constants.TNS_MSG_TYPE_ONEWAY_FN;
        this.sessReleaseMode = 0;
      }
      encode(buf) {
        this.writeFunctionHeader(buf);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUB4(this.sessReleaseMode);
      }
      decode() {
      }
    };
    module2.exports = SessionReleaseMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/fastAuth.js
var require_fastAuth = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/fastAuth.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var Message = require_base2();
    var FastAuthMessage = class extends Message {
      /**
       * Serializes the FastAuthMessage function arguments
       *
       * @param {object} buf input arguments
       */
      encode(buf) {
        buf.writeUInt8(constants.TNS_MSG_TYPE_FAST_AUTH);
        buf.writeUInt8(1);
        buf.writeUInt8(constants.TNS_SERVER_CONVERTS_CHARS);
        buf.writeUInt8(0);
        this.protocolMessage.encode(buf);
        buf.writeUInt16BE(0);
        buf.writeUInt8(0);
        buf.writeUInt16BE(0);
        buf.caps.ttcFieldVersion = constants.TNS_CCAP_FIELD_VERSION_19_1_EXT_1;
        buf.writeUInt8(buf.caps.ttcFieldVersion);
        this.dataTypeMessage.encode(buf);
        this.authMessage.encode(buf);
        buf.caps.ttcFieldVersion = constants.TNS_CCAP_FIELD_VERSION_MAX;
      }
      processMessage(buf, messageType) {
        if (messageType === constants.TNS_MSG_TYPE_RENEGOTIATE) {
          this.reNegotiate = true;
        } else if (messageType === constants.TNS_MSG_TYPE_PROTOCOL) {
          this.protocolMessage.processMessage(buf, messageType);
        } else if (messageType === constants.TNS_MSG_TYPE_DATA_TYPES) {
          this.dataTypeMessage.processMessage(buf, messageType);
        } else {
          this.authMessage.processMessage(buf, messageType);
          this.endOfResponse = this.authMessage.endOfResponse;
          if (this.authMessage.errorOccurred) {
            this.errorOccurred = this.authMessage.errorOccurred;
            this.errorInfo = this.authMessage.errorInfo;
          }
        }
      }
    };
    module2.exports = FastAuthMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/transactionChangeState.js
var require_transactionChangeState = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/transactionChangeState.js"(exports2, module2) {
    "use strict";
    var Message = require_base2();
    var constants = require_constants3();
    var TransactionChangeStateMessage = class extends Message {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_TPC_TXN_CHANGE_STATE;
      }
      processReturnParameter(buf) {
        this.state = buf.readUB4();
      }
      encode(buf) {
        let xidBytes;
        if (this.xid) {
          xidBytes = Buffer.alloc(128);
          this.xid.globalTransactionId.copy(xidBytes);
          this.xid.branchQualifier.copy(
            xidBytes,
            this.xid.globalTransactionId.length
          );
        }
        this.writeFunctionHeader(buf);
        buf.writeUB4(this.operation);
        if (this.context) {
          buf.writeUInt8(1);
          buf.writeUB4(this.context.length);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        if (this.xid) {
          buf.writeUB4(this.xid.formatId);
          buf.writeUB4(this.xid.globalTransactionId.length);
          buf.writeUB4(this.xid.branchQualifier.length);
          buf.writeUInt8(1);
          buf.writeUB4(xidBytes.length);
        } else {
          buf.writeUB4(0);
          buf.writeUB4(0);
          buf.writeUB4(0);
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        buf.writeUB4(0);
        buf.writeUB4(this.state);
        buf.writeUInt8(1);
        buf.writeUB4(this.flags);
        if (this.context) {
          buf.writeBytes(this.context);
        }
        if (this.xid) {
          buf.writeBytes(xidBytes);
        }
      }
    };
    module2.exports = TransactionChangeStateMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/index.js
var require_messages = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/index.js"(exports2, module2) {
    "use strict";
    var AuthMessage = require_auth();
    var CommitMessage = require_commit();
    var DataTypeMessage = require_dataType();
    var ExecuteMessage = require_execute();
    var FetchMessage = require_fetch();
    var LobOpMessage = require_lobOp();
    var LogOffMessage = require_logOff();
    var PingMessage = require_ping();
    var ProtocolMessage = require_protocol2();
    var RollbackMessage = require_rollback();
    var SessionReleaseMessage = require_sessionRelease();
    var FastAuthMessage = require_fastAuth();
    var TransactionChangeStateMessage = require_transactionChangeState();
    var TransactionSwitchMessage = require_transactionSwitch();
    module2.exports = {
      AuthMessage,
      CommitMessage,
      FastAuthMessage,
      DataTypeMessage,
      ExecuteMessage,
      FetchMessage,
      LobOpMessage,
      LogOffMessage,
      PingMessage,
      ProtocolMessage,
      RollbackMessage,
      SessionReleaseMessage,
      TransactionChangeStateMessage,
      TransactionSwitchMessage
    };
  }
});

// node_modules/oracledb/lib/thin/statementCache.js
var require_statementCache = __commonJS({
  "node_modules/oracledb/lib/thin/statementCache.js"(exports2, module2) {
    "use strict";
    var errors = require_errors();
    var { Statement } = require_statement();
    var StatementCache = class {
      constructor(maxSize) {
        this._cachedStatements = /* @__PURE__ */ new Map();
        this._maxSize = maxSize;
        this._cursorsToClose = /* @__PURE__ */ new Set();
        this._openCursors = /* @__PURE__ */ new Set();
      }
      //---------------------------------------------------------------------------
      // _addCursorToClose()
      //
      // Add the statement's cursor to the list of cursors that need to be closed.
      //---------------------------------------------------------------------------
      _addCursorToClose(statement) {
        if (this._cursorsToClose.has(statement.cursorId)) {
          const reason = `attempt to close cursor ${statement.cursorId} twice`;
          errors.throwErr(errors.ERR_INTERNAL, reason);
        }
        if (statement.cursorId != 0) {
          this._cursorsToClose.add(statement.cursorId);
        }
        this._openCursors.delete(statement);
      }
      //---------------------------------------------------------------------------
      // _adjustCache()
      // Adjust the cache so that no more than the maximum number of statements
      // are cached by removing least recently used statements
      //---------------------------------------------------------------------------
      _adjustCache() {
        while (this._cachedStatements.size > this._maxSize) {
          const sql = this._cachedStatements.keys().next().value;
          const stmt = this._cachedStatements.get(sql);
          this._cachedStatements.delete(sql);
          if (stmt.inUse) {
            stmt.returnToCache = false;
          } else if (stmt.cursorId !== 0) {
            this._addCursorToClose(stmt);
          }
        }
      }
      //---------------------------------------------------------------------------
      //clearCursors() {
      // Clears the list of open cursors and removes the list of cursors that
      // need to be closed. This is required when a DRCP session change has
      // taken place as the cursor ID values are invalidated.
      //---------------------------------------------------------------------------
      clearCursors() {
        const newOpenCursors = /* @__PURE__ */ new Set();
        for (const stmt of this._openCursors) {
          if (stmt.inUse || stmt.returnToCache) {
            stmt.pendingClear = true;
            newOpenCursors.add(stmt);
          }
          stmt._clearState();
        }
        this._openCursors = newOpenCursors;
        this._cursorsToClose.clear();
      }
      //---------------------------------------------------------------------------
      //clearPendingState() {
      // Clears state for statment with pending clear flag set and not in use.
      // This will clear all state for open cursors.
      // Called after rows processing is completed.
      //---------------------------------------------------------------------------
      clearPendingStatus() {
        for (const stmt of this._openCursors) {
          if (stmt.pendingClear && !stmt.inUse) {
            stmt._clearAllState();
            stmt.pendingClear = false;
          }
        }
      }
      //---------------------------------------------------------------------------
      // get_statement()
      // Get a statement from the statement cache, or prepare a new statement
      // for use. If a statement is already in use or the statement is not
      // supposed to be cached, a copy will be made (and not returned to the
      // cache).
      //---------------------------------------------------------------------------
      getStatement(sql, cacheStatement = false, forceNew = false) {
        let stmt = null;
        if (sql) {
          stmt = this._cachedStatements.get(sql);
        }
        if (!stmt) {
          stmt = new Statement();
          if (sql) {
            stmt._prepare(sql);
          }
          if (cacheStatement && !stmt.isDdl && this._maxSize > 0) {
            stmt.returnToCache = true;
            this._cachedStatements.set(sql, stmt);
            this._adjustCache();
          }
          this._openCursors.add(stmt);
        } else if (forceNew || stmt.inUse) {
          if (!cacheStatement) {
            this._addCursorToClose(stmt);
            this._cachedStatements.delete(sql);
          }
          stmt = stmt._copy();
          this._openCursors.add(stmt);
        } else if (!cacheStatement) {
          this._cachedStatements.delete(sql);
          stmt.returnToCache = false;
        } else {
          this._cachedStatements.delete(sql);
          this._cachedStatements.set(sql, stmt);
        }
        this._openCursors.add(stmt);
        stmt.inUse = true;
        return stmt;
      }
      clearCursor(statement) {
        this._addCursorToClose(statement);
        statement.cursorId = 0;
      }
      //---------------------------------------------------------------------------
      // returnStatement()
      // Return the statement to the statement cache, if applicable. If the
      // statement must not be returned to the statement cache, add the cursor
      // id to the list of cursor ids to close on the next round trip to the
      // database. Clear all bind variables and fetch variables in order to
      // ensure that unnecessary references are not retained.
      //---------------------------------------------------------------------------
      returnStatement(statement) {
        if (statement.bindInfoList) {
          statement.bindInfoList.forEach((bindInfo) => {
            bindInfo.bindVar = null;
          });
        }
        if (statement.queryVars) {
          statement.queryVars.forEach((queryVar) => {
            queryVar.values.fill(null);
          });
        }
        if (statement.returnToCache) {
          statement.inUse = false;
        } else {
          this._addCursorToClose(statement);
        }
        this.clearPendingStatus();
      }
      //---------------------------------------------------------------------------
      // writeCursorsToClose()
      // Write the list of cursors to close to the buffer.
      //---------------------------------------------------------------------------
      writeCursorsToClose(buf) {
        buf.writeUB4(this._cursorsToClose.size);
        for (const cursorNum of this._cursorsToClose.keys()) {
          buf.writeUB4(cursorNum);
        }
        this._cursorsToClose.clear();
      }
    };
    module2.exports = StatementCache;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/aqBase.js
var require_aqBase = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/aqBase.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var errors = require_errors();
    var BaseMessage = require_base2();
    var { ThinDbObjectImpl } = require_dbObject3();
    var oson = require_oson();
    var AqBaseMessage = class extends BaseMessage {
      constructor(connImpl) {
        super(connImpl);
        this.queueImpl = null;
        this.deqOptionsImpl = null;
        this.enqOptionsImpl = null;
        this.noMsgFound = false;
      }
      //--------------------------------------------------------------------------
      // _processDate()
      //
      // Processes a date found in the buffer.
      //--------------------------------------------------------------------------
      _processDate(buf) {
        const numBytes = buf.readUB4();
        if (numBytes > 0)
          return buf.readOracleDate(true);
      }
      //--------------------------------------------------------------------------
      // _processErrorInfo()
      //
      // Process error information from the buffer. If the error that indicates
      // that no messages were received is detected, the error is cleared and
      // the flag set so that the dequeue can handle that case.
      //--------------------------------------------------------------------------
      processErrorInfo(buf) {
        super.processErrorInfo(buf);
        if (this.errorInfo.num === constants.TNS_ERR_NO_MESSAGES_FOUND) {
          this.errorInfo.num = 0;
          this.errorOccurred = false;
          this.noMsgFound = true;
        }
      }
      //--------------------------------------------------------------------------
      // _processExtensions()
      //
      // Processes extensions to the message property object returned by the
      // database.
      //--------------------------------------------------------------------------
      _processExtensions(buf, propsImpl) {
        const numExtensions = buf.readUB4();
        if (numExtensions > 0) {
          buf.skipUB1();
          for (let i = 0; i < numExtensions; i++) {
            const textValue = buf.readBytesAndLength();
            const binaryValue = buf.readBytesAndLength();
            const value = textValue || binaryValue;
            const keyword = buf.readUB2();
            if (value) {
              if (keyword === constants.TNS_AQ_EXT_KEYWORD_AGENT_NAME) {
                propsImpl.senderAgentName = value;
              } else if (keyword === constants.TNS_AQ_EXT_KEYWORD_AGENT_ADDRESS) {
                propsImpl.senderAgentAddress = value;
              } else if (keyword === constants.TNS_AQ_EXT_KEYWORD_AGENT_PROTOCOL) {
                propsImpl.senderAgentProtocol = value[0];
              } else if (keyword === constants.TNS_AQ_EXT_KEYWORD_ORIGINAL_MSGID) {
                propsImpl.originalMsgId = value;
              }
            }
          }
        }
      }
      //--------------------------------------------------------------------------
      // _processMsgId()
      //
      // Reads a message id from the buffer and returns it.
      //--------------------------------------------------------------------------
      _processMsgId(buf) {
        return Buffer.from(buf.readBytes(constants.TNS_AQ_MESSAGE_ID_LENGTH));
      }
      //--------------------------------------------------------------------------
      // _processMsgProps()
      //
      // Processes a message property object returned by the database.
      //--------------------------------------------------------------------------
      _processMsgProps(buf, propsImpl) {
        propsImpl.priority = buf.readSB4();
        propsImpl.delay = buf.readSB4();
        propsImpl.expiration = buf.readSB4();
        propsImpl.correlation = buf.readStrAndLength();
        propsImpl.numAttempts = buf.readSB4();
        propsImpl.exceptionQueue = buf.readStrAndLength();
        propsImpl.state = buf.readSB4();
        propsImpl.enqTime = this._processDate(buf);
        propsImpl.enqTxnId = buf.readBytesAndLength();
        this._processExtensions(buf, propsImpl);
        const temp32 = buf.readUB4();
        if (temp32 > 0) {
          errors.throwErr(errors.ERR_NOT_IMPLEMENTED);
        }
        buf.skipUB4();
        buf.skipUB4();
        const flags = buf.readUB4();
        if (flags === constants.TNS_KPD_AQ_BUFMSG) {
          propsImpl.deliveryMode = constants.TNS_AQ_MSG_BUFFERED;
        } else {
          propsImpl.deliveryMode = constants.TNS_AQ_MSG_PERSISTENT;
        }
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_21_1) {
          buf.skipUB4();
        }
      }
      //--------------------------------------------------------------------------
      // _processPayload()
      //
      // Processes the payload for an enqueued message returned by the database.
      //--------------------------------------------------------------------------
      _processPayload(buf) {
        const payloadData = buf.readDbObject();
        if (this.queueImpl.payloadTypeClass) {
          const obj = new this.queueImpl.payloadTypeClass();
          const objImpl = new ThinDbObjectImpl(
            this.queueImpl.payloadTypeClass,
            payloadData.packedData
          );
          if (payloadData) {
            objImpl.toid = payloadData.toid;
            objImpl.oid = payloadData.oid;
          }
          obj._impl = objImpl;
          return obj;
        } else {
          if (payloadData.packedData) {
            const payload = Buffer.from(payloadData.packedData.slice(4));
            if (this.queueImpl.isJson) {
              const decoder = new oson.OsonDecoder(payload);
              return decoder.decode();
            }
            return payload;
          } else if (!this.queueImpl.isJson) {
            return Buffer.alloc(0);
          }
        }
      }
      //--------------------------------------------------------------------------
      // _processRecipients()
      //
      // Process recipients for a message.
      //--------------------------------------------------------------------------
      _processRecipients(buf) {
        const numRecipients = buf.readUB4();
        if (numRecipients > 0)
          errors.throwNotImplemented("aq recipients");
        return [];
      }
      //--------------------------------------------------------------------------
      // _writeMsgProps()
      //
      // Write a message property object to the buffer.
      //--------------------------------------------------------------------------
      _writeMsgProps(buf, propsImpl) {
        buf.writeSB4(propsImpl.priority);
        buf.writeSB4(propsImpl.delay);
        buf.writeSB4(propsImpl.expiration);
        this._writeValueWithLength(buf, propsImpl.correlation);
        buf.writeUB4(0);
        this._writeValueWithLength(buf, propsImpl.exceptionQueue);
        buf.writeUB4(propsImpl.state);
        buf.writeUB4(0);
        this._writeValueWithLength(buf, propsImpl.enqTxnId);
        buf.writeUB4(4);
        buf.writeUInt8(14);
        this._writeKeywordValuePair(
          buf,
          null,
          null,
          constants.TNS_AQ_EXT_KEYWORD_AGENT_NAME
        );
        this._writeKeywordValuePair(
          buf,
          null,
          null,
          constants.TNS_AQ_EXT_KEYWORD_AGENT_ADDRESS
        );
        this._writeKeywordValuePair(
          buf,
          null,
          Buffer.from([0]),
          constants.TNS_AQ_EXT_KEYWORD_AGENT_PROTOCOL
        );
        this._writeKeywordValuePair(
          buf,
          null,
          null,
          constants.TNS_AQ_EXT_KEYWORD_ORIGINAL_MSGID
        );
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_21_1) {
          buf.writeUB4(4294967295);
        }
      }
      //--------------------------------------------------------------------------
      // _writePayload()
      //
      // Writes the payload of the message property object to the buffer.
      //--------------------------------------------------------------------------
      _writePayload(buf, propsImpl) {
        if (this.queueImpl.isJson) {
          buf.writeOson(
            propsImpl.payload,
            this.connection._osonMaxFieldNameSize,
            false
          );
        } else if (this.queueImpl.payloadTypeClass) {
          buf.writeDbObject(propsImpl.payload);
        } else {
          buf.writeBytes(propsImpl.payload);
        }
      }
      //--------------------------------------------------------------------------
      // _writeRecipients()
      //
      // Write the recipient list of the message property object to the buffer.
      //--------------------------------------------------------------------------
      _writeRecipients(buf, propsImpl) {
        let index = 0;
        for (const recipient of propsImpl.recipients) {
          this._writeKeywordValuePair(buf, recipient, null, index);
          this._writeKeywordValuePair(buf, null, null, index + 1);
          this._writeKeywordValuePair(buf, null, Buffer.from([0]), index + 2);
          index += 3;
        }
      }
      //--------------------------------------------------------------------------
      // _writeValueWithLength()
      //
      // Write a string to the buffer, prefixed by a length.
      //--------------------------------------------------------------------------
      _writeValueWithLength(buf, value) {
        if (!value) {
          buf.writeUB4(0);
        } else {
          const valueBytes = Buffer.isBuffer(value) ? value : Buffer.from(value, "utf-8");
          buf.writeUB4(valueBytes.length);
          buf.writeBytesWithLength(valueBytes);
        }
      }
      //--------------------------------------------------------------------------
      // _writeKeywordValuePair()
      //
      // Writes a keyword value pair to the buffer.
      //--------------------------------------------------------------------------
      _writeKeywordValuePair(buf, textValue, binaryValue, keyword) {
        let textValueBytes;
        if (!textValue) {
          buf.writeUB4(0);
        } else {
          textValueBytes = Buffer.from(textValue);
          buf.writeUB4(textValueBytes.length);
          buf.writeBytesWithLength(textValueBytes);
        }
        if (!binaryValue) {
          buf.writeUB4(0);
        } else {
          buf.writeUB4(binaryValue.length);
          buf.writeBytesWithLength(binaryValue);
        }
        buf.writeUB2(keyword);
      }
    };
    module2.exports = AqBaseMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/aqEnq.js
var require_aqEnq = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/aqEnq.js"(exports2, module2) {
    "use strict";
    var AqBaseMessage = require_aqBase();
    var constants = require_constants3();
    var AqEnqMessage = class extends AqBaseMessage {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_AQ_ENQ;
        this.propsImpl = null;
      }
      //--------------------------------------------------------------------------
      // processReturnParameter()
      //
      // Process the return parameters for the AQ enqueue request.
      //--------------------------------------------------------------------------
      processReturnParameter(buf) {
        this.propsImpl.msgId = this._processMsgId(buf);
        buf.skipUB2();
      }
      //--------------------------------------------------------------------------
      // encode()
      //
      // Writes the body of the message to the buffer.
      //--------------------------------------------------------------------------
      encode(buf) {
        const queueNameBytes = Buffer.from(this.queueImpl.name, "utf-8");
        let enqFlags = 0;
        if (this.enqOptionsImpl.deliveryMode === constants.TNS_AQ_MSG_BUFFERED) {
          enqFlags |= constants.TNS_KPD_AQ_BUFMSG;
        }
        this.writeFunctionHeader(buf);
        buf.writeUInt8(1);
        buf.writeUB4(queueNameBytes.length);
        this._writeMsgProps(buf, this.propsImpl);
        if (!this.propsImpl.recipients) {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        } else {
          buf.writeUInt8(1);
          buf.writeUB4(3 * this.propsImpl.recipients.length);
        }
        buf.writeUB4(this.enqOptionsImpl.visibility);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUB4(0);
        buf.writeUInt8(1);
        buf.writeUB4(16);
        buf.writeUB2(constants.TNS_AQ_MESSAGE_VERSION);
        if (this.queueImpl.isJson) {
          buf.writeUInt8(0);
          buf.writeUInt8(0);
          buf.writeUB4(0);
        } else if (this.queueImpl.payloadTypeClass) {
          buf.writeUInt8(1);
          buf.writeUInt8(0);
          buf.writeUB4(0);
        } else {
          buf.writeUInt8(0);
          buf.writeUInt8(1);
          buf.writeUB4(this.propsImpl.payload.length);
        }
        buf.writeUInt8(1);
        buf.writeUB4(constants.TNS_AQ_MESSAGE_ID_LENGTH);
        buf.writeUB4(enqFlags);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUB4(0);
        buf.writeUInt8(0);
        buf.writeUInt8(0);
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_20_1) {
          buf.writeUInt8(this.queueImpl.isJson ? 1 : 0);
        }
        buf.writeBytesWithLength(queueNameBytes);
        if (this.propsImpl.recipients) {
          this._writeRecipients(buf, this.propsImpl);
        }
        buf.writeBytes(this.queueImpl.payloadToid);
        this._writePayload(buf, this.propsImpl);
      }
    };
    module2.exports = AqEnqMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/aqDeq.js
var require_aqDeq = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/aqDeq.js"(exports2, module2) {
    "use strict";
    var AqBaseMessage = require_aqBase();
    var constants = require_constants3();
    var AqDeqMessage = class extends AqBaseMessage {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_AQ_DEQ;
        this.propsImpl = null;
      }
      //--------------------------------------------------------------------------
      // processReturnParameter()
      //
      // Process the return parameters of the AQ Dequeue request.
      //--------------------------------------------------------------------------
      processReturnParameter(buf) {
        const numBytes = buf.readUB4();
        if (numBytes > 0) {
          this._processMsgProps(buf, this.propsImpl);
          this.propsImpl.recipients = this._processRecipients(buf);
          this.propsImpl.payload = this._processPayload(buf);
          this.propsImpl.msgId = this._processMsgId(buf);
        }
      }
      //--------------------------------------------------------------------------
      // _writeMessageBody()
      //
      // Writes the body of the message to the buffer.
      //--------------------------------------------------------------------------
      encode(buf) {
        const queueNameBytes = Buffer.from(this.queueImpl.name, "utf-8");
        const consumerNameBytes = this.deqOptionsImpl.consumerName ? Buffer.from(this.deqOptionsImpl.consumerName, "utf-8") : null;
        const correlationBytes = this.deqOptionsImpl.correlation ? Buffer.from(this.deqOptionsImpl.correlation, "utf-8") : null;
        const conditionBytes = this.deqOptionsImpl.condition ? Buffer.from(this.deqOptionsImpl.condition, "utf-8") : null;
        let msgIdBytes = this.deqOptionsImpl.msgId ? this.deqOptionsImpl.msgId.slice(0, 16) : null;
        const deliveryMode = this.deqOptionsImpl.deliveryMode;
        let deqFlags = 0;
        if (msgIdBytes && msgIdBytes.length < 16) {
          msgIdBytes = Buffer.concat([
            msgIdBytes,
            Buffer.alloc(16 - msgIdBytes.length)
          ]);
        }
        if (deliveryMode === constants.TNS_AQ_MSG_BUFFERED) {
          deqFlags |= constants.TNS_KPD_AQ_BUFMSG;
        } else if (deliveryMode === constants.TNS_AQ_MSG_PERSISTENT_OR_BUFFERED) {
          deqFlags |= constants.TNS_KPD_AQ_EITHER;
        }
        this.writeFunctionHeader(buf);
        buf.writeUInt8(1);
        buf.writeUB4(queueNameBytes.length);
        buf.writeUInt8(1);
        buf.writeUInt8(1);
        buf.writeUInt8(1);
        buf.writeUInt8(1);
        if (consumerNameBytes) {
          buf.writeUInt8(1);
          buf.writeUB4(consumerNameBytes.length);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        buf.writeSB4(this.deqOptionsImpl.mode);
        buf.writeSB4(this.deqOptionsImpl.navigation);
        buf.writeSB4(this.deqOptionsImpl.visibility);
        buf.writeSB4(this.deqOptionsImpl.wait);
        if (msgIdBytes) {
          buf.writeUInt8(1);
          buf.writeUB4(constants.TNS_AQ_MESSAGE_ID_LENGTH);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        if (correlationBytes) {
          buf.writeUInt8(1);
          buf.writeUB4(correlationBytes.length);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        buf.writeUInt8(1);
        buf.writeUB4(16);
        buf.writeUB2(constants.TNS_AQ_MESSAGE_VERSION);
        buf.writeUInt8(1);
        buf.writeUInt8(1);
        buf.writeUB4(constants.TNS_AQ_MESSAGE_ID_LENGTH);
        buf.writeUB4(deqFlags);
        if (conditionBytes) {
          buf.writeUInt8(1);
          buf.writeUB4(conditionBytes.length);
        } else {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        }
        buf.writeUInt8(0);
        buf.writeUB4(0);
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_20_1) {
          buf.writeUInt8(0);
        }
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_21_1) {
          buf.writeUB4(4294967295);
        }
        buf.writeBytesWithLength(queueNameBytes);
        if (consumerNameBytes) {
          buf.writeBytesWithLength(consumerNameBytes);
        }
        if (msgIdBytes) {
          buf.writeBytes(msgIdBytes);
        }
        if (correlationBytes) {
          buf.writeBytesWithLength(correlationBytes);
        }
        buf.writeBytes(this.queueImpl.payloadToid);
        if (conditionBytes) {
          buf.writeBytesWithLength(conditionBytes);
        }
      }
    };
    module2.exports = AqDeqMessage;
  }
});

// node_modules/oracledb/lib/thin/protocol/messages/aqArray.js
var require_aqArray = __commonJS({
  "node_modules/oracledb/lib/thin/protocol/messages/aqArray.js"(exports2, module2) {
    "use strict";
    var AqBaseMessage = require_aqBase();
    var constants = require_constants3();
    var errors = require_errors();
    var AqArrayMessage = class extends AqBaseMessage {
      constructor(connImpl) {
        super(connImpl);
        this.functionCode = constants.TNS_FUNC_ARRAY_AQ;
        this.numIters = 0;
        this.propsImpls = [];
        this.noMsgFound = false;
      }
      //--------------------------------------------------------------------------
      // processReturnParameter()
      //
      // Process the return parameters of the AQ array enqueue/dequeue request.
      // We recieve all the msg details in deq and in case of enq the msgIds.
      //--------------------------------------------------------------------------
      processReturnParameter(buf) {
        const numIters = buf.readUB4();
        for (let i = 0; i < numIters; i++) {
          const propsImpl = this.propsImpls[i];
          let temp16 = buf.readUB2();
          if (temp16 > 0) {
            buf.skipUB1();
            this._processMsgProps(buf, propsImpl);
          }
          propsImpl.recipients = this._processRecipients(buf);
          temp16 = buf.readUB2();
          if (temp16 > 0) {
            propsImpl.payload = this._processPayload(buf);
          }
          const msgId = buf.readBytesAndLength();
          if (this.operation === constants.TNS_AQ_ARRAY_ENQ) {
            for (let j = 0; j < this.propsImpls.length; j++) {
              this.propsImpls[j].msgId = Buffer.from(msgId.slice(j * 16, (j + 1) * 16));
            }
          } else {
            propsImpl.msgId = Buffer.from(msgId);
          }
          temp16 = buf.readUB2();
          if (temp16 > 0) {
            errors.throwErr(errors.ERR_NOT_IMPLEMENTED);
          }
          buf.skipUB2();
        }
        if (this.operation === constants.TNS_AQ_ARRAY_ENQ) {
          this.numIters = buf.readUB4();
        } else {
          this.numIters = numIters;
        }
      }
      //--------------------------------------------------------------------------
      // _writeArrayDeq()
      //
      // Writes to the buffer the fields specific to the array dequeue of AQ
      // messages.
      //--------------------------------------------------------------------------
      _writeArrayDeq(buf) {
        let consumerNameBytes = null;
        let correlationBytes = null;
        let conditionBytes = null;
        const queueNameBytes = Buffer.from(this.queueImpl.name);
        const deliveryMode = this.deqOptionsImpl.deliveryMode;
        let flags = 0;
        if (deliveryMode === constants.TNS_AQ_MSG_BUFFERED) {
          flags |= constants.TNS_KPD_AQ_BUFMSG;
        } else if (deliveryMode === constants.TNS_AQ_MSG_PERSISTENT_OR_BUFFERED) {
          flags |= constants.TNS_KPD_AQ_EITHER;
        }
        if (this.deqOptionsImpl.consumerName) {
          consumerNameBytes = Buffer.from(this.deqOptionsImpl.consumerName, "utf-8");
        }
        if (this.deqOptionsImpl.condition) {
          conditionBytes = Buffer.from(this.deqOptionsImpl.condition, "utf-8");
        }
        if (this.deqOptionsImpl.correlation) {
          correlationBytes = Buffer.from(this.deqOptionsImpl.correlation, "utf-8");
        }
        for (const propsImpl of this.propsImpls) {
          buf.writeUB4(queueNameBytes.length);
          buf.writeBytesWithLength(queueNameBytes);
          this._writeMsgProps(buf, propsImpl);
          buf.writeUB4(0);
          this._writeValueWithLength(buf, consumerNameBytes);
          buf.writeSB4(this.deqOptionsImpl.mode);
          buf.writeSB4(this.deqOptionsImpl.navigation);
          buf.writeSB4(this.deqOptionsImpl.visibility);
          buf.writeSB4(this.deqOptionsImpl.wait);
          this._writeValueWithLength(buf, this.deqOptionsImpl.msgid);
          this._writeValueWithLength(buf, correlationBytes);
          this._writeValueWithLength(buf, conditionBytes);
          buf.writeUB4(0);
          buf.writeUB4(0);
          buf.writeSB4(0);
          buf.writeUB4(16);
          buf.writeBytesWithLength(this.queueImpl.payloadToid);
          buf.writeUB2(constants.TNS_AQ_MESSAGE_VERSION);
          buf.writeUB4(0);
          buf.writeUB4(0);
          buf.writeUB4(0);
          buf.writeUB4(flags);
          buf.writeUB4(0);
          buf.writeUB4(0);
        }
      }
      //--------------------------------------------------------------------------
      // _writeArrayEnq()
      //
      // Writes input parameters in case of array enqueue.
      //--------------------------------------------------------------------------
      _writeArrayEnq(buf) {
        const queueNameBytes = Buffer.from(this.queueImpl.name);
        const deliveryMode = this.enqOptionsImpl.deliveryMode;
        let flags = 0;
        if (deliveryMode === constants.TNS_AQ_MSG_BUFFERED) {
          flags |= constants.TNS_KPD_AQ_BUFMSG;
        } else if (deliveryMode === constants.TNS_AQ_MSG_PERSISTENT_OR_BUFFERED) {
          flags |= constants.TNS_KPD_AQ_EITHER;
        }
        buf.writeUB4(0);
        buf.writeUInt8(constants.TNS_MSG_TYPE_ROW_HEADER);
        buf.writeUB4(queueNameBytes.length);
        buf.writeBytesWithLength(queueNameBytes);
        buf.writeBytes(this.queueImpl.payloadToid);
        buf.writeUB2(constants.TNS_AQ_MESSAGE_VERSION);
        buf.writeUB4(flags);
        for (const propsImpl of this.propsImpls) {
          buf.writeUInt8(constants.TNS_MSG_TYPE_ROW_DATA);
          buf.writeUB4(flags);
          this._writeMsgProps(buf, propsImpl);
          if (propsImpl.recipients === null || propsImpl.recipients.length === 0) {
            buf.writeUB4(0);
          } else {
            buf.writeUB4(3 * propsImpl.recipients.length);
            this._writeRecipients(buf, propsImpl);
          }
          buf.writeSB4(this.enqOptionsImpl.visibility);
          buf.writeUB4(0);
          buf.writeSB4(0);
          if (!this.queueImpl.payloadTypeClass && !this.queueImpl.isJson) {
            buf.writeUB4(propsImpl.payload.length);
          }
          this._writePayload(buf, propsImpl);
        }
        buf.writeUInt8(constants.TNS_MSG_TYPE_STATUS);
      }
      //--------------------------------------------------------------------------
      // _writeMessageBody()
      //
      // Writes the body of the message to the buffer.
      //--------------------------------------------------------------------------
      encode(buf) {
        this.writeFunctionHeader(buf);
        if (this.operation === constants.TNS_AQ_ARRAY_ENQ) {
          buf.writeUInt8(0);
          buf.writeUB4(0);
        } else {
          buf.writeUInt8(1);
          buf.writeUB4(this.numIters);
        }
        buf.writeUB4(constants.TNS_AQ_ARRAY_FLAGS_RETURN_MESSAGE_ID);
        if (this.operation === constants.TNS_AQ_ARRAY_ENQ) {
          buf.writeUInt8(1);
          buf.writeUInt8(0);
        } else {
          buf.writeUInt8(1);
          buf.writeUInt8(1);
        }
        buf.writeSB4(this.operation);
        if (this.operation === constants.TNS_AQ_ARRAY_ENQ) {
          buf.writeUInt8(1);
        } else {
          buf.writeUInt8(0);
        }
        if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_21_1) {
          buf.writeUB4(65535);
        }
        if (this.operation === constants.TNS_AQ_ARRAY_ENQ) {
          buf.writeUB4(this.numIters);
        }
        if (this.operation === constants.TNS_AQ_ARRAY_ENQ) {
          this._writeArrayEnq(buf);
        } else {
          this._writeArrayDeq(buf);
        }
      }
    };
    module2.exports = AqArrayMessage;
  }
});

// node_modules/oracledb/lib/thin/aq.js
var require_aq = __commonJS({
  "node_modules/oracledb/lib/thin/aq.js"(exports2, module2) {
    "use strict";
    var AqEnqMessage = require_aqEnq();
    var AqDeqMessage = require_aqDeq();
    var AqArrayMessage = require_aqArray();
    var constants = require_constants3();
    var errors = require_errors();
    var types = require_types();
    var { AQ_VISIBILITY_IMMEDIATE } = require_constants();
    var ThinQueueImpl = class {
      constructor(connImpl, name, payloadTypeClass, payloadType) {
        this._connImpl = connImpl;
        this.name = name;
        this.payloadTypeClass = payloadTypeClass;
        this.isJson = payloadType === types.DB_TYPE_JSON;
        this.payloadType = payloadType;
        this.deqOptions = new ThinDeqOptionsImpl();
        this.enqOptions = new ThinEnqOptionsImpl();
        if (this.isJson) {
          this.payloadToid = Buffer.alloc(16, 0);
          this.payloadToid[15] = 71;
        } else if (this.payloadTypeClass) {
          this.payloadToid = this.payloadTypeClass._objType.oid;
        } else {
          this.payloadToid = Buffer.alloc(16, 0);
          this.payloadToid[15] = 23;
        }
      }
      //---------------------------------------------------------------------------
      // _createArrayDeqMessage()
      //
      // Creates an array dequeue message for dequeuing multiple messages.
      //---------------------------------------------------------------------------
      _createArrayDeqMessage(numIters) {
        const message = new AqArrayMessage(this._connImpl);
        message.numIters = numIters;
        message.propsImpls = Array.from(
          { length: numIters },
          () => new ThinMsgPropsImpl()
        );
        message.queueImpl = this;
        message.deqOptionsImpl = this.deqOptions;
        message.operation = constants.TNS_AQ_ARRAY_DEQ;
        return message;
      }
      //---------------------------------------------------------------------------
      // _createArrayEnqMessage()
      //
      // Creates an array enqueue message for enqueuing multiple messages.
      //---------------------------------------------------------------------------
      _createArrayEnqMessage(propsImpls) {
        const message = new AqArrayMessage(this._connImpl);
        message.queueImpl = this;
        message.enqOptionsImpl = this.enqOptions;
        message.propsImpls = propsImpls;
        message.operation = constants.TNS_AQ_ARRAY_ENQ;
        message.numIters = propsImpls.length;
        return message;
      }
      //---------------------------------------------------------------------------
      // _createDeqMessage()
      //
      // Creates a dequeue message for dequeuing a single message.
      //---------------------------------------------------------------------------
      _createDeqMessage() {
        const propsImpl = new ThinMsgPropsImpl();
        const message = new AqDeqMessage(this._connImpl);
        message.queueImpl = this;
        message.deqOptionsImpl = this.deqOptions;
        message.propsImpl = propsImpl;
        return message;
      }
      //---------------------------------------------------------------------------
      // _createEnqMessage()
      //
      // Creates an enqueue message for enqueuing a single message.
      //---------------------------------------------------------------------------
      _createEnqMessage(propsImpl) {
        const message = new AqEnqMessage(this._connImpl);
        message.queueImpl = this;
        message.enqOptionsImpl = this.enqOptions;
        message.propsImpl = propsImpl;
        return message;
      }
      //---------------------------------------------------------------------------
      // deq()
      //
      // Dequeues messages from the queue, either one or many based on the max
      // number of messages requested.
      //---------------------------------------------------------------------------
      async deq(maxNumMessages) {
        let results;
        if (maxNumMessages > 1) {
          results = await this.deqMany(maxNumMessages);
        } else if (maxNumMessages == 1) {
          results = await this.deqOne();
        } else {
          errors.throwErr(errors.ERR_INVALID_MAX_MESSAGES);
        }
        return results;
      }
      //---------------------------------------------------------------------------
      // deqMany()
      //
      // Dequeues multiple messages from the queue.
      //---------------------------------------------------------------------------
      async deqMany(maxNumMessages) {
        if (this.enqOptions.visibility === AQ_VISIBILITY_IMMEDIATE)
          errors.throwNotImplemented("immediate visibility with deqMany");
        const message = this._createArrayDeqMessage(maxNumMessages);
        await this._connImpl._protocol._processMessage(message);
        if (message.noMsgFound) {
          return [];
        }
        return message.propsImpls.slice(0, message.numIters);
      }
      //---------------------------------------------------------------------------
      // deqOne()
      //
      // Dequeues a single message from the queue.
      //---------------------------------------------------------------------------
      async deqOne() {
        const message = this._createDeqMessage();
        await this._connImpl._protocol._processMessage(message);
        if (message.noMsgFound) {
          return [];
        }
        return [message.propsImpl];
      }
      //---------------------------------------------------------------------------
      // enq()
      //
      // Enqueues one or many messages to the queue based on the number provided.
      //---------------------------------------------------------------------------
      async enq(messages) {
        const propsImpls = messages.map((properties) => {
          const impl = new ThinMsgPropsImpl();
          impl._init(properties);
          return impl;
        });
        if (messages.length == 1)
          return await this.enqOne(propsImpls[0]);
        return await this.enqMany(propsImpls);
      }
      //---------------------------------------------------------------------------
      // enqMany()
      //
      // Enqueues multiple messages to the queue.
      //---------------------------------------------------------------------------
      async enqMany(propsImpls) {
        if (this.enqOptions.visibility === AQ_VISIBILITY_IMMEDIATE)
          errors.throwNotImplemented("immediate visibility with enqMany");
        const message = this._createArrayEnqMessage(propsImpls);
        await this._connImpl._protocol._processMessage(message);
        return propsImpls;
      }
      //---------------------------------------------------------------------------
      // enqOne()
      //
      // Enqueues a single message to the queue.
      //---------------------------------------------------------------------------
      async enqOne(propsImpl) {
        const message = this._createEnqMessage(propsImpl);
        await this._connImpl._protocol._processMessage(message);
        return [propsImpl];
      }
      //---------------------------------------------------------------------------
      // _getConnImpl()
      //
      // Common method on all classes that make use of a connection -- used to
      // ensure serialization of all use of the connection.
      //---------------------------------------------------------------------------
      _getConnImpl() {
        return this._connImpl;
      }
    };
    var ThinDeqOptionsImpl = class {
      constructor() {
        this.condition = null;
        this.consumerName = null;
        this.correlation = null;
        this.deliveryMode = constants.TNS_AQ_MSG_PERSISTENT;
        this.mode = constants.TNS_AQ_DEQ_REMOVE;
        this.msgId = null;
        this.navigation = constants.TNS_AQ_DEQ_NEXT_MSG;
        this.transformation = null;
        this.visibility = constants.TNS_AQ_DEQ_ON_COMMIT;
        this.wait = constants.TNS_AQ_DEQ_WAIT_FOREVER;
      }
      getCondition() {
        return this.condition;
      }
      getConsumerName() {
        return this.consumerName;
      }
      getCorrelation() {
        return this.correlation;
      }
      getMsgId() {
        return this.msgId;
      }
      getMode() {
        return this.mode;
      }
      getNavigation() {
        return this.navigation;
      }
      getTransformation() {
        return this.transformation;
      }
      getVisibility() {
        return this.visibility;
      }
      getWait() {
        return this.wait;
      }
      setCondition(value) {
        this.condition = value;
      }
      setConsumerName(value) {
        this.consumerName = value;
      }
      setCorrelation(value) {
        this.correlation = value;
      }
      setDeliveryMode(value) {
        this.deliveryMode = value;
      }
      setMode(value) {
        this.mode = value;
      }
      setMsgId(value) {
        this.msgId = value;
      }
      setNavigation(value) {
        this.navigation = value;
      }
      setTransformation(value) {
        this.transformation = value;
      }
      setVisibility(value) {
        this.visibility = value;
      }
      setWait(value) {
        this.wait = value;
      }
    };
    var ThinEnqOptionsImpl = class {
      constructor() {
        this.transformation = null;
        this.visibility = constants.TNS_AQ_ENQ_ON_COMMIT;
        this.deliveryMode = constants.TNS_AQ_MSG_PERSISTENT;
      }
      getDeliveryMode() {
        return this.deliveryMode;
      }
      getTransformation() {
        errors.throwNotImplemented("transformation");
      }
      getVisibility() {
        return this.visibility;
      }
      setDeliveryMode(value) {
        this.deliveryMode = value;
      }
      // eslint-disable-next-line no-unused-vars
      setTransformation(value) {
        errors.throwNotImplemented("transformation");
      }
      setVisibility(value) {
        this.visibility = value;
      }
    };
    var ThinMsgPropsImpl = class {
      constructor() {
        this.delay = constants.TNS_AQ_MSG_NO_DELAY;
        this.correlation = null;
        this.exceptionq = null;
        this.expiration = constants.TNS_AQ_MSG_NO_EXPIRATION;
        this.priority = 0;
        this.recipients = [];
        this.numAttempts = 0;
        this.deliveryMode = 0;
        this.enqTime = null;
        this.msgId = null;
        this.state = 0;
        this.payload = null;
        this.enqTxnId = null;
        this.senderAgentName = null;
        this.senderAgentAddress = null;
        this.senderAgentProtocol = 0;
        this.originalMsgId = null;
      }
      //---------------------------------------------------------------------------
      // _init()
      //
      // Initializes the message properties from the provided properties object.
      //---------------------------------------------------------------------------
      _init(properties) {
        this.payload = properties.payload;
        if (properties.correlation !== void 0)
          this.correlation = properties.correlation;
        if (properties.delay !== void 0)
          this.delay = properties.delay;
        if (properties.exceptionQueue !== void 0)
          this.exceptionQueue = properties.exceptionQueue;
        if (properties.expiration !== void 0)
          this.expiration = properties.expiration;
        if (properties.priority !== void 0)
          this.priority = properties.priority;
        if (properties.recipients !== void 0)
          this.recipients = properties.recipients;
      }
      getNumAttempts() {
        return this.numAttempts;
      }
      getCorrelation() {
        return this.correlation;
      }
      getDelay() {
        return this.delay;
      }
      getDeliveryMode() {
        return this.deliveryMode;
      }
      getEnqTime() {
        return this.enqTime;
      }
      getExceptionQueue() {
        return this.exceptionq;
      }
      getExpiration() {
        return this.expiration;
      }
      getMsgId() {
        return this.msgId;
      }
      getOriginalMsgId() {
        return this.originalMsgId;
      }
      getPayload() {
        return this.payload;
      }
      getPriority() {
        return this.priority;
      }
      getState() {
        return this.state;
      }
      setCorrelation(value) {
        this.correlation = value;
      }
      setDelay(value) {
        this.delay = value;
      }
      setExceptionQueue(value) {
        this.exceptionq = value;
      }
      setExpiration(value) {
        this.expiration = value;
      }
      setPayloadBytes(value) {
        this.payload = value;
      }
      setPayloadObject(value) {
        this.payload = value;
      }
      setPayloadJson(value) {
        this.payload = value;
      }
      setPriority(value) {
        this.priority = value;
      }
      setRecipients(value) {
        this.recipients = value;
      }
    };
    module2.exports = { ThinQueueImpl };
  }
});

// node_modules/oracledb/lib/thin/connection.js
var require_connection3 = __commonJS({
  "node_modules/oracledb/lib/thin/connection.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var ConnectionImpl = require_connection();
    var ThinResultSetImpl = require_resultSet();
    var ThinLobImpl = require_lob3();
    var Protocol = require_protocol();
    var { BaseBuffer } = require_buffer();
    var { NetworkSession: nsi } = require_networkSession();
    var { Statement } = require_statement();
    var thinUtil = require_util2();
    var sqlNetConstants = require_constants4();
    var constants = require_constants3();
    var process2 = require("process");
    var types = require_types();
    var errors = require_errors();
    var messages = require_messages();
    var StatementCache = require_statementCache();
    var { ThinQueueImpl } = require_aq();
    var finalizationRegistry = new global.FinalizationRegistry((heldValue) => {
      heldValue.disconnect();
    });
    var TDSBuffer = class extends BaseBuffer {
    };
    var ThinConnectionImpl = class extends ConnectionImpl {
      /**
       * Terminates the connection
       *
       * @return {Promise}
       */
      async close() {
        try {
          if (this._protocol.txnInProgress) {
            if (this.tpcContext) {
              const message = this.createTpcRollbackMessage();
              await this._protocol._processMessage(message);
            } else {
              await this.rollback();
            }
            this.tpcContext = null;
          }
          if (this._drcpEnabled) {
            await this._sessRelease();
            this._drcpEstablishSession = true;
          }
          if (this._pool && !this._dropSess) {
            await this._pool.release(this);
          } else {
            if (!this._drcpEnabled) {
              const message = new messages.LogOffMessage(this);
              await this._protocol._processMessage(message);
            }
            this.nscon.disconnect();
          }
        } catch (err) {
          this.nscon.disconnect(sqlNetConstants.NSFIMM);
          if (this._pool)
            await this._pool.release(this);
        }
      }
      async _sessRelease() {
        const message = new messages.SessionReleaseMessage(this);
        if (!this.isPooled()) {
          message.sessReleaseMode = constants.DRCP_DEAUTHENTICATE;
        }
        await this._protocol._processMessage(message);
      }
      //---------------------------------------------------------------------------
      // _getElementTypeObj()
      //
      // Get the element type's object type. This is needed when processing
      // collections with an object as the element type since this information is
      // not available in the TDS.
      //---------------------------------------------------------------------------
      async _getElementTypeObj(info) {
        const binds = [
          {
            name: "owner",
            type: types.DB_TYPE_VARCHAR,
            dir: constants.BIND_IN,
            maxSize: 128,
            values: [info.schema]
          },
          {
            name: "name",
            type: types.DB_TYPE_VARCHAR,
            dir: constants.BIND_IN,
            maxSize: 128,
            values: [info.name]
          },
          {
            name: "package_name",
            type: types.DB_TYPE_VARCHAR,
            dir: constants.BIND_IN,
            maxSize: 128,
            values: [info.packageName]
          }
        ];
        let sql;
        if (info.packageName) {
          sql = `
        select
            elem_type_owner,
            elem_type_name,
            elem_type_package
        from all_plsql_coll_types
        where owner = :owner
          and type_name = :name
          and package_name = :package_name`;
        } else {
          binds.pop();
          sql = `
        select
            elem_type_owner,
            elem_type_name
        from all_coll_types
        where owner = :owner
          and type_name = :name`;
        }
        const options = {
          connection: { _impl: this },
          prefetchRows: 2
        };
        const result = await this.execute(sql, 1, binds, options, false);
        const rows = await result.resultSet.getRows(1, options);
        await result.resultSet.close();
        const row = rows[0];
        info.elementTypeClass = this._getDbObjectType(row[0], row[1], row[2]);
        if (info.elementTypeClass.partial) {
          this._partialDbObjectTypes.push(info.elementTypeClass);
        }
      }
      //---------------------------------------------------------------------------
      // _execute()
      //
      // Calls the RPC that executes a SQL statement and returns the results.
      //---------------------------------------------------------------------------
      async _execute(statement, numIters, binds, options, executeManyFlag, internalTempLobs = []) {
        if (executeManyFlag && statement.isQuery) {
          errors.throwErr(errors.ERR_EXECMANY_NOT_ALLOWED_ON_QUERIES);
        }
        const numStmtBinds = statement.bindInfoList.length;
        const numUserBinds = binds.length;
        if (numStmtBinds !== numUserBinds) {
          if (!binds[0]?.name) {
            errors.throwErr(errors.ERR_WRONG_NUMBER_OF_BINDS, numStmtBinds, numUserBinds);
          }
          const numDistinctStmtBinds = statement.bindInfoDict.size;
          if (numDistinctStmtBinds !== numUserBinds)
            errors.throwErr(errors.ERR_WRONG_NUMBER_OF_BINDS, numStmtBinds, numUserBinds);
        }
        for (let i = 0; i < binds.length; i++) {
          await this._bind(statement, binds[i], i + 1, internalTempLobs);
        }
        if (statement.isPlSql && (options.batchErrors || options.dmlRowCounts)) {
          errors.throwErr(errors.ERR_EXEC_MODE_ONLY_FOR_DML);
        }
        const message = new messages.ExecuteMessage(this, statement, options);
        message.numExecs = numIters;
        message.arrayDmlRowCounts = options.dmlRowCounts;
        message.batchErrors = options.batchErrors;
        if (statement.isPlSql && (statement.cursorId === 0 || statement.requiresFullExecute)) {
          message.numExecs = 1;
          message.noImplicitRelease = true;
          await this._protocol._processMessage(message);
          statement.requiresFullExecute = false;
          message.numExecs = numIters - 1;
          message.offset = 1;
          message.noImplicitRelease = false;
        }
        if (message.numExecs > 0) {
          await this._protocol._processMessage(message);
          statement.requiresFullExecute = false;
        }
        if (statement.requiresDefine && statement.sql) {
          statement.requiresFullExecute = true;
          await this._protocol._processMessage(message);
          statement.requiresFullExecute = false;
          statement.requiresDefine = false;
        }
        const result = {};
        if (message.warning) {
          result.warning = message.warning;
        }
        if (statement.numQueryVars > 0) {
          result.resultSet = message.resultSet;
        } else {
          statement.bufferRowIndex = 0;
          const outBinds = thinUtil.getOutBinds(
            statement,
            numIters,
            executeManyFlag
          );
          if (outBinds) {
            result.outBinds = outBinds;
          }
          if (executeManyFlag) {
            if (!statement.isPlSql) {
              result.rowsAffected = statement.rowCount;
              delete statement.rowCount;
            }
            if (options.dmlRowCounts) {
              result.dmlRowCounts = options.dmlRowCounts;
            }
            if (options.batchErrors) {
              result.batchErrors = options.batchErrors;
            }
          } else {
            if (statement.isPlSql && options.implicitResultSet) {
              result.implicitResults = options.implicitResultSet;
            }
            if (statement.lastRowid) {
              result.lastRowid = statement.lastRowid;
              delete statement.lastRowid;
            }
            if (statement.isPlSql) {
              if (statement.rowCount) {
                result.rowsAffected = statement.rowCount;
              }
            } else {
              result.rowsAffected = statement.rowCount || 0;
            }
            if (statement.rowCount) {
              delete statement.rowCount;
            }
          }
          this._returnStatement(statement);
        }
        return result;
      }
      //---------------------------------------------------------------------------
      // _parseTDSAttr()
      //
      // Returns the DB type and fills metadata from the TDS buffer.
      //---------------------------------------------------------------------------
      _parseTDSAttr(buf, metaData) {
        let oraTypeNum, csfrm, attrType;
        for (; ; ) {
          attrType = buf.readUInt8();
          if (attrType === constants.TNS_OBJ_TDS_TYPE_EMBED_ADT_INFO) {
            buf.skipBytes(1);
          } else if (attrType !== constants.TNS_OBJ_TDS_TYPE_SUBTYPE_MARKER) {
            break;
          }
        }
        let tempPrecision, tempScale;
        switch (attrType) {
          case constants.TNS_OBJ_TDS_TYPE_NUMBER:
            tempPrecision = buf.readInt8();
            tempScale = buf.readInt8();
            if (tempPrecision || tempScale) {
              metaData.precision = tempPrecision;
              metaData.scale = tempScale;
            }
            return types.DB_TYPE_NUMBER;
          case constants.TNS_OBJ_TDS_TYPE_FLOAT:
            tempPrecision = buf.readInt8();
            if (tempPrecision)
              metaData.precision = tempPrecision;
            return types.DB_TYPE_NUMBER;
          case constants.TNS_OBJ_TDS_TYPE_VARCHAR:
          case constants.TNS_OBJ_TDS_TYPE_CHAR:
            metaData.maxSize = buf.readUInt16BE();
            oraTypeNum = attrType === constants.TNS_OBJ_TDS_TYPE_VARCHAR ? constants.TNS_DATA_TYPE_VARCHAR : constants.TNS_DATA_TYPE_CHAR;
            csfrm = buf.readUInt8();
            csfrm = csfrm & 127;
            buf.skipBytes(2);
            return types.getTypeByOraTypeNum(oraTypeNum, csfrm);
          case constants.TNS_OBJ_TDS_TYPE_RAW:
            metaData.maxSize = buf.readUInt16BE();
            return types.DB_TYPE_RAW;
          case constants.TNS_OBJ_TDS_TYPE_BINARY_FLOAT:
            return types.DB_TYPE_BINARY_FLOAT;
          case constants.TNS_OBJ_TDS_TYPE_BINARY_DOUBLE:
            return types.DB_TYPE_BINARY_DOUBLE;
          case constants.TNS_OBJ_TDS_TYPE_DATE:
            return types.DB_TYPE_DATE;
          case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP:
            buf.skipBytes(1);
            return types.DB_TYPE_TIMESTAMP;
          case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_LTZ:
            buf.skipBytes(1);
            return types.DB_TYPE_TIMESTAMP_LTZ;
          case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_TZ:
            buf.skipBytes(1);
            return types.DB_TYPE_TIMESTAMP_TZ;
          case constants.TNS_OBJ_TDS_TYPE_BOOLEAN:
            return types.DB_TYPE_BOOLEAN;
          case constants.TNS_OBJ_TDS_TYPE_CLOB:
            return types.DB_TYPE_CLOB;
          case constants.TNS_OBJ_TDS_TYPE_BLOB:
            return types.DB_TYPE_BLOB;
          case constants.TNS_OBJ_TDS_TYPE_OBJ:
            buf.skipBytes(5);
            return types.DB_TYPE_OBJECT;
          case constants.TNS_OBJ_TDS_TYPE_START_EMBED_ADT:
            while (this._parseTDSAttr(buf, {}) !== 0) {
              continue;
            }
            return types.DB_TYPE_OBJECT;
          case constants.TNS_OBJ_TDS_TYPE_END_EMBED_ADT:
            return 0;
          default:
            errors.throwErr(errors.ERR_TDS_TYPE_NOT_SUPPORTED, attrType);
        }
      }
      //---------------------------------------------------------------------------
      // _parseTDS()
      //
      // Parses the TDS (type descriptor segment) for the type.
      //---------------------------------------------------------------------------
      async _parseTDS(tds, info) {
        const buf = new TDSBuffer(tds);
        buf.skipBytes(4);
        buf.skipBytes(2);
        buf.skipBytes(2);
        const numAttrs = buf.readUInt16BE();
        buf.skipBytes(1);
        buf.skipBytes(1);
        buf.skipBytes(2);
        buf.skipBytes(4);
        info.isCollection = false;
        if (numAttrs === 1) {
          const pos = buf.pos;
          const attrType = buf.readUInt8();
          if (attrType === constants.TNS_OBJ_TDS_TYPE_COLL) {
            info.isCollection = true;
          } else {
            buf.pos = pos;
          }
        }
        if (info.isCollection) {
          const elementPos = buf.readUInt32BE();
          info.maxNumElements = buf.readUInt32BE();
          info.collectionType = buf.readUInt8();
          if (info.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {
            info.collectionFlags = constants.TNS_OBJ_HAS_INDEXES;
          }
          buf.pos = elementPos;
          info.elementTypeInfo = {};
          info.elementType = this._parseTDSAttr(buf, info.elementTypeInfo);
          if (info.elementType === types.DB_TYPE_OBJECT) {
            await this._getElementTypeObj(info);
            if (info.elementTypeClass.isXmlType) {
              info.elementType = types.DB_TYPE_XMLTYPE;
            }
          }
        } else {
          if (info.attributes) {
            for (const attr of info.attributes) {
              this._parseTDSAttr(buf, attr);
            }
          }
        }
      }
      //---------------------------------------------------------------------------
      // _populateRowTypeInfo()
      //
      // Get column and datatype information in case of %ROWTYPE handling.
      //---------------------------------------------------------------------------
      async _populateRowTypeInfo(info, options, result) {
        const getColumnsSQL = `
      SELECT
        column_name,
        data_type,
        data_type_owner,
        case
          when data_type in
            ('CHAR', 'NCHAR', 'VARCHAR2', 'NVARCHAR2', 'RAW')
            then data_length
          else 0
        end,
        case
          when data_precision is null and data_scale is null
            then 0
          when data_precision is null
            then 38
          else data_precision
        end,
        case
          when data_precision is null and data_scale is null
              and data_type = 'NUMBER'
            then -127
          when data_scale is null
            then 0
          else data_scale
        end
      from all_tab_cols
      where owner = :owner
        and table_name = :name
        and hidden_column != 'YES'
      order by column_id`;
        const bindVal = [
          {
            name: "owner",
            type: types.DB_TYPE_VARCHAR,
            maxSize: 128,
            dir: constants.BIND_IN,
            values: [result.outBinds.schema]
          },
          {
            name: "name",
            type: types.DB_TYPE_VARCHAR,
            maxSize: 128,
            dir: constants.BIND_IN,
            values: [info.name.substring(0, info.name.length - 8)]
          }
        ];
        const val = await this.execute(
          getColumnsSQL,
          1,
          bindVal,
          options,
          false
        );
        try {
          const attrRows = await val.resultSet._getAllRows();
          info.attributes = [];
          for (const row of attrRows) {
            const metaData = {
              name: row[0],
              dataType: row[1],
              dataTypeOwner: row[2],
              maxSize: row[3],
              dataPrecision: row[4],
              dataScale: row[5]
            };
            if (!metaData.dataTypeOwner) {
              const startPos = row[1].indexOf("(");
              const endPos = row[1].indexOf(")");
              if (endPos > startPos) {
                metaData.dataType = metaData.dataType.substring(0, startPos) + metaData.dataType.substring(
                  endPos + 1,
                  metaData.dataType.length
                );
              }
            }
            this._addAttr(info.attributes, metaData);
          }
        } finally {
          val.resultSet.close();
        }
      }
      //---------------------------------------------------------------------------
      // _populateDbObjectTypeInfo()
      //
      // Poplates type information given the name of the type.
      //---------------------------------------------------------------------------
      async _populateDbObjectTypeInfo(name) {
        const sql = `
      declare
          t_Instantiable              varchar2(3);
          t_SuperTypeOwner            varchar2(128);
          t_SuperTypeName             varchar2(128);
          t_SubTypeRefCursor          sys_refcursor;
          t_Pos                       pls_integer;
      begin
          :ret_val := dbms_pickler.get_type_shape(:full_name, :oid,
              :version, :tds, t_Instantiable, t_SuperTypeOwner,
              t_SuperTypeName, :attrs_rc, t_SubTypeRefCursor);
          :package_name := null;
          if substr(:full_name, length(:full_name) - 7) = '%ROWTYPE' then
              t_Pos := instr(:full_name, '.');
              :schema := substr(:full_name, 1, t_Pos - 1);
              :name := substr(:full_name, t_Pos + 1);
          else
              begin
                  select owner, type_name
                  into :schema, :name
                  from all_types
                  where type_oid = :oid;
              exception
              when no_data_found then
                  begin
                      select owner, package_name, type_name
                      into :schema, :package_name, :name
                      from all_plsql_types
                      where type_oid = :oid;
                  exception
                  when no_data_found then
                      null;
                  end;
              end;
          end if;
      end;`;
        const binds = [
          {
            name: "full_name",
            type: types.DB_TYPE_VARCHAR,
            dir: constants.BIND_INOUT,
            maxSize: 500,
            values: [name]
          },
          {
            name: "ret_val",
            type: types.DB_TYPE_BINARY_INTEGER,
            dir: constants.BIND_OUT,
            values: []
          },
          {
            name: "oid",
            type: types.DB_TYPE_RAW,
            maxSize: 16,
            dir: constants.BIND_OUT,
            values: []
          },
          {
            name: "version",
            type: types.DB_TYPE_BINARY_INTEGER,
            dir: constants.BIND_OUT,
            values: []
          },
          {
            name: "tds",
            type: types.DB_TYPE_RAW,
            maxSize: 2e3,
            dir: constants.BIND_OUT,
            values: []
          },
          {
            name: "attrs_rc",
            type: types.DB_TYPE_CURSOR,
            dir: constants.BIND_OUT,
            values: []
          },
          {
            name: "package_name",
            type: types.DB_TYPE_VARCHAR,
            maxSize: 128,
            dir: constants.BIND_OUT,
            values: []
          },
          {
            name: "schema",
            type: types.DB_TYPE_VARCHAR,
            maxSize: 128,
            dir: constants.BIND_OUT,
            values: []
          },
          {
            name: "name",
            type: types.DB_TYPE_VARCHAR,
            maxSize: 128,
            dir: constants.BIND_OUT,
            values: []
          }
        ];
        const options = {
          connection: { _impl: this },
          nullifyInvalidCursor: true
        };
        const result = await this.execute(sql, 1, binds, options, false);
        if (result.outBinds.ret_val !== 0) {
          errors.throwErr(errors.ERR_INVALID_OBJECT_TYPE_NAME, name);
        }
        try {
          const info = this._getDbObjectType(
            result.outBinds.schema,
            result.outBinds.name,
            result.outBinds.package_name,
            result.outBinds.oid
          );
          if (!info.partial) {
            return info;
          }
          if (info.name.endsWith("%ROWTYPE")) {
            await this._populateRowTypeInfo(info, options, result);
          } else {
            info.version = result.outBinds.version;
            const attrRows = await result.outBinds.attrs_rc._getAllRows();
            if (attrRows.length > 0) {
              info.attributes = [];
              for (const row of attrRows) {
                const metaData = {
                  name: row[1],
                  dataType: row[3],
                  dataTypeOwner: row[4],
                  packageName: row[5],
                  oid: row[6]
                };
                this._addAttr(info.attributes, metaData);
              }
            }
            await this._parseTDS(result.outBinds.tds, info);
          }
          info.partial = false;
          return info;
        } finally {
          result.outBinds.attrs_rc.close();
        }
      }
      //---------------------------------------------------------------------------
      // _addAttr()
      //
      // Populates "attributes" object present in "attrList".
      //---------------------------------------------------------------------------
      _addAttr(attributes, attrInfo) {
        const attr = { name: attrInfo.name };
        if (attrInfo.dataTypeOwner) {
          attr.type = types.DB_TYPE_OBJECT;
          attr.typeClass = this._getDbObjectType(
            attrInfo.dataTypeOwner,
            attrInfo.dataType,
            attrInfo.packageName,
            attrInfo.oid
          );
          if (attr.typeClass.isXmlType) {
            attr.type = types.DB_TYPE_XMLTYPE;
          }
          if (attr.typeClass.partial) {
            this._partialDbObjectTypes.push(attr.typeClass);
          }
        } else {
          if (attrInfo.dataType === "INTEGER" || attrInfo.dataType === "SMALLINT") {
            attr.type = types.DB_TYPE_NUMBER;
            attr.precision = 38;
            attr.scale = 0;
          } else if (attrInfo.dataType === "REAL") {
            attr.type = types.DB_TYPE_NUMBER;
            attr.precision = 63;
            attr.scale = -127;
          } else if (attrInfo.dataType === "DOUBLE PRECISION" || attrInfo.dataType === "FLOAT") {
            attr.type = types.DB_TYPE_NUMBER;
            if (attrInfo.dataPrecision != null || attrInfo.dataPrecision != void 0)
              attr.precision = Number(attrInfo.dataPrecision);
            else
              attr.precision = 126;
            attr.scale = -127;
          } else {
            attr.type = types.getTypeByColumnTypeName(attrInfo.dataType);
            if (attrInfo.maxSize != null || attrInfo.maxSize != void 0) {
              const tempMaxSize = Number(attrInfo.maxSize);
              if (tempMaxSize)
                attr.maxSize = tempMaxSize;
            }
            if (attr.type === types.DB_TYPE_NUMBER) {
              attr.precision = Number(attrInfo.dataPrecision);
              attr.scale = Number(attrInfo.dataScale);
            }
          }
        }
        attributes.push(attr);
      }
      //---------------------------------------------------------------------------
      // _populatePartialDbObjectTypes()
      //
      // Populates partial types that were discovered earlier. Since populating an
      // object type might result in additional object types being discovered,
      // object types are popped from the partial types list until the list is
      // empty.
      //---------------------------------------------------------------------------
      async _populatePartialDbObjectTypes() {
        while (this._partialDbObjectTypes.length > 0) {
          const info = this._partialDbObjectTypes.pop();
          let suffix = "%ROWTYPE";
          let name = info.name;
          if (name.endsWith(suffix)) {
            name = name.substring(0, name.length - suffix.length);
          } else {
            suffix = "";
          }
          let fullName;
          if (info.packageName) {
            fullName = `"${info.schema}"."${info.packageName}"."${name}"${suffix}`;
          } else {
            fullName = `"${info.schema}"."${name}"${suffix}`;
          }
          await this._populateDbObjectTypeInfo(fullName);
        }
      }
      async commit() {
        const message = new messages.CommitMessage(this);
        await this._protocol._processMessage(message);
      }
      async breakExecution() {
        await this._protocol.breakMessage();
      }
      isCompressionEnabled() {
        return this.nscon.compressionEnabled;
      }
      isHealthy() {
        try {
          if (this.nscon.recvInbandNotif() === 0)
            return true;
          return false;
        } catch {
          return false;
        }
      }
      isPooled() {
        return this._pool ? true : false;
      }
      _postConnect(authMessage) {
        let releaseNum;
        let updateNum;
        let portReleaseNum;
        let portUpdateNum;
        this.dbDomain = authMessage.sessionData["AUTH_SC_DB_DOMAIN"];
        this.dbName = authMessage.sessionData["AUTH_DBNAME"];
        this.maxOpenCursors = Number(authMessage.sessionData["AUTH_MAX_OPEN_CURSORS"] || 0);
        this.serviceName = authMessage.sessionData["AUTH_SC_SERVICE_NAME"];
        this.instanceName = authMessage.sessionData["AUTH_INSTANCENAME"];
        this.maxIdentifierLength = Number(authMessage.sessionData["AUTH_MAX_IDEN_LENGTH"] || 30);
        const fullVersionNum = Number(authMessage.sessionData["AUTH_VERSION_NO"]);
        const versionNum = fullVersionNum >> 24 & 255;
        this.warning = authMessage.warning;
        if (this._protocol.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_18_1_EXT_1) {
          releaseNum = fullVersionNum >> 16 & 255;
          updateNum = fullVersionNum >> 12 & 15;
          portReleaseNum = fullVersionNum >> 4 & 255;
          portUpdateNum = fullVersionNum & 15;
        } else {
          releaseNum = fullVersionNum >> 20 & 15;
          updateNum = fullVersionNum >> 12 & 255;
          portReleaseNum = fullVersionNum >> 8 & 15;
          portUpdateNum = fullVersionNum & 255;
        }
        this.serverVersionString = versionNum + "." + releaseNum + "." + updateNum + "." + portReleaseNum + "." + portUpdateNum;
        this.serverVersion = versionNum * 1e8 + releaseNum * 1e6 + updateNum * 1e4 + portReleaseNum * 100 + portUpdateNum * 1;
      }
      /**
       *
       * @param {object} params  Configuration of the connection
       *
       * @return {Promise}
       */
      async connect(params) {
        if (!params.connectString) {
          errors.throwErr(errors.ERR_EMPTY_CONNECT_STRING);
        }
        thinUtil.checkCredentials(params);
        this.sessionID = 0;
        this.serialNum = 0;
        this.autoCommit = false;
        this.serverVersion = "";
        this.statementCache = null;
        this.currentSchema = "";
        this.invokeSessionCallback = true;
        this.statementCacheSize = params.stmtCacheSize;
        this._currentSchemaModified = false;
        this._tempLobsToClose = [];
        this._tempLobsTotalSize = 0;
        this._drcpEstablishSession = false;
        this._cclass = null;
        this._clientIdentifier = "";
        this._clientIdentifierModified = false;
        this._action = "";
        this._actionModified = false;
        this._dbOp = "";
        this._dbOpModified = false;
        this._clientInfo = "";
        this._clientInfoModified = false;
        this._module = "";
        this._moduleModified = false;
        this._drcpEnabled = false;
        this.serviceName = "";
        this.remoteAddress = "";
        this.comboKey = null;
        this.tpcContext = null;
        this._sessionlessData = null;
        this.nscon = new nsi();
        finalizationRegistry.register(this, this.nscon);
        await this.nscon.connect(params);
        let serverType;
        if (this.isPooled()) {
          serverType = params._connInfo[0];
          this.serviceName = params._connInfo[2];
          this.purity = params._connInfo[3] | constants.PURITY_DEFAULT;
          this.sid = params._connInfo[4];
        } else {
          serverType = this.nscon.getOption(sqlNetConstants.SERVERTYPE);
          this.serviceName = this.nscon.getOption(sqlNetConstants.SVCNAME);
          this.sid = this.nscon.getOption(sqlNetConstants.SID);
          this.purity = this.nscon.getOption(sqlNetConstants.PURITY) | constants.PURITY_DEFAULT;
        }
        if (serverType) {
          this._drcpEnabled = serverType.toLowerCase() === "pooled";
        }
        this.remoteAddress = this.nscon.getOption(sqlNetConstants.REMOTEADDR);
        this.connectionClass = params.connectionClass;
        if (this.purity === constants.PURITY_DEFAULT && this._drcpEnabled) {
          if (this.isPooled()) {
            this.purity = constants.PURITY_SELF;
          } else {
            this.purity = constants.PURITY_NEW;
          }
        }
        this._protocol = new Protocol(this);
        if (this._protocol.caps.protocolVersion < constants.TNS_VERSION_MIN_ACCEPTED) {
          errors.throwErr(errors.ERR_SERVER_VERSION_NOT_SUPPORTED);
        }
        try {
          const protocolMessage = new messages.ProtocolMessage(this);
          const dataTypeMessage = new messages.DataTypeMessage(this);
          const authMessage = new messages.AuthMessage(this, params);
          if (this.nscon.supportsFastAuth) {
            const fastAuthMessage = new messages.FastAuthMessage(this);
            fastAuthMessage.protocolMessage = protocolMessage;
            fastAuthMessage.dataTypeMessage = dataTypeMessage;
            fastAuthMessage.authMessage = authMessage;
            await this._protocol._processMessage(fastAuthMessage);
            if (fastAuthMessage.reNegotiate) {
              await this._protocol._processMessage(dataTypeMessage);
              await this._protocol._processMessage(authMessage);
            }
          } else {
            const endOfRequestSupport = this.nscon.endOfRequestSupport;
            this.nscon.endOfRequestSupport = false;
            await this._protocol._processMessage(protocolMessage);
            await this._protocol._processMessage(dataTypeMessage);
            this.nscon.endOfRequestSupport = endOfRequestSupport;
            await this._protocol._processMessage(authMessage);
          }
          if (!params.externalAuth) {
            await this._protocol._processMessage(authMessage);
          }
          this._postConnect(authMessage);
        } catch (err) {
          this.nscon.disconnect();
          throw err;
        }
        this.statementCache = new StatementCache(this.statementCacheSize);
        this._partialDbObjectTypes = [];
        if (params.debugJDWP) {
          this.jdwpData = Buffer2.from(params.debugJDWP);
        } else if (process2.env.ORA_DEBUG_JDWP) {
          this.jdwpData = Buffer2.from(process2.env.ORA_DEBUG_JDWP);
        }
        this._protocol.connInProgress = false;
      }
      //---------------------------------------------------------------------------
      // Return the statement to the statement cache, if applicable
      //---------------------------------------------------------------------------
      _returnStatement(statement) {
        this.statementCache.returnStatement(statement);
      }
      //---------------------------------------------------------------------------
      // Parses the sql statement and puts it into cache if keepInStmtCache
      // option is true
      //---------------------------------------------------------------------------
      _prepare(sql, options) {
        const statement = this._getStatement(sql, options.keepInStmtCache);
        statement.bufferRowIndex = 0;
        statement.bufferRowCount = 0;
        statement.lastRowIndex = 0;
        statement.moreRowsToFetch = true;
        return statement;
      }
      //---------------------------------------------------------------------------
      // Binds the values by user to the statement object
      //---------------------------------------------------------------------------
      async _bind(stmt, variable, pos = 0, internalTempLobs = []) {
        const bindInfoDict = stmt.bindInfoDict;
        const bindInfoList = stmt.bindInfoList;
        if (stmt.isPlSql && variable.maxSize > 32767) {
          if (variable.type === types.DB_TYPE_RAW || variable.type === types.DB_TYPE_LONG_RAW) {
            variable.type = types.DB_TYPE_BLOB;
          } else if (variable.type._csfrm === constants.CSFRM_NCHAR) {
            variable.type = types.DB_TYPE_NCLOB;
          } else {
            variable.type = types.DB_TYPE_CLOB;
          }
          const maxSize = variable.maxSize;
          delete variable.maxSize;
          variable.outConverter = async function(val) {
            if (val === null) {
              return null;
            }
            const data = await val.getData();
            const len = val._length;
            if (data && len > maxSize) {
              errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);
            }
            return data;
          };
        }
        if (variable.type === types.DB_TYPE_CLOB || variable.type === types.DB_TYPE_NCLOB || variable.type === types.DB_TYPE_BLOB) {
          for (const [index, val] of variable.values.entries()) {
            if (!(val instanceof ThinLobImpl)) {
              if (val && val.length > 0) {
                const lobImpl = new ThinLobImpl();
                await lobImpl.create(this, variable.type);
                internalTempLobs.push(lobImpl);
                await lobImpl.write(1, val);
                variable.values[index] = lobImpl;
              } else {
                variable.values[index] = null;
              }
            }
          }
        }
        if (variable.name) {
          let normalizedName;
          if (variable.name.startsWith('"') && variable.name.endsWith('"')) {
            normalizedName = variable.name.substring(1, variable.name.length - 1);
          } else {
            normalizedName = variable.name.toUpperCase();
          }
          if (normalizedName.startsWith(":")) {
            normalizedName = variable.name.substring(1);
          }
          if (!bindInfoDict.has(normalizedName)) {
            errors.throwErr(errors.ERR_INVALID_BIND_NAME, normalizedName);
          }
          bindInfoDict.get(normalizedName).forEach((bindInfo) => {
            stmt._setVariable(bindInfo, variable);
          });
        } else {
          const bindInfo = bindInfoList[pos - 1];
          stmt._setVariable(bindInfo, variable);
        }
      }
      //---------------------------------------------------------------------------
      // _createResultSet()
      //
      // Creates a result set and performs any necessary initialization.
      //---------------------------------------------------------------------------
      _createResultSet(options, statement) {
        const resultSet = new ThinResultSetImpl();
        if (!statement) {
          statement = new Statement();
        }
        resultSet._resultSetNew(this, statement, options);
        if (statement.queryVars.length > 0) {
          const metadata = thinUtil.getMetadataMany(statement.queryVars);
          resultSet._setup(options, metadata);
        }
        return resultSet;
      }
      //---------------------------------------------------------------------------
      // getDbObjectClass()
      //
      // Returns a database object class given its name.
      //---------------------------------------------------------------------------
      async getDbObjectClass(name) {
        const info = await this._populateDbObjectTypeInfo(name);
        await this._populatePartialDbObjectTypes();
        return info;
      }
      //---------------------------------------------------------------------------
      // getStatementInfo()
      //
      // Parses the SQL statement and returns information about the statement.
      //---------------------------------------------------------------------------
      async getStatementInfo(sql) {
        const options = {};
        const result = {};
        const statement = this._prepare(sql, options);
        options.connection = this;
        try {
          if (!statement.isDdl) {
            const message = new messages.ExecuteMessage(this, statement, options);
            message.parseOnly = true;
            await this._protocol._processMessage(message);
          }
          if (statement.numQueryVars > 0) {
            result.metaData = thinUtil.getMetadataMany(statement.queryVars);
          }
          result.bindNames = Array.from(statement.bindInfoDict.keys());
          result.statementType = statement.statementType;
          return result;
        } finally {
          this._returnStatement(statement);
        }
      }
      //---------------------------------------------------------------------------
      // execute()
      //
      // Calls the RPC that executes a SQL statement and returns the results.
      //---------------------------------------------------------------------------
      async execute(sql, numIters, binds, options, executeManyFlag) {
        const statement = this._prepare(sql, options);
        const internalTempLobs = [];
        try {
          return await this._execute(
            statement,
            numIters,
            binds,
            options,
            executeManyFlag,
            internalTempLobs
          );
        } catch (err) {
          this._returnStatement(statement);
          throw err;
        } finally {
          for (const lob of internalTempLobs) {
            this._tempLobsToClose.push(lob._locator);
            this._tempLobsTotalSize += lob._locator.length;
          }
        }
      }
      //---------------------------------------------------------------------------
      // Get the statement object from the statement cache for the SQL if it exists
      // else prepare a new statement object for the SQL. If a statement is already
      // in use a copy will be made and returned (and will not be returned to the
      // cache). If a statement is being executed for the first time after releasing
      // a DRCP session, a copy will also be made (and will not be returned to the
      // cache) since it is unknown at this point whether the original session or a
      // new session is going to be used.
      //---------------------------------------------------------------------------
      _getStatement(sql, cacheStatement = false) {
        return this.statementCache.getStatement(
          sql,
          cacheStatement,
          this._drcpEstablishSession
        );
      }
      //---------------------------------------------------------------------------
      // Calls the ping RPC for Oracle Database
      //---------------------------------------------------------------------------
      async ping() {
        const message = new messages.PingMessage(this);
        await this._protocol._processMessage(message);
      }
      //---------------------------------------------------------------------------
      // Calls the Rollback RPC for Oracle Database
      //---------------------------------------------------------------------------
      async rollback() {
        const message = new messages.RollbackMessage(this);
        await this._protocol._processMessage(message);
      }
      //---------------------------------------------------------------------------
      // Returns the Oracle Server version
      //---------------------------------------------------------------------------
      getOracleServerVersion() {
        return this.serverVersion;
      }
      //---------------------------------------------------------------------------
      // Returns the Oracle Server version string
      //---------------------------------------------------------------------------
      getOracleServerVersionString() {
        return this.serverVersionString;
      }
      setCurrentSchema(schema) {
        this._currentSchemaModified = true;
        this.currentSchema = schema;
      }
      getCurrentSchema() {
        return this.currentSchema;
      }
      setClientId(clientId) {
        this._clientIdentifierModified = true;
        this._clientIdentifier = clientId;
      }
      setDbOp(dbOp) {
        this._dbOpModified = true;
        this._dbOp = dbOp;
      }
      setExternalName(value) {
        this.externalName = value;
      }
      setInternalName(value) {
        this.internalName = value;
      }
      setClientInfo(clientInfo) {
        this._clientInfoModified = true;
        this._clientInfo = clientInfo;
      }
      setModule(module3) {
        this._moduleModified = true;
        this._module = module3;
        this._actionModified = true;
      }
      setAction(action) {
        this._actionModified = true;
        this._action = action;
      }
      async changePassword(user, password, newPassword) {
        const config = {
          user,
          newPassword,
          password,
          changePassword: true
        };
        const message = new messages.AuthMessage(this, config);
        await this._protocol._processMessage(message);
      }
      async createLob(dbType) {
        const lobImpl = new ThinLobImpl();
        await lobImpl.create(this, dbType);
        return lobImpl;
      }
      // Check the state returned by the tpcCommit() call.
      checkTpcCommitState(state, onePhase) {
        if (onePhase && state !== constants.TNS_TPC_TXN_STATE_READ_ONLY && state !== constants.TNS_TPC_TXN_STATE_COMMITTED || !onePhase && state !== constants.TNS_TPC_TXN_STATE_FORGOTTEN) {
          errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, state);
        }
      }
      // Creates a two-phase commit message suitable for committing a transaction.
      createTpcCommitMessage(xid, onePhase) {
        const message = new messages.TransactionChangeStateMessage(this);
        message.operation = constants.TNS_TPC_TXN_COMMIT;
        message.state = onePhase == 0 ? constants.TNS_TPC_TXN_STATE_COMMITTED : constants.TNS_TPC_TXN_STATE_READ_ONLY;
        message.xid = xid;
        message.context = this.tpcContext;
        return message;
      }
      // Creates a two-phase commit rollback message suitable for use in both
      // the close() method and explicitly by the user.
      createTpcRollbackMessage(xid = null) {
        const message = new messages.TransactionChangeStateMessage(this);
        message.operation = constants.TNS_TPC_TXN_ABORT;
        message.state = constants.TNS_TPC_TXN_STATE_ABORTED;
        message.xid = xid;
        message.context = this.tpcContext;
        return message;
      }
      //---------------------------------------------------------------------------
      // tpcBegin()
      //---------------------------------------------------------------------------
      async tpcBegin(xid, flags, timeout) {
        const message = new messages.TransactionSwitchMessage(this);
        message.operation = constants.TNS_TPC_TXN_START;
        message.xid = xid;
        message.flags = flags;
        message.timeout = timeout;
        await this._protocol._processMessage(message);
        this.tpcContext = message.context;
      }
      //---------------------------------------------------------------------------
      // tpcCommit()
      //---------------------------------------------------------------------------
      async tpcCommit(xid, onePhase) {
        const message = this.createTpcCommitMessage(xid, onePhase);
        await this._protocol._processMessage(message);
        this.checkTpcCommitState(message.state, onePhase);
      }
      //---------------------------------------------------------------------------
      // tpcEnd()
      //---------------------------------------------------------------------------
      async tpcEnd(xid, flags) {
        const message = new messages.TransactionSwitchMessage(this);
        message.operation = constants.TNS_TPC_TXN_DETACH;
        message.xid = xid;
        message.context = this.tpcContext;
        message.flags = flags;
        await this._protocol._processMessage(message);
        this.tpcContext = null;
      }
      //---------------------------------------------------------------------------
      // tpcPrepare()
      //---------------------------------------------------------------------------
      async tpcPrepare(xid) {
        const message = new messages.TransactionChangeStateMessage(this);
        message.operation = constants.TNS_TPC_TXN_PREPARE;
        message.xid = xid;
        message.context = this.tpcContext;
        await this._protocol._processMessage(message);
        if (message.state === constants.TNS_TPC_TXN_STATE_REQUIRES_COMMIT) {
          return true;
        } else if (message.state === constants.TNS_TPC_TXN_STATE_READ_ONLY) {
          return false;
        }
        errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, message.state);
      }
      //---------------------------------------------------------------------------
      // tpcRollback()
      //---------------------------------------------------------------------------
      async tpcRollback(xid) {
        const message = this.createTpcRollbackMessage(xid);
        await this._protocol._processMessage(message);
        if (message.state !== constants.TNS_TPC_TXN_STATE_ABORTED) {
          errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, message.state);
        }
      }
      //---------------------------------------------------------------------------
      // Ensure no sessionless transaction was started through server procedure
      //---------------------------------------------------------------------------
      _validateSessionlessState() {
        if (this._sessionlessData?.startedOnServer) {
          errors.throwErr(errors.ERR_SESSIONLESS_DIFFERING_METHODS);
        }
      }
      //---------------------------------------------------------------------------
      // Begin/Resume a sessionless transaction with provided transactionId
      //---------------------------------------------------------------------------
      async startSessionlessTransaction(transactionId, timeout, flags, deferRoundTrip) {
        this._validateSessionlessState();
        if (this._sessionlessData)
          errors.throwErr(errors.ERR_SESSIONLESS_ALREADY_ACTIVE);
        const message = new messages.TransactionSwitchMessage(this);
        message.xid = {
          globalTransactionId: transactionId,
          branchQualifier: "",
          formatId: constants.TNS_TPC_TRANS_SESSIONLESS_FORMAT
        };
        message.timeout = timeout;
        message.operation = constants.TNS_TPC_TXN_START;
        message.flags = constants.TNS_TPC_TRANS_SESSIONLESS | flags;
        if (deferRoundTrip) {
          message.messageType = constants.TNS_MSG_TYPE_PIGGYBACK;
          this._sessionlessData = {
            piggyback: message,
            pending: true
          };
        } else {
          await this._protocol._processMessage(message);
        }
      }
      //---------------------------------------------------------------------------
      // Suspend the active sessionless transaction
      //---------------------------------------------------------------------------
      async suspendSessionlessTransaction() {
        this._validateSessionlessState();
        if (!this._sessionlessData)
          errors.throwErr(errors.ERR_SESSIONLESS_INACTIVE);
        const message = new messages.TransactionSwitchMessage(this);
        message.operation = constants.TNS_TPC_TXN_DETACH;
        message.flags = constants.TNS_TPC_TRANS_SESSIONLESS;
        await this._protocol._processMessage(message);
      }
      //---------------------------------------------------------------------------
      // Returns the statement cache size for the statement cache maintained by
      // the connection object
      //---------------------------------------------------------------------------
      getStmtCacheSize() {
        return this.statementCache._maxSize;
      }
      setCallTimeout(timeout) {
        this._protocol.callTimeout = timeout;
      }
      getCallTimeout() {
        return this._protocol.callTimeout;
      }
      //---------------------------------------------------------------------------
      // Returns getTag. Actual tag returned by db must be a string.
      //---------------------------------------------------------------------------
      getTag() {
        return "";
      }
      getExternalName() {
        return this.externalName;
      }
      //---------------------------------------------------------------------------
      // Returns the Oracle Database instance name associated with the connection.
      //---------------------------------------------------------------------------
      getInstanceName() {
        return this.instanceName;
      }
      getInternalName() {
        return this.internalName;
      }
      //---------------------------------------------------------------------------
      // Returns the Logical Transaction ID (ltxid) associated with the connection.
      // Used with Oracle Database Transaction Guard feature.
      //---------------------------------------------------------------------------
      getLTXID() {
        return this._ltxid;
      }
      //---------------------------------------------------------------------------
      // Returns the Oracle Database domain name associated with the connection.
      //---------------------------------------------------------------------------
      getDbDomain() {
        return this.dbDomain;
      }
      //---------------------------------------------------------------------------
      // Returns the Oracle Database host name associated with the connection.
      //---------------------------------------------------------------------------
      getHostName() {
        return this.nscon.ntAdapter.hostName;
      }
      //---------------------------------------------------------------------------
      // Returns the Oracle Database port number associated with the connection.
      //---------------------------------------------------------------------------
      getPort() {
        return this.nscon.ntAdapter.port;
      }
      //---------------------------------------------------------------------------
      // Returns the protocol associated with the connection.
      //---------------------------------------------------------------------------
      getProtocol() {
        return this.nscon.ntAdapter.secure ? "TCPS" : "TCP";
      }
      //---------------------------------------------------------------------------
      // Returns the Oracle Database name associated with the connection.
      //---------------------------------------------------------------------------
      getDbName() {
        return this.dbName;
      }
      //---------------------------------------------------------------------------
      // Returns maximum number of cursors that can be opened in one session.
      //---------------------------------------------------------------------------
      getMaxOpenCursors() {
        return this.maxOpenCursors;
      }
      //---------------------------------------------------------------------------
      // Returns the maximum length of identifiers supported by the database to
      // which this connection has been established.
      //---------------------------------------------------------------------------
      getMaxIdentifierLength() {
        return this.maxIdentifierLength;
      }
      //---------------------------------------------------------------------------
      // Returns the Oracle Database service name associated with the connection.
      //---------------------------------------------------------------------------
      getServiceName() {
        return this.serviceName;
      }
      //---------------------------------------------------------------------------
      // Returns boolean based on this._protocol.txnInProgress value.
      //---------------------------------------------------------------------------
      getTransactionInProgress() {
        return this._protocol.txnInProgress;
      }
      //---------------------------------------------------------------------------
      // Returns the warning object.
      //---------------------------------------------------------------------------
      getWarning() {
        return this.warning;
      }
      //---------------------------------------------------------------------------
      // getQueue()
      //
      // Returns a queue for use with advanced queuing.
      //---------------------------------------------------------------------------
      getQueue(name, payloadTypeClass, payloadType) {
        return new ThinQueueImpl(this, name, payloadTypeClass, payloadType);
      }
    };
    module2.exports = ThinConnectionImpl;
  }
});

// node_modules/oracledb/lib/thin/pool.js
var require_pool3 = __commonJS({
  "node_modules/oracledb/lib/thin/pool.js"(exports2, module2) {
    "use strict";
    var PoolImpl = require_pool();
    var ThinConnectionImpl = require_connection3();
    var protocolUtil = require_utils();
    var errors = require_errors();
    var settings = require_settings();
    var util = require_util();
    var thinUtil = require_util2();
    var { getConnectionInfo } = require_networkSession();
    var crypto = require("crypto");
    var Timers = require("timers");
    var ThinPoolImpl = class extends PoolImpl {
      _init(params) {
        if (!params.homogeneous) {
          errors.throwErr(errors.ERR_NOT_IMPLEMENTED, "Heterogeneous Pooling");
        }
        if (!params.connectString) {
          errors.throwErr(errors.ERR_EMPTY_CONNECT_STRING);
        }
        thinUtil.checkCredentials(params);
        this._availableObjects = [];
        this._name = "node-thin";
        this._poolMin = params.poolMin;
        this._poolMax = params.poolMax;
        this._poolIncrement = params.poolIncrement;
        this._poolTimeout = params.poolTimeout;
        this._poolPingInterval = params.poolPingInterval;
        this._poolPingTimeout = params.poolPingTimeout;
        this._maxLifetimeSession = params.maxLifetimeSession || 0;
        this._stmtCacheSize = params.stmtCacheSize;
        this._userConfig = params;
        this._freeConnectionList = [];
        this._usedConnectionList = /* @__PURE__ */ new Set();
        this._password = params.password;
        this._walletPassword = params.walletPassword;
        this._walletContent = params.walletContent;
        this._obfuscatedPassword = [];
        this._obfuscatedWalletPassword = [];
        this._token = params.token;
        this._obfuscatedToken = [];
        this._privateKey = params.privateKey;
        this._obfuscatedPrivateKey = [];
        this._schedulerJob = null;
        this._poolCloseWaiter = null;
        this._pendingRequests = [];
        this._connsToDrop = [];
        this._bgCleaner = null;
        this._poolCloseCleaner = null;
        if (this._password !== void 0) {
          const obj = protocolUtil.setObfuscatedValue(this._password);
          this._password = obj.value;
          this._obfuscatedPassword = obj.obfuscatedValue;
          this._userConfig.password = null;
        }
        if (this._walletPassword !== void 0) {
          const obj = protocolUtil.setObfuscatedValue(this._walletPassword);
          this._walletPassword = obj.value;
          this._obfuscatedWalletPassword = obj.obfuscatedValue;
          this._userConfig.walletPassword = null;
        }
        if (this._walletContent !== void 0) {
          const obj = protocolUtil.setObfuscatedValue(this._walletContent);
          this._walletContent = obj.value;
          this._obfuscatedWalletContent = obj.obfuscatedValue;
          this._userConfig.walletConent = null;
        }
        if (this._token !== void 0) {
          const obj = protocolUtil.setObfuscatedValue(this._token);
          this._token = obj.value;
          this._obfuscatedToken = obj.obfuscatedValue;
          this._userConfig.token = null;
        }
        if (this._privateKey !== void 0) {
          const obj = protocolUtil.setObfuscatedValue(this._privateKey);
          this._privateKey = obj.value;
          this._obfuscatedPrivateKey = obj.obfuscatedValue;
          this._userConfig.privateKey = null;
        }
        this._accessTokenFn = params.accessTokenFn;
        this._accessTokenConfig = params.accessTokenConfig;
        this._isDRCPEnabled = false;
        this._implicitPool = null;
      }
      //---------------------------------------------------------------------------
      // create pool with specified parameters and miminum number of connections as
      // specified by poolMin
      //---------------------------------------------------------------------------
      async create(params) {
        this._init(params);
        this._userConfig._connInfo = await getConnectionInfo(params);
        this._isDRCPEnabled = String(this._userConfig._connInfo[0]).toLowerCase() === "pooled";
        if (this._isDRCPEnabled && settings.connectionClass === "") {
          this._generateConnectionClass();
        }
        this.bgThreadFunc();
        this._bgConnCleaner();
      }
      //---------------------------------------------------------------------------
      // set new token and private key in pool
      //---------------------------------------------------------------------------
      setAccessToken(params) {
        if (params.token) {
          this._token = params.token;
          const objToken = protocolUtil.setObfuscatedValue(this._token);
          this._token = objToken.value;
          this._obfuscatedToken = objToken.obfuscatedValue;
        }
        if (params.privateKey) {
          this._privateKey = params.privateKey;
          const objKey = protocolUtil.setObfuscatedValue(this._privateKey);
          this._privateKey = objKey.value;
          this._obfuscatedPrivateKey = objKey.obfuscatedValue;
        }
      }
      //---------------------------------------------------------------------------
      // credentials are obfuscated and stored in an object(userConfig) during
      // pool creation. _getConnAttrs() method is used to deobfuscate encrypted
      // credentials for creating new connections
      //---------------------------------------------------------------------------
      async _getConnAttrs() {
        let accessToken;
        const clonedAttrs = Object.assign({}, this._userConfig);
        if (clonedAttrs.password === null) {
          clonedAttrs.password = protocolUtil.getDeobfuscatedValue(
            this._password,
            this._obfuscatedPassword
          );
        }
        if (clonedAttrs.walletPassword === null) {
          clonedAttrs.walletPassword = protocolUtil.getDeobfuscatedValue(
            this._walletPassword,
            this._obfuscatedWalletPassword
          );
        }
        if (clonedAttrs.walletContent === null) {
          clonedAttrs.walletContent = protocolUtil.getDeobfuscatedValue(
            this._walletContent,
            this._obfuscatedWalletContent
          );
        }
        if (clonedAttrs.token === null) {
          clonedAttrs.token = protocolUtil.getDeobfuscatedValue(this._token, this._obfuscatedToken);
          if (util.isTokenExpired(clonedAttrs.token)) {
            if (typeof this._accessTokenFn === "function") {
              try {
                accessToken = await this._accessTokenFn(true, this._accessTokenConfig);
              } catch (error) {
                errors.throwWrapErr(error, errors.ERR_ACCESS_TOKEN);
              }
              if (typeof accessToken === "string") {
                clonedAttrs.token = accessToken;
                if (util.isTokenExpired(clonedAttrs.token)) {
                  errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);
                } else {
                  const obj = protocolUtil.setObfuscatedValue(clonedAttrs.token);
                  this._token = obj.value;
                  this._obfuscatedToken = obj.obfuscatedValue;
                }
              } else if (typeof accessToken === "object") {
                clonedAttrs.token = accessToken.token;
                clonedAttrs.privateKey = util.denormalizePrivateKey(accessToken.privateKey);
                if (util.isTokenExpired(clonedAttrs.token)) {
                  errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);
                } else {
                  const objToken = protocolUtil.setObfuscatedValue(clonedAttrs.token);
                  this._token = objToken.value;
                  this._obfuscatedToken = objToken.obfuscatedValue;
                  const objKey = protocolUtil.setObfuscatedValue(clonedAttrs.privateKey);
                  this._privateKey = objKey.value;
                  this._obfuscatedPrivateKey = objKey.obfuscatedValue;
                }
              }
            } else {
              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);
            }
          }
        }
        if (clonedAttrs.privateKey === null) {
          clonedAttrs.privateKey = protocolUtil.getDeobfuscatedValue(
            this._privateKey,
            this._obfuscatedPrivateKey
          );
        }
        return clonedAttrs;
      }
      //---------------------------------------------------------------------------
      // return available connection if present in pool else
      // create new connection and return it
      //---------------------------------------------------------------------------
      async getConnection() {
        return await this.acquire();
      }
      //---------------------------------------------------------------------------
      // destroy connection when pool close operation is called
      //---------------------------------------------------------------------------
      async _destroy(connection) {
        try {
          if (connection.nscon.ntAdapter.connected) {
            connection._dropSess = true;
            await connection.close();
          }
        } catch (err) {
          return;
        }
      }
      //---------------------------------------------------------------------------
      // close pool by destroying available connections
      //---------------------------------------------------------------------------
      async close() {
        await new Promise((resolve3) => {
          this._poolCloseWaiter = resolve3;
          if (this.bgWaiter) {
            this.bgWaiter();
          }
        });
        if (this._schedulerJob) {
          clearTimeout(this._schedulerJob);
          this._schedulerJob = null;
        }
        for (const conn of this._freeConnectionList) {
          await this._destroy(conn);
        }
        for (const conn of this._usedConnectionList) {
          await this._destroy(conn);
        }
        await new Promise((resolve3) => {
          this._poolCloseCleaner = resolve3;
          if (this._bgCleaner)
            this._bgCleaner();
        });
      }
      //---------------------------------------------------------------------------
      // returns poolMax from configuration
      //---------------------------------------------------------------------------
      getPoolMax() {
        return this._poolMax;
      }
      //---------------------------------------------------------------------------
      // returns poolMin from configuration
      //---------------------------------------------------------------------------
      getPoolMin() {
        return this._poolMin;
      }
      //---------------------------------------------------------------------------
      // get number of used connection
      //---------------------------------------------------------------------------
      getConnectionsInUse() {
        return this._usedConnectionList.size;
      }
      //---------------------------------------------------------------------------
      // get number of free connection
      //---------------------------------------------------------------------------
      getConnectionsOpen() {
        return this._freeConnectionList.length + this._usedConnectionList.size;
      }
      //---------------------------------------------------------------------------
      // returns poolIncrement from configuration
      //---------------------------------------------------------------------------
      getPoolIncrement() {
        return this._poolIncrement;
      }
      //---------------------------------------------------------------------------
      // returns maximum number of connections allowed per shard in the pool
      //---------------------------------------------------------------------------
      getPoolMaxPerShard() {
        return;
      }
      //---------------------------------------------------------------------------
      // returns the pool ping interval (seconds)
      //---------------------------------------------------------------------------
      getPoolPingInterval() {
        return this._poolPingInterval;
      }
      //---------------------------------------------------------------------------
      // returns the pool ping Timeout (milliseconds)
      //---------------------------------------------------------------------------
      getPoolPingTimeout() {
        return this._poolPingTimeout;
      }
      //---------------------------------------------------------------------------
      // returns the pool timeout
      //---------------------------------------------------------------------------
      getPoolTimeout() {
        return this._poolTimeout;
      }
      //---------------------------------------------------------------------------
      // returns the pool max lifetime for a session  (seconds)
      //---------------------------------------------------------------------------
      getMaxLifetimeSession() {
        return this._maxLifetimeSession;
      }
      //---------------------------------------------------------------------------
      // returns whether the SODA metadata cache is enabled or not
      //---------------------------------------------------------------------------
      getSodaMetaDataCache() {
        return;
      }
      //---------------------------------------------------------------------------
      // returns the statement cache size associate with the pool
      //---------------------------------------------------------------------------
      getStmtCacheSize() {
        return this._stmtCacheSize;
      }
      //---------------------------------------------------------------------------
      // _setScheduler()
      //
      // set scheduler to scan and remove idle connections
      //---------------------------------------------------------------------------
      _setScheduler() {
        if (!this._schedulerJob && this._poolTimeout > 0 && this._freeConnectionList.length > 0 && this._freeConnectionList.length + this._usedConnectionList.size > this._poolMin) {
          this._schedulerJob = setTimeout(() => {
            this._scanIdleConnection();
          }, this._poolTimeout * 1e3);
        }
      }
      //---------------------------------------------------------------------------
      // scanIdleConnection()
      //
      // scan connection list and removes idle connections from pool
      //---------------------------------------------------------------------------
      _scanIdleConnection() {
        while (this._usedConnectionList.size + this._freeConnectionList.length > this._poolMin && this._freeConnectionList.length > 0) {
          const conn = this._freeConnectionList[0];
          if (Date.now() - conn._lastTimeUsed < this._poolTimeout * 1e3) {
            break;
          }
          this._connsToDrop.push(conn);
          this._freeConnectionList.shift();
        }
        if (this._bgCleaner)
          this._bgCleaner();
        this._schedulerJob = null;
        this._setScheduler();
      }
      //---------------------------------------------------------------------------
      // _getNumConnsToCreate()
      //
      // get number of connections need to be created
      //---------------------------------------------------------------------------
      _getNumConnsToCreate() {
        const usedConns = this._freeConnectionList.length + this._usedConnectionList.size;
        if (usedConns < this._poolMin) {
          return this._poolMin - usedConns;
        } else if (this._pendingRequests.length > 0) {
          return Math.min(this._poolIncrement, this._poolMax - usedConns);
        } else {
          return 0;
        }
      }
      //---------------------------------------------------------------------------
      // bgThreadFunc()
      //
      // method which runs in a background thread and is used to create connections.
      // When first started, it creates poolMin connections. After that, it creates
      // poolIncrement connections up to the value of poolMax when needed.
      // The thread terminates automatically when the pool is closed.
      //---------------------------------------------------------------------------
      async bgThreadFunc() {
        while (!this._poolCloseWaiter) {
          const numToCreate = this._getNumConnsToCreate();
          for (let i = 0; i < numToCreate; i++) {
            try {
              const config = await this._getConnAttrs();
              const conn = new ThinConnectionImpl();
              conn._pool = this;
              await conn.connect(config);
              conn._newSession = true;
              conn._dropSess = false;
              conn._creationTime = Date.now();
              conn._lastTimeUsed = Date.now();
              this._freeConnectionList.push(conn);
            } catch (err) {
              this._bgErr = err;
            }
            if (this._poolIncrement > 1 && this._poolMax - this._usedConnectionList.size - this._freeConnectionList.length > 1) {
              this._setScheduler();
            }
            if (this._pendingRequests.length > 0) {
              const payload = this._pendingRequests.shift();
              payload.resolve();
            }
            await new Promise((resolve3) => Timers.setImmediate(resolve3));
            if (this._poolCloseWaiter) {
              break;
            }
          }
          if (this._poolCloseWaiter) {
            break;
          }
          if ((this._pendingRequests.length == 0 || this._bgErr) && this.getConnectionsOpen() >= this._poolMin) {
            await new Promise((resolve3) => {
              this.bgWaiter = resolve3;
            });
            this.bgWaiter = null;
          }
        }
        this._poolCloseWaiter();
      }
      //---------------------------------------------------------------------------
      // _bgConnCleaner()
      // Method which stays in the stack and performs cleanup whenever a connection
      // gets added for cleanup to _connsToDrop
      // acquire a connection from connection pool
      //---------------------------------------------------------------------------
      async _bgConnCleaner() {
        while (!this._poolCloseCleaner) {
          if (this._connsToDrop.length == 0)
            await new Promise((resolve3) => this._bgCleaner = resolve3);
          while (this._connsToDrop.length)
            await this._destroy(this._connsToDrop.pop());
        }
        this._poolCloseCleaner();
      }
      //---------------------------------------------------------------------------
      // acquire()
      //
      // acquire a connection from connection pool
      //---------------------------------------------------------------------------
      async acquire() {
        while (this._freeConnectionList.length > 0) {
          const conn2 = this._freeConnectionList.pop();
          if (!this._shouldRetainInPool(conn2)) {
            this._invokeBgCleaner(conn2);
            continue;
          }
          let requiresPing = false;
          if (this._poolPingInterval === 0) {
            requiresPing = true;
          } else if (this._poolPingInterval > 0) {
            const elapsed = Date.now() - conn2._lastTimeUsed;
            if (elapsed > this._poolPingInterval * 1e3)
              requiresPing = true;
          }
          if (requiresPing) {
            let pingTimer;
            try {
              if (this._poolPingTimeout) {
                pingTimer = setTimeout(() => {
                  conn2.nscon.forceDisconnect();
                }, this._poolPingTimeout);
              }
              await conn2.ping();
            } catch {
              conn2.nscon.forceDisconnect();
              continue;
            } finally {
              clearTimeout(pingTimer);
            }
          }
          this._usedConnectionList.add(conn2);
          return conn2;
        }
        await new Promise((resolve3) => {
          this._pendingRequests.push({ resolve: resolve3 });
          if (this.bgWaiter) {
            this.bgWaiter();
          }
        });
        if (this._bgErr) {
          const err = this._bgErr;
          this._bgErr = null;
          if (this._pendingRequests.length > 0 && this.bgWaiter) {
            this.bgWaiter();
          }
          throw err;
        }
        const conn = this._freeConnectionList.pop();
        this._usedConnectionList.add(conn);
        return conn;
      }
      // release connection to connection pool
      release(conn) {
        conn.warning = void 0;
        this._usedConnectionList.delete(conn);
        if (conn.nscon.connected) {
          conn._lastTimeUsed = Date.now();
          conn._newSession = false;
          if (this.getConnectionsOpen() < this._poolMax && this._shouldRetainInPool(conn)) {
            this._freeConnectionList.push(conn);
          } else {
            this._invokeBgCleaner(conn);
          }
        }
        this._setScheduler();
      }
      //---------------------------------------------------------------------------
      // _generateConnectionClass()
      //
      // generate connection class for drcp if none is provided by user
      //---------------------------------------------------------------------------
      _generateConnectionClass() {
        this._userConfig.connectionClass = crypto.randomBytes(16).toString("base64");
        this._userConfig.connectionClass = "NJS:" + this._userConfig.connectionClass;
      }
      //---------------------------------------------------------------------------
      // reconfigure()
      //
      // Reconfigures the pool with new parameters
      //---------------------------------------------------------------------------
      reconfigure(params) {
        if (params.poolIncrement !== void 0) {
          this._poolIncrement = params.poolIncrement;
        }
        if (params.poolTimeout !== void 0 && this._poolTimeout !== params.poolTimeout) {
          this._poolTimeout = params.poolTimeout;
          if (this._schedulerJob) {
            clearTimeout(this._schedulerJob);
            this._schedulerJob = null;
          }
        }
        if (params.poolPingInterval !== void 0) {
          this._poolPingInterval = params.poolPingInterval;
        }
        if (params.stmtCacheSize !== void 0) {
          this._stmtCacheSize = params.stmtCacheSize;
        }
        if (params.poolMax !== void 0) {
          this._poolMax = params.poolMax;
        }
        if (params.poolMin !== void 0) {
          this._poolMin = params.poolMin;
        }
        if (params.maxLifetimeSession !== void 0) {
          this._maxLifetimeSession = params.maxLifetimeSession;
        }
        let numToDestroy = this.getConnectionsOpen() - this._poolMax;
        while (this._freeConnectionList.length && numToDestroy > 0) {
          const conn = this._freeConnectionList.pop();
          this._connsToDrop.push(conn);
          numToDestroy--;
        }
        if (this._bgCleaner)
          this._bgCleaner();
      }
      //---------------------------------------------------------------------------
      // _invokeBgCleaner()
      //
      // drop conn and invoke the bgCleaner while also ensuring min connections
      //---------------------------------------------------------------------------
      _invokeBgCleaner(conn) {
        this._connsToDrop.push(conn);
        if (this._bgCleaner)
          this._bgCleaner();
        if (this.getConnectionsOpen() < this._poolMin && this.bgWaiter)
          this.bgWaiter();
      }
      //---------------------------------------------------------------------------
      // _shouldRetainInPool()
      //
      // returns true if the connection should be retained in pool
      //---------------------------------------------------------------------------
      _shouldRetainInPool(conn) {
        if (!conn.isHealthy())
          return false;
        if (this._maxLifetimeSession !== 0) {
          if (Date.now() - conn._creationTime > this._maxLifetimeSession * 1e3)
            return false;
        }
        return true;
      }
    };
    module2.exports = ThinPoolImpl;
  }
});

// node_modules/oracledb/lib/thin/index.js
var require_thin = __commonJS({
  "node_modules/oracledb/lib/thin/index.js"() {
    "use strict";
    var ThinConnectionImpl = require_connection3();
    var ThinResultSetImpl = require_resultSet();
    var ThinPoolImpl = require_pool3();
    var ThinLobImpl = require_lob3();
    var { ThinDbObjectImpl } = require_dbObject3();
    var impl = require_impl();
    impl.ConnectionImpl = ThinConnectionImpl;
    impl.ResultSetImpl = ThinResultSetImpl;
    impl.PoolImpl = ThinPoolImpl;
    impl.LobImpl = ThinLobImpl;
    impl.DbObjectImpl = ThinDbObjectImpl;
  }
});

// node_modules/oracledb/lib/oracledb.js
var require_oracledb = __commonJS({
  "node_modules/oracledb/lib/oracledb.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var nodbUtil = require_util();
    var errors = require_errors();
    var types = require_types();
    var impl = require_impl();
    var process2 = require("process");
    var util = require("util");
    var vs = process2.version.substring(1).split(".").map(Number);
    errors.assert(
      vs[0] > 14 || vs[0] === 14 && vs[1] >= 17,
      errors.ERR_NODE_TOO_OLD,
      nodbUtil.PACKAGE_JSON_VERSION,
      "14.17"
    );
    var AqDeqOptions = require_aqDeqOptions2();
    var AqEnqOptions = require_aqEnqOptions2();
    var AqMessage = require_aqMessage2();
    var protocolUtil = require_utils();
    var AqQueue = require_aqQueue2();
    var future = require_future();
    var traceHandler = require_traceHandler();
    var BaseDbObject = require_dbObject2();
    var Connection = require_connection2();
    var Lob = require_lob2();
    var Pool = require_pool2();
    var PoolStatistics = require_poolStatistics();
    var ResultSet = require_resultset2();
    var settings = require_settings();
    var SodaDatabase = require_sodaDatabase2();
    var SodaCollection = require_sodaCollection2();
    var SodaDocCursor = require_sodaDocCursor2();
    var SodaDocument = require_sodaDocument2();
    var SodaOperation = require_sodaOperation2();
    var poolCache = {};
    var tempUsedPoolAliases = {};
    var defaultPoolAlias = "default";
    var registeredHooks = [];
    var registeredConfigProviderHooks = /* @__PURE__ */ new Map();
    var configProviderCache;
    var _initOracleClientArgs;
    function _initCLib(options) {
      const nodeVer = typeof process2 !== "undefined" && process2.versions?.node;
      const requireBinary = nodeVer ? typeof __webpack_require__ === "function" ? __non_webpack_require__ : require : void 0;
      const binaryLocations = [
        "../" + nodbUtil.RELEASE_DIR + "/" + nodbUtil.BINARY_FILE,
        // pre-built binary
        "../" + nodbUtil.RELEASE_DIR + "/" + nodbUtil.BUILD_FILE,
        // binary built from source
        "../build/Debug/" + nodbUtil.BUILD_FILE,
        // debug binary
        // Paths for Webpack.
        // Note: to use node-oracledb Thick mode, you will need a Webpack copy plugin to
        // copy 'node_modules/oracledb/build/' to the output directory,
        // see https://github.com/oracle/node-oracledb/issues/1156
        // If you want to use only node-oracledb Thin mode, a copy plugin is not needed.
        "./node_modules/oracledb/" + nodbUtil.RELEASE_DIR + "/" + nodbUtil.BINARY_FILE,
        "./node_modules/oracledb/" + nodbUtil.RELEASE_DIR + "/" + nodbUtil.BUILD_FILE
      ];
      if (options.binaryDir !== void 0) {
        binaryLocations.splice(
          0,
          0,
          options.binaryDir + "/" + nodbUtil.BINARY_FILE,
          options.binaryDir + "/" + nodbUtil.BUILD_FILE
        );
      }
      let oracledbCLib;
      for (let i = 0; i < binaryLocations.length; i++) {
        try {
          oracledbCLib = requireBinary(binaryLocations[i]);
          break;
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND" || i == binaryLocations.length - 1) {
            let nodeInfo;
            if (err.code === "MODULE_NOT_FOUND") {
              nodeInfo = `
  Looked for ${binaryLocations.map((x) => require("path").resolve(__dirname, x)).join(", ")}
  ${nodbUtil.getInstallURL()}
`;
            } else {
              nodeInfo = `
  Node.js require('oracledb') error was:
  ${err.message}
  ${nodbUtil.getInstallHelp()}
`;
            }
            errors.throwErr(errors.ERR_CANNOT_LOAD_BINARY, nodeInfo);
          }
        }
      }
      return oracledbCLib;
    }
    function _initializeThinDriver() {
      require_thin();
    }
    async function _verifyOptions(options, inCreatePool) {
      const outOptions = {};
      options = await _checkConfigProvider(options);
      if (options.user !== void 0) {
        errors.assertParamPropValue(typeof options.user === "string", 1, "user");
        outOptions.user = options.user;
      }
      if (options.username !== void 0) {
        errors.assert(outOptions.user === void 0, errors.ERR_DBL_USER);
        errors.assertParamPropValue(
          typeof options.username === "string",
          1,
          "username"
        );
        outOptions.user = options.username;
      }
      if (options.password !== void 0) {
        errors.assertParamPropValue(
          typeof options.password === "string",
          1,
          "password"
        );
        outOptions.password = options.password;
      }
      if (options.connectString !== void 0) {
        errors.assertParamPropValue(
          typeof options.connectString === "string",
          1,
          "connectString"
        );
        outOptions.connectString = options.connectString;
      }
      if (options.connectionString !== void 0) {
        errors.assert(
          outOptions.connectString === void 0,
          errors.ERR_DBL_CONNECT_STRING
        );
        errors.assertParamPropValue(
          typeof options.connectionString === "string",
          1,
          "connectionString"
        );
        outOptions.connectString = options.connectionString;
      }
      if (options.walletPassword !== void 0) {
        errors.assertParamPropValue(
          typeof options.walletPassword === "string",
          1,
          "walletPassword"
        );
        outOptions.walletPassword = options.walletPassword;
      }
      if (options.walletLocation !== void 0) {
        errors.assertParamPropValue(
          typeof options.walletLocation === "string",
          1,
          "walletLocation"
        );
        outOptions.walletLocation = options.walletLocation;
      }
      if (options.networkCompression !== void 0) {
        errors.assertParamPropValue(
          typeof options.networkCompression === "boolean",
          1,
          "networkCompression"
        );
        outOptions.networkCompression = options.networkCompression;
        outOptions.networkCompressionLevels = [];
        outOptions.networkCompressionLevels.push("high");
      }
      if (options.networkCompressionThreshold !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.networkCompressionThreshold), 1, "networkCompressionThreshold");
        outOptions.networkCompressionThreshold = options.networkCompressionThreshold;
      }
      if (options.walletContent !== void 0) {
        errors.assertParamPropValue(
          typeof options.walletContent === "string",
          1,
          "walletContent"
        );
        outOptions.walletContent = options.walletContent;
      }
      if (options.edition !== void 0) {
        errors.assertParamPropValue(
          typeof options.edition === "string",
          1,
          "edition"
        );
        outOptions.edition = options.edition;
      }
      if (options.stmtCacheSize !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.stmtCacheSize) && options.stmtCacheSize >= 0, 1, "stmtCacheSize");
        outOptions.stmtCacheSize = options.stmtCacheSize;
      }
      outOptions.externalAuth = settings.externalAuth;
      if (options.externalAuth !== void 0) {
        errors.assertParamPropValue(
          typeof options.externalAuth === "boolean",
          1,
          "externalAuth"
        );
        outOptions.externalAuth = options.externalAuth;
      }
      if (options.events !== void 0) {
        errors.assertParamPropValue(
          typeof options.events === "boolean",
          1,
          "events"
        );
        outOptions.events = options.events;
      }
      if (options.poolAlias !== void 0) {
        errors.assertParamPropValue(typeof options.poolAlias === "string" && options.poolAlias.length > 0, 1, "poolAlias");
        outOptions.poolAlias = options.poolAlias;
      }
      if (options.configDir !== void 0) {
        errors.assertParamPropValue(
          typeof options.configDir === "string",
          1,
          "configDir"
        );
        outOptions.configDir = options.configDir;
      }
      if (options.sslServerCertDN !== void 0) {
        errors.assertParamPropValue(
          typeof options.sslServerCertDN === "string",
          1,
          "sslServerCertDN"
        );
        outOptions.sslServerCertDN = options.sslServerCertDN;
      }
      if (options.sslServerDNMatch !== void 0) {
        errors.assertParamPropValue(
          typeof options.sslServerDNMatch === "boolean",
          1,
          "sslServerDNMatch"
        );
        outOptions.sslServerDNMatch = options.sslServerDNMatch;
      }
      if (options.sslAllowWeakDNMatch !== void 0) {
        errors.assertParamPropValue(
          typeof options.sslAllowWeakDNMatch === "boolean",
          1,
          "sslAllowWeakDNMatch"
        );
        outOptions.sslAllowWeakDNMatch = options.sslAllowWeakDNMatch;
      }
      if (options.httpsProxy !== void 0) {
        errors.assertParamPropValue(
          typeof options.httpsProxy === "string",
          1,
          "httpsProxy"
        );
        outOptions.httpsProxy = options.httpsProxy;
      }
      if (options.httpsProxyPort !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.httpsProxyPort) && options.httpsProxyPort >= 0, 1, "httpsProxyPort");
        outOptions.httpsProxyPort = options.httpsProxyPort;
      }
      if (options.retryCount !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.retryCount) && options.retryCount >= 0, 1, "retryCount");
        outOptions.retryCount = options.retryCount;
      }
      if (options.retryDelay !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.retryDelay) && options.retryDelay >= 0, 1, "retryDelay");
        outOptions.retryDelay = options.retryDelay;
      }
      if (options.connectTimeout !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.connectTimeout) && options.connectTimeout >= 0, 1, "connectTimeout");
        outOptions.connectTimeout = options.connectTimeout;
      }
      if (options.transportConnectTimeout !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.transportConnectTimeout) && options.transportConnectTimeout >= 0, 1, "transportConnectTimeout");
        outOptions.transportConnectTimeout = options.transportConnectTimeout;
      }
      if (options.expireTime !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.expireTime) && options.expireTime >= 0, 1, "expireTime");
        outOptions.expireTime = options.expireTime;
      }
      if (options.sdu !== void 0) {
        errors.assertParamPropValue(Number.isInteger(options.sdu) && options.sdu > 0, 1, "sdu");
        outOptions.sdu = options.sdu;
      }
      if (options.connectionIdPrefix !== void 0) {
        errors.assertParamPropValue(
          typeof options.connectionIdPrefix === "string",
          1,
          "connectionIdPrefix"
        );
        outOptions.connectionIdPrefix = options.connectionIdPrefix;
      }
      if (options.privilege !== void 0) {
        errors.assertParamPropValue(
          nodbUtil.isPrivilege(options.privilege),
          1,
          "privilege"
        );
        outOptions.privilege = options.privilege;
      }
      if (options.machine !== void 0) {
        nodbUtil.assertParamPropNetworkName(options, 1, "machine");
        outOptions.machine = options.machine;
      }
      if (options.osUser !== void 0) {
        nodbUtil.assertParamPropNetworkName(options, 1, "osUser");
        outOptions.osUser = options.osUser;
      }
      if (options.driverName !== void 0) {
        errors.assertParamPropValue(
          typeof options.driverName === "string",
          1,
          "driverName"
        );
        outOptions.driverName = options.driverName;
      }
      if (options.program !== void 0) {
        nodbUtil.assertParamPropNetworkName(options, 1, "program");
        outOptions.program = options.program;
      }
      if (options.terminal !== void 0) {
        errors.assertParamPropValue(
          typeof options.terminal === "string",
          1,
          "terminal"
        );
        outOptions.terminal = options.terminal;
      }
      if (options.useSNI !== void 0) {
        errors.assertParamPropValue(
          typeof options.useSNI === "boolean",
          1,
          "useSNI"
        );
        outOptions.useSNI = options.useSNI;
      }
      if (options.appContext !== void 0) {
        const value = options.appContext;
        errors.assertParamPropValue(
          nodbUtil.isAppContext(value),
          1,
          "appContext"
        );
        outOptions.appContext = options.appContext;
      }
      if (inCreatePool) {
        if (options.poolMax !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.poolMax) && options.poolMax > 0, 1, "poolMax");
          outOptions.poolMax = options.poolMax;
        }
        if (options.poolMaxPerShard !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.poolMaxPerShard) && options.poolMaxPerShard >= 0, 1, "poolMaxPerShard");
          outOptions.poolMaxPerShard = options.poolMaxPerShard;
        }
        if (options.poolMin !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.poolMin) && options.poolMin >= 0, 1, "poolMin");
          outOptions.poolMin = options.poolMin;
        }
        if (options.poolIncrement !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.poolIncrement) && options.poolIncrement >= 0, 1, "poolIncrement");
          outOptions.poolIncrement = options.poolIncrement;
        }
        if (options.poolTimeout !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.poolTimeout) && options.poolTimeout >= 0, 1, "poolTimeout");
          outOptions.poolTimeout = options.poolTimeout;
        }
        if (options.poolPingInterval !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.poolPingInterval) && options.poolPingInterval >= -2147483648 && options.poolPingInterval <= 2147483647, 1, "poolPingInterval");
          outOptions.poolPingInterval = options.poolPingInterval;
        }
        if (options.poolPingTimeout !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.poolPingTimeout) && options.poolPingTimeout >= 0, 1, "poolPingTimeout");
          outOptions.poolPingTimeout = options.poolPingTimeout;
        }
        if (options.maxLifetimeSession !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.maxLifetimeSession) && options.maxLifetimeSession >= 0, 1, "maxLifetimeSession");
          outOptions.maxLifetimeSession = options.maxLifetimeSession;
        }
        outOptions.homogeneous = true;
        if (options.homogeneous !== void 0) {
          errors.assertParamPropValue(
            typeof options.homogeneous === "boolean",
            1,
            "homogeneous"
          );
          outOptions.homogeneous = options.homogeneous;
        }
        if (options.queueTimeout !== void 0) {
          errors.assertParamPropValue(Number.isInteger(options.queueTimeout) && options.queueTimeout >= 0, 1, "queueTimeout");
          outOptions.queueTimeout = options.queueTimeout;
        }
        if (options.queueMax !== void 0) {
          errors.assertParamPropValue(
            Number.isInteger(options.queueMax),
            1,
            "queueMax"
          );
          outOptions.queueMax = options.queueMax;
        }
        outOptions.sodaMetaDataCache = false;
        if (options.sodaMetaDataCache !== void 0) {
          errors.assertParamPropValue(typeof options.sodaMetaDataCache === "boolean", 1, "sodaMetaDataCache");
          outOptions.sodaMetaDataCache = options.sodaMetaDataCache;
        }
        if (options.sessionCallback !== void 0) {
          errors.assertParamPropValue(typeof options.sessionCallback === "string" || typeof options.sessionCallback === "function", 1, "sessionCallback");
          outOptions.sessionCallback = options.sessionCallback;
        }
        outOptions.enableStatistics = false;
        if (options.enableStatistics !== void 0) {
          errors.assertParamPropValue(typeof options.enableStatistics === "boolean", 1, "enableStatistics");
          outOptions.enableStatistics = options.enableStatistics;
        }
        if (!outOptions.enableStatistics && options._enableStats !== void 0) {
          errors.assertParamPropValue(
            typeof options._enableStats === "boolean",
            1,
            "_enableStats"
          );
          outOptions.enableStatistics = options._enableStats;
        }
      } else {
        if (options.newPassword !== void 0) {
          errors.assertParamPropValue(
            typeof options.newPassword === "string",
            1,
            "newPassword"
          );
          outOptions.newPassword = options.newPassword;
        }
        if (options.shardingKey !== void 0) {
          const value = options.shardingKey;
          errors.assertParamPropValue(
            nodbUtil.isShardingKey(value),
            1,
            "shardingKey"
          );
          outOptions.shardingKey = options.shardingKey;
        }
        if (options.superShardingKey !== void 0) {
          const value = options.superShardingKey;
          errors.assertParamPropValue(
            nodbUtil.isShardingKey(value),
            1,
            "superShardingKey"
          );
          outOptions.superShardingKey = options.superShardingKey;
        }
      }
      if (options.accessToken !== void 0) {
        errors.assert(outOptions.user === void 0 && outOptions.password === void 0, errors.ERR_TOKEN_BASED_AUTH);
        if (inCreatePool) {
          errors.assert(
            outOptions.homogeneous && outOptions.externalAuth,
            errors.ERR_POOL_TOKEN_BASED_AUTH
          );
        } else {
          errors.assert(outOptions.externalAuth, errors.ERR_CONN_TOKEN_BASED_AUTH);
        }
        let accessToken;
        if (typeof options.accessToken === "function") {
          outOptions.accessTokenFn = options.accessToken;
          outOptions.accessTokenConfig = options.accessTokenConfig;
          try {
            accessToken = await options.accessToken(false, outOptions.accessTokenConfig);
            if (!nodbUtil.isTokenValid(accessToken)) {
              accessToken = await options.accessToken(true, outOptions.accessTokenConfig);
            }
          } catch (error) {
            errors.throwWrapErr(error, errors.ERR_ACCESS_TOKEN);
          }
        } else {
          accessToken = options.accessToken;
        }
        errors.assert(
          nodbUtil.isTokenValid(accessToken),
          errors.ERR_TOKEN_HAS_EXPIRED
        );
        if (accessToken.privateKey !== void 0) {
          errors.assert(typeof accessToken.privateKey === "string", errors.ERR_TOKEN_BASED_AUTH);
          accessToken.privateKey = nodbUtil.denormalizePrivateKey(accessToken.privateKey);
        }
        if (typeof accessToken === "string") {
          outOptions.token = accessToken;
        } else {
          outOptions.token = accessToken.token;
          outOptions.privateKey = accessToken.privateKey;
        }
      }
      if (outOptions.token === void 0 && outOptions.externalAuth) {
        if (outOptions.password) {
          errors.throwErr(errors.ERR_WRONG_CRED_FOR_EXTAUTH);
        }
        if (outOptions.user) {
          if (inCreatePool && !settings.thin) {
            errors.throwErr(errors.ERR_WRONG_CRED_FOR_EXTAUTH);
          } else if (outOptions.user[0] !== "[" || outOptions.user.slice(-1) !== "]") {
            errors.throwErr(errors.ERR_WRONG_USER_FORMAT_EXTAUTH_PROXY);
          }
        }
      }
      return outOptions;
    }
    async function createPool(options) {
      let poolAlias;
      errors.assertArgCount(arguments, 1, 1);
      errors.assertParamValue(nodbUtil.isObject(options), 1);
      for (const hookFn of registeredHooks) {
        try {
          await hookFn(options);
        } catch (error) {
          errors.throwWrapErr(error, errors.ERR_CALLOUT_FN);
        }
      }
      options = await _verifyOptions(options, true);
      const sessionCallback = options.sessionCallback;
      if (typeof sessionCallback === "function")
        delete options.sessionCallback;
      if (options.poolAlias !== void 0) {
        poolAlias = options.poolAlias;
      } else if (options.poolAlias === void 0 && !poolCache[defaultPoolAlias] && !tempUsedPoolAliases[defaultPoolAlias]) {
        poolAlias = defaultPoolAlias;
      }
      if (poolCache[poolAlias] || tempUsedPoolAliases[poolAlias]) {
        errors.throwErr(errors.ERR_POOL_WITH_ALIAS_ALREADY_EXISTS, poolAlias);
      }
      settings.addToOptions(
        options,
        "connectionClass",
        "driverName",
        "edition",
        "events",
        "externalAuth",
        "machine",
        "osUser",
        "stmtCacheSize",
        "poolMax",
        "poolMaxPerShard",
        "poolMin",
        "poolIncrement",
        "poolTimeout",
        "poolPingInterval",
        "poolPingTimeout",
        "program",
        "terminal",
        "queueMax",
        "queueTimeout"
      );
      if (options.poolMin > options.poolMax) {
        errors.throwErr(
          errors.ERR_INVALID_NUMBER_OF_CONNECTIONS,
          options.poolMax,
          options.poolMin
        );
      }
      if (_initOracleClientArgs === void 0 && !settings.thinDriverInitialized) {
        _initializeThinDriver();
      }
      if (poolAlias) {
        tempUsedPoolAliases[poolAlias] = true;
      }
      const pool = new Pool();
      pool._impl._connectString = options.connectString;
      pool._impl._user = options.user;
      try {
        await pool._impl.create(options);
      } finally {
        if (poolAlias) {
          delete tempUsedPoolAliases[poolAlias];
        }
      }
      if (poolAlias) {
        poolCache[poolAlias] = pool;
      }
      pool._setup(options, poolAlias);
      pool._sessionCallback = sessionCallback;
      pool.on("_afterPoolClose", () => {
        if (pool.poolAlias) {
          delete poolCache[pool.poolAlias];
        }
      });
      if (_initOracleClientArgs === void 0) {
        settings.thinDriverInitialized = true;
      }
      return pool;
    }
    async function getNetworkServiceNames(configDir) {
      const { NLParamParser, tnsnamesFilePath } = require_paramParser();
      const nlParamParser = new NLParamParser();
      const filePath = tnsnamesFilePath(configDir);
      const aliasht = await nlParamParser.initializeNlpa(filePath);
      const keysArr = [...aliasht.keys()];
      return keysArr;
    }
    async function getConnection(a1) {
      let options = {};
      let poolAlias;
      errors.assertArgCount(arguments, 0, 1);
      if (arguments.length == 0) {
        poolAlias = defaultPoolAlias;
      } else if (typeof a1 === "string") {
        poolAlias = a1;
      } else {
        options = a1;
        errors.assertParamValue(nodbUtil.isObject(options), 1);
        poolAlias = options.poolAlias;
      }
      if (poolAlias) {
        const pool = poolCache[poolAlias];
        errors.assert(pool, errors.ERR_POOL_WITH_ALIAS_NOT_FOUND, poolAlias);
        return await pool.getConnection(options);
      }
      for (const hookFn of registeredHooks) {
        try {
          await hookFn(options);
        } catch (error) {
          errors.throwWrapErr(error, errors.ERR_CALLOUT_FN);
        }
      }
      options = await _verifyOptions(options, false);
      settings.addToOptions(
        options,
        "connectionClass",
        "driverName",
        "edition",
        "events",
        "externalAuth",
        "machine",
        "osUser",
        "program",
        "stmtCacheSize",
        "terminal"
      );
      if (_initOracleClientArgs === void 0 && !settings.thinDriverInitialized) {
        _initializeThinDriver();
      }
      const conn = new Connection();
      conn._impl = new impl.ConnectionImpl();
      conn._impl._connectString = options.connectString;
      conn._impl._user = options.user;
      await conn._impl.connect(options);
      if (_initOracleClientArgs === void 0) {
        settings.thinDriverInitialized = true;
      }
      return conn;
    }
    function getPool(poolAlias) {
      errors.assertArgCount(arguments, 0, 1);
      if (poolAlias) {
        errors.assertParamValue(typeof poolAlias === "string" || typeof poolAlias === "number", 1);
      }
      poolAlias = poolAlias || defaultPoolAlias;
      const pool = poolCache[poolAlias];
      if (!pool) {
        errors.throwErr(errors.ERR_POOL_WITH_ALIAS_NOT_FOUND, poolAlias);
      }
      return pool;
    }
    function initOracleClient(arg1) {
      let options = {};
      errors.assertArgCount(arguments, 0, 1);
      if (arg1 !== void 0) {
        errors.assertParamValue(nodbUtil.isObject(arg1), 1);
        options = { ...arg1 };
        errors.assertParamPropString(options, 1, "libDir");
        errors.assertParamPropString(options, 1, "configDir");
        errors.assertParamPropString(options, 1, "errorUrl");
        errors.assertParamPropString(options, 1, "driverName");
        errors.assertParamPropString(options, 1, "binaryDir");
      }
      if (settings.thinDriverInitialized) {
        errors.throwErr(errors.ERR_THIN_CONNECTION_ALREADY_CREATED);
      }
      if (_initOracleClientArgs === void 0) {
        const oracledbCLib = _initCLib(options);
        if (options.driverName === void 0)
          options.driverName = constants.DEFAULT_DRIVER_NAME + " thk";
        if (options.errorUrl === void 0)
          options.errorUrl = constants.DEFAULT_ERROR_URL;
        try {
          oracledbCLib.initOracleClient(options, impl, settings);
        } catch (err) {
          const newErr = errors.transformErr(err);
          if (newErr.code === "DPI-1047") {
            newErr.message += "\n" + nodbUtil.getInstallHelp();
          }
          throw newErr;
        }
        _initOracleClientArgs = arg1 || {};
      } else if (!util.isDeepStrictEqual(_initOracleClientArgs, options)) {
        errors.throwErr(errors.ERR_INIT_ORACLE_CLIENT_ARGS);
      }
      settings.thin = false;
    }
    async function shutdown(a1, a2) {
      let connAttr = {};
      let shutdownMode = constants.SHUTDOWN_MODE_DEFAULT;
      errors.assertArgCount(arguments, 0, 2);
      if (arguments.length == 2) {
        errors.assertParamValue(typeof a1 === "object", 1);
        errors.assertParamValue(typeof a2 === "number", 2);
        connAttr = a1;
        shutdownMode = a2;
      } else if (arguments.length == 1) {
        errors.assertParamValue(typeof a1 === "object", 1);
        connAttr = a1;
      }
      const dbConfig = {
        user: connAttr.user,
        password: connAttr.password,
        connectString: connAttr.connectString,
        connectionString: connAttr.connectionString,
        externalAuth: connAttr.externalAuth,
        privilege: constants.SYSOPER
      };
      const conn = await this.getConnection(dbConfig);
      await conn.shutdown(shutdownMode);
      if (shutdownMode != this.SHUTDOWN_MODE_ABORT) {
        await conn.execute("ALTER DATABASE CLOSE");
        await conn.execute("ALTER DATABASE DISMOUNT");
        await conn.shutdown(this.SHUTDOWN_MODE_FINAL);
      }
      await conn.close();
    }
    async function _setConfigParameters(obj, credential, configProvider) {
      const configObject = {};
      const pmSection = "njs";
      const params = obj[pmSection];
      for (const key in params) {
        const val = params[key];
        configObject[key] = val;
      }
      configObject.connectString = obj.connect_descriptor;
      configObject.configTTL = obj.config_time_to_live;
      if (!configObject.connectString)
        errors.throwErr(errors.ERR_CONFIG_PROVIDER_FAILED_TO_RETRIEVE_CONFIG, "connect_descriptor must be set");
      configObject.user = obj.user;
      if (obj.password) {
        configObject.password = await _retrieveParamValueFromVault(obj["password"], credential, configProvider);
      }
      if (obj.wallet_location) {
        configObject.walletContent = await _retrieveParamValueFromVault(obj["wallet_location"], credential, configProvider);
        if (!nodbUtil.isPemFile(configObject.walletContent))
          errors.throwErr(errors.ERR_WALLET_TYPE_NOT_SUPPORTED);
      }
      return configObject;
    }
    async function _retrieveParamValueFromVault(paramObj, credential, configProvider) {
      const paramMap = /* @__PURE__ */ new Map();
      const auth = paramObj.authentication;
      if (auth) {
        for (const key in auth) {
          if (key == "method")
            paramMap.set("authentication", auth[key]);
          const val = auth[key];
          paramMap.set(key.toLowerCase(), val);
        }
      }
      const args = {};
      if (paramObj.type == "base64") {
        console.log("WARNING: Base64 Encoding in a JSON Password should only be used in development environments");
        return Buffer.from(paramObj.value, "base64").toString("utf-8");
      } else if (paramObj.type == "text") {
        if (configProvider == "azurevault" || configProvider == "ocivault") {
          console.log("WARNING: Plain Text in a JSON Password should only be used in development environments");
          return paramObj.value;
        } else
          errors.throwErr(errors.ERR_CONFIG_PROVIDER_PARAM_TYPE, "password type text is only allowed in ocivault and azurevault");
      } else if (paramObj.type == "azurevault") {
        paramMap.set("azuresecreturl", paramObj.value);
        if (!(configProvider == "azure" || configProvider == "azurevault"))
          credential = null;
        const hookFn = registeredConfigProviderHooks["azurevault"];
        if (hookFn == void 0)
          errors.throwErr(errors.ERR_REGISTER_HOOKFN_CONFIGPROVIDER, "azurevault");
        args.credential = credential;
        args.paramMap = paramMap;
        const vaultReturn = await hookFn(args);
        const paramValue = vaultReturn[0];
        return paramValue;
      } else if (paramObj.type == "ocivault") {
        paramMap.set("ocidvault", paramObj.value);
        if (!(configProvider == "ociobject" || configProvider == "ocivault"))
          credential = null;
        const hookFn = registeredConfigProviderHooks["ocivault"];
        if (hookFn == void 0)
          errors.throwErr(errors.ERR_REGISTER_HOOKFN_CONFIGPROVIDER, "ocivault");
        const args2 = {};
        args2.credential = credential;
        args2.paramMap = paramMap;
        const vaultReturn = await hookFn(args2);
        const paramValue = vaultReturn[0];
        return paramValue;
      } else {
        errors.throwErr(errors.ERR_CONFIG_PROVIDER_PARAM_TYPE, "password/wallet_location");
      }
    }
    async function _checkConfigProvider(options) {
      let cacheEntriesDuration = settings.configProviderCacheTimeout * 1e3;
      let secondOpts, cachedConfigEntry;
      const url = options.connectString || options.connectionString;
      if (!url)
        return options;
      if (configProviderCache && (cachedConfigEntry = configProviderCache.get(url))) {
        const config = cachedConfigEntry.cacheOpts;
        if (config.configTTL)
          cacheEntriesDuration = config.configTTL * 1e3;
        if (Date.now() - cachedConfigEntry.timeAdded < cacheEntriesDuration) {
          secondOpts = { ...config };
          if (secondOpts.password)
            secondOpts.password = protocolUtil.getDeobfuscatedValue(secondOpts.password.value, secondOpts.password.obfuscatedValue);
          if (secondOpts.walletContent)
            secondOpts.walletContent = protocolUtil.getDeobfuscatedValue(secondOpts.walletContent.value, secondOpts.walletContent.obfuscatedValue);
        }
      }
      if (!secondOpts) {
        let parsedUrl = url;
        let urlExtendedPart;
        const baseRegex = new RegExp("^config-(?<provider>[A-Za-z0-9]+)(://)(?<provider_arg>[^?]+)");
        if (url.indexOf("?") != -1) {
          parsedUrl = url.substring(0, url.indexOf("?"));
          urlExtendedPart = url.substring(url.indexOf("?"), url.length);
        }
        const match = parsedUrl.match(baseRegex);
        if (match) {
          const provider = match.groups.provider;
          const provider_arg = match.groups.provider_arg;
          const hookFn = registeredConfigProviderHooks[provider];
          if (hookFn == void 0)
            errors.throwErr(errors.ERR_REGISTER_HOOKFN_CONFIGPROVIDER, provider);
          const args = {};
          args.provider_arg = provider_arg;
          args.urlExtendedPart = urlExtendedPart;
          try {
            const configProviderReturn = await hookFn(args);
            secondOpts = configProviderReturn[0];
            if (!configProviderCache) {
              configProviderCache = /* @__PURE__ */ new Map();
            }
            if (!secondOpts) {
              errors.throwErr(errors.ERR_CONFIG_PROVIDER_FAILED_TO_RETRIEVE_CONFIG, "no configuration found in " + provider);
            }
            if (provider != "azure")
              secondOpts = await _setConfigParameters(secondOpts, configProviderReturn[1], provider);
            const cacheOpts = { ...secondOpts };
            if (secondOpts.password)
              cacheOpts.password = protocolUtil.setObfuscatedValue(secondOpts.password);
            if (secondOpts.walletContent)
              cacheOpts.walletContent = protocolUtil.setObfuscatedValue(secondOpts.walletContent);
            configProviderCache.set(url, { cacheOpts, timeAdded: Date.now() });
          } catch (err) {
            errors.throwErr(errors.ERR_CONFIG_PROVIDER_FAILED_TO_RETRIEVE_CONFIG, err.message);
          }
        }
      }
      if (secondOpts) {
        options = modifyOptionsPrecedence(secondOpts, options);
      }
      return options;
    }
    function modifyOptionsPrecedence(cloudConfig, userConfig) {
      userConfig = { ...userConfig };
      if (!userConfig.user)
        userConfig.user = cloudConfig.user;
      if (!userConfig.password)
        userConfig.password = cloudConfig.password;
      if (cloudConfig.connectString) {
        userConfig.connectString = cloudConfig.connectString;
        userConfig.connectionString = void 0;
      }
      if (cloudConfig.walletContent)
        userConfig.walletContent = cloudConfig.walletContent;
      if (cloudConfig.poolMin)
        userConfig.poolMin = cloudConfig.poolMin;
      if (cloudConfig.poolMax)
        userConfig.poolMax = cloudConfig.poolMax;
      if (cloudConfig.poolIncrement)
        userConfig.poolIncrement = cloudConfig.poolIncrement;
      if (cloudConfig.poolTimeout)
        userConfig.poolTimeout = cloudConfig.poolTimeout;
      if (cloudConfig.poolPingInterval)
        userConfig.poolPingInterval = cloudConfig.poolPingInterval;
      if (cloudConfig.poolPingTimeout)
        userConfig.poolPingTimeout = cloudConfig.poolPingTimeout;
      if (cloudConfig.stmtCacheSize)
        userConfig.stmtCacheSize = cloudConfig.stmtCacheSize;
      if (cloudConfig.prefetchRows)
        userConfig.prefetchRows = cloudConfig.prefetchRows;
      if (cloudConfig.lobPrefetch)
        userConfig.lobPrefetch = cloudConfig.lobPrefetch;
      return userConfig;
    }
    async function startup(a1, a2) {
      let connAttr = {};
      let startupAttr = {};
      errors.assertArgCount(arguments, 0, 2);
      if (arguments.length == 2) {
        errors.assertParamValue(typeof a1 === "object", 1);
        errors.assertParamValue(typeof a2 === "object", 2);
        connAttr = a1;
        startupAttr = a2;
      } else if (arguments.length == 1) {
        errors.assertParamValue(typeof a1 === "object", 1);
        connAttr = a1;
      }
      const dbConfig = {
        user: connAttr.user,
        password: connAttr.password,
        connectString: connAttr.connectString,
        connectionString: connAttr.connectionString,
        externalAuth: connAttr.externalAuth,
        privilege: this.SYSOPER | this.SYSPRELIM
      };
      let conn = await this.getConnection(dbConfig);
      await conn.startup(startupAttr);
      await conn.close();
      dbConfig.privilege = this.SYSOPER;
      conn = await this.getConnection(dbConfig);
      await conn.execute("ALTER DATABASE MOUNT");
      await conn.execute("ALTER DATABASE OPEN");
      await conn.close();
    }
    function registerProcessConfigurationHook(fn) {
      errors.assertArgCount(arguments, 1, 1);
      errors.assertParamValue(typeof fn === "function", 1);
      registeredHooks.push(fn);
    }
    function registerConfigurationProviderHook(configProvider, fn) {
      errors.assertArgCount(arguments, 2, 2);
      errors.assertParamValue(typeof fn === "function", 1);
      errors.assertParamValue(typeof configProvider === "string", 1);
      registeredConfigProviderHooks[configProvider] = fn;
    }
    module2.exports = {
      // classes
      AqDeqOptions,
      AqEnqOptions,
      AqMessage,
      AqQueue,
      BaseDbObject,
      Connection,
      JsonId: types.JsonId,
      Lob,
      Pool,
      PoolStatistics,
      ResultSet,
      SodaDatabase,
      SodaCollection,
      SodaDocCursor,
      SodaDocument,
      SodaOperation,
      SparseVector: types.SparseVector,
      IntervalYM: types.IntervalYM,
      IntervalDS: types.IntervalDS,
      // top-level functions
      getConnection: nodbUtil.callbackify(nodbUtil.wrapFn(getConnection)),
      createPool: nodbUtil.callbackify(nodbUtil.wrapFn(createPool)),
      getNetworkServiceNames: nodbUtil.callbackify(nodbUtil.wrapFn(getNetworkServiceNames)),
      getPool,
      initOracleClient,
      registerProcessConfigurationHook,
      registerConfigurationProviderHook,
      shutdown: nodbUtil.callbackify(nodbUtil.wrapFn(shutdown)),
      startup: nodbUtil.callbackify(nodbUtil.wrapFn(startup)),
      // CQN operation codes
      CQN_OPCODE_ALL_OPS: constants.CQN_OPCODE_ALL_OPS,
      CQN_OPCODE_ALL_ROWS: constants.CQN_OPCODE_ALL_ROWS,
      CQN_OPCODE_ALTER: constants.CQN_OPCODE_ALTER,
      CQN_OPCODE_DELETE: constants.CQN_OPCODE_DELETE,
      CQN_OPCODE_DROP: constants.CQN_OPCODE_DROP,
      CQN_OPCODE_INSERT: constants.CQN_OPCODE_INSERT,
      CQN_OPCODE_UPDATE: constants.CQN_OPCODE_UPDATE,
      // database types
      DB_TYPE_BFILE: types.DB_TYPE_BFILE,
      DB_TYPE_BINARY_DOUBLE: types.DB_TYPE_BINARY_DOUBLE,
      DB_TYPE_BINARY_FLOAT: types.DB_TYPE_BINARY_FLOAT,
      DB_TYPE_BINARY_INTEGER: types.DB_TYPE_BINARY_INTEGER,
      DB_TYPE_BLOB: types.DB_TYPE_BLOB,
      DB_TYPE_BOOLEAN: types.DB_TYPE_BOOLEAN,
      DB_TYPE_CHAR: types.DB_TYPE_CHAR,
      DB_TYPE_CLOB: types.DB_TYPE_CLOB,
      DB_TYPE_CURSOR: types.DB_TYPE_CURSOR,
      DB_TYPE_DATE: types.DB_TYPE_DATE,
      DB_TYPE_INTERVAL_DS: types.DB_TYPE_INTERVAL_DS,
      DB_TYPE_INTERVAL_YM: types.DB_TYPE_INTERVAL_YM,
      DB_TYPE_JSON: types.DB_TYPE_JSON,
      DB_TYPE_LONG: types.DB_TYPE_LONG,
      DB_TYPE_LONG_NVARCHAR: types.DB_TYPE_LONG_NVARCHAR,
      DB_TYPE_LONG_RAW: types.DB_TYPE_LONG_RAW,
      DB_TYPE_NCHAR: types.DB_TYPE_NCHAR,
      DB_TYPE_NCLOB: types.DB_TYPE_NCLOB,
      DB_TYPE_NUMBER: types.DB_TYPE_NUMBER,
      DB_TYPE_NVARCHAR: types.DB_TYPE_NVARCHAR,
      DB_TYPE_OBJECT: types.DB_TYPE_OBJECT,
      DB_TYPE_RAW: types.DB_TYPE_RAW,
      DB_TYPE_ROWID: types.DB_TYPE_ROWID,
      DB_TYPE_TIMESTAMP: types.DB_TYPE_TIMESTAMP,
      DB_TYPE_TIMESTAMP_LTZ: types.DB_TYPE_TIMESTAMP_LTZ,
      DB_TYPE_TIMESTAMP_TZ: types.DB_TYPE_TIMESTAMP_TZ,
      DB_TYPE_VARCHAR: types.DB_TYPE_VARCHAR,
      DB_TYPE_XMLTYPE: types.DB_TYPE_XMLTYPE,
      DB_TYPE_VECTOR: types.DB_TYPE_VECTOR,
      // fetchInfo type defaulting
      DEFAULT: constants.DEFAULT,
      // statement types
      STMT_TYPE_UNKNOWN: constants.STMT_TYPE_UNKNOWN,
      STMT_TYPE_SELECT: constants.STMT_TYPE_SELECT,
      STMT_TYPE_UPDATE: constants.STMT_TYPE_UPDATE,
      STMT_TYPE_DELETE: constants.STMT_TYPE_DELETE,
      STMT_TYPE_INSERT: constants.STMT_TYPE_INSERT,
      STMT_TYPE_CREATE: constants.STMT_TYPE_CREATE,
      STMT_TYPE_DROP: constants.STMT_TYPE_DROP,
      STMT_TYPE_ALTER: constants.STMT_TYPE_ALTER,
      STMT_TYPE_BEGIN: constants.STMT_TYPE_BEGIN,
      STMT_TYPE_DECLARE: constants.STMT_TYPE_DECLARE,
      STMT_TYPE_CALL: constants.STMT_TYPE_CALL,
      STMT_TYPE_EXPLAIN_PLAN: constants.STMT_TYPE_EXPLAIN_PLAN,
      STMT_TYPE_MERGE: constants.STMT_TYPE_MERGE,
      STMT_TYPE_ROLLBACK: constants.STMT_TYPE_ROLLBACK,
      STMT_TYPE_COMMIT: constants.STMT_TYPE_COMMIT,
      // shutdown modes
      SHUTDOWN_MODE_DEFAULT: constants.SHUTDOWN_MODE_DEFAULT,
      SHUTDOWN_MODE_TRANSACTIONAL: constants.SHUTDOWN_MODE_TRANSACTIONAL,
      SHUTDOWN_MODE_TRANSACTIONAL_LOCAL: constants.SHUTDOWN_MODE_TRANSACTIONAL_LOCAL,
      SHUTDOWN_MODE_IMMEDIATE: constants.SHUTDOWN_MODE_IMMEDIATE,
      SHUTDOWN_MODE_ABORT: constants.SHUTDOWN_MODE_ABORT,
      SHUTDOWN_MODE_FINAL: constants.SHUTDOWN_MODE_FINAL,
      // startup modes
      STARTUP_MODE_DEFAULT: constants.STARTUP_MODE_DEFAULT,
      STARTUP_MODE_FORCE: constants.STARTUP_MODE_FORCE,
      STARTUP_MODE_RESTRICT: constants.STARTUP_MODE_RESTRICT,
      // subscription event types
      SUBSCR_EVENT_TYPE_SHUTDOWN: constants.SUBSCR_EVENT_TYPE_SHUTDOWN,
      SUBSCR_EVENT_TYPE_SHUTDOWN_ANY: constants.SUBSCR_EVENT_TYPE_SHUTDOWN_ANY,
      SUBSCR_EVENT_TYPE_STARTUP: constants.SUBSCR_EVENT_TYPE_STARTUP,
      SUBSCR_EVENT_TYPE_DEREG: constants.SUBSCR_EVENT_TYPE_DEREG,
      SUBSCR_EVENT_TYPE_OBJ_CHANGE: constants.SUBSCR_EVENT_TYPE_OBJ_CHANGE,
      SUBSCR_EVENT_TYPE_QUERY_CHANGE: constants.SUBSCR_EVENT_TYPE_QUERY_CHANGE,
      SUBSCR_EVENT_TYPE_AQ: constants.SUBSCR_EVENT_TYPE_AQ,
      // subscription grouping classes
      SUBSCR_GROUPING_CLASS_TIME: constants.SUBSCR_GROUPING_CLASS_TIME,
      // subscription grouping types
      SUBSCR_GROUPING_TYPE_SUMMARY: constants.SUBSCR_GROUPING_TYPE_SUMMARY,
      SUBSCR_GROUPING_TYPE_LAST: constants.SUBSCR_GROUPING_TYPE_LAST,
      // subscription namespaces
      SUBSCR_NAMESPACE_AQ: constants.SUBSCR_NAMESPACE_AQ,
      SUBSCR_NAMESPACE_DBCHANGE: constants.SUBSCR_NAMESPACE_DBCHANGE,
      // subscription quality of service flags
      SUBSCR_QOS_BEST_EFFORT: constants.SUBSCR_QOS_BEST_EFFORT,
      SUBSCR_QOS_DEREG_NFY: constants.SUBSCR_QOS_DEREG_NFY,
      SUBSCR_QOS_QUERY: constants.SUBSCR_QOS_QUERY,
      SUBSCR_QOS_RELIABLE: constants.SUBSCR_QOS_RELIABLE,
      SUBSCR_QOS_ROWIDS: constants.SUBSCR_QOS_ROWIDS,
      // privileges
      SYSASM: constants.SYSASM,
      SYSBACKUP: constants.SYSBACKUP,
      SYSDBA: constants.SYSDBA,
      SYSDG: constants.SYSDG,
      SYSKM: constants.SYSKM,
      SYSOPER: constants.SYSOPER,
      SYSPRELIM: constants.SYSPRELIM,
      SYSRAC: constants.SYSRAC,
      // bind directions
      BIND_IN: constants.BIND_IN,
      BIND_INOUT: constants.BIND_INOUT,
      BIND_OUT: constants.BIND_OUT,
      // outFormat values
      OUT_FORMAT_ARRAY: constants.OUT_FORMAT_ARRAY,
      OUT_FORMAT_OBJECT: constants.OUT_FORMAT_OBJECT,
      // SODA collection creation modes
      SODA_COLL_MAP_MODE: constants.SODA_COLL_MAP_MODE,
      // pool statuses
      POOL_STATUS_OPEN: constants.POOL_STATUS_OPEN,
      POOL_STATUS_DRAINING: constants.POOL_STATUS_DRAINING,
      POOL_STATUS_CLOSED: constants.POOL_STATUS_CLOSED,
      POOL_STATUS_RECONFIGURING: constants.POOL_STATUS_RECONFIGURING,
      // AQ dequeue wait options
      AQ_DEQ_NO_WAIT: constants.AQ_DEQ_NO_WAIT,
      AQ_DEQ_WAIT_FOREVER: constants.AQ_DEQ_WAIT_FOREVER,
      // AQ dequeue modes
      AQ_DEQ_MODE_BROWSE: constants.AQ_DEQ_MODE_BROWSE,
      AQ_DEQ_MODE_LOCKED: constants.AQ_DEQ_MODE_LOCKED,
      AQ_DEQ_MODE_REMOVE: constants.AQ_DEQ_MODE_REMOVE,
      AQ_DEQ_MODE_REMOVE_NO_DATA: constants.AQ_DEQ_MODE_REMOVE_NO_DATA,
      // AQ dequeue navigation flags
      AQ_DEQ_NAV_FIRST_MSG: constants.AQ_DEQ_NAV_FIRST_MSG,
      AQ_DEQ_NAV_NEXT_TRANSACTION: constants.AQ_DEQ_NAV_NEXT_TRANSACTION,
      AQ_DEQ_NAV_NEXT_MSG: constants.AQ_DEQ_NAV_NEXT_MSG,
      // AQ message delivery modes
      AQ_MSG_DELIV_MODE_PERSISTENT: constants.AQ_MSG_DELIV_MODE_PERSISTENT,
      AQ_MSG_DELIV_MODE_BUFFERED: constants.AQ_MSG_DELIV_MODE_BUFFERED,
      AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED: constants.AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED,
      // AQ message states
      AQ_MSG_STATE_READY: constants.AQ_MSG_STATE_READY,
      AQ_MSG_STATE_WAITING: constants.AQ_MSG_STATE_WAITING,
      AQ_MSG_STATE_PROCESSED: constants.AQ_MSG_STATE_PROCESSED,
      AQ_MSG_STATE_EXPIRED: constants.AQ_MSG_STATE_EXPIRED,
      // AQ visibility flags
      AQ_VISIBILITY_IMMEDIATE: constants.AQ_VISIBILITY_IMMEDIATE,
      AQ_VISIBILITY_ON_COMMIT: constants.AQ_VISIBILITY_ON_COMMIT,
      // TPC/XA begin flags Constants
      TPC_BEGIN_JOIN: constants.TPC_BEGIN_JOIN,
      TPC_BEGIN_NEW: constants.TPC_BEGIN_NEW,
      TPC_BEGIN_PROMOTE: constants.TPC_BEGIN_PROMOTE,
      TPC_BEGIN_RESUME: constants.TPC_BEGIN_RESUME,
      // TPC/XA two-phase commit flags
      TPC_END_NORMAL: constants.TPC_END_NORMAL,
      TPC_END_SUSPEND: constants.TPC_END_SUSPEND,
      // vector types
      VECTOR_FORMAT_FLOAT32: constants.VECTOR_FORMAT_FLOAT32,
      VECTOR_FORMAT_FLOAT64: constants.VECTOR_FORMAT_FLOAT64,
      VECTOR_FORMAT_INT8: constants.VECTOR_FORMAT_INT8,
      VECTOR_FORMAT_BINARY: constants.VECTOR_FORMAT_BINARY,
      // database type aliases
      BLOB: types.DB_TYPE_BLOB,
      BUFFER: types.DB_TYPE_RAW,
      CLOB: types.DB_TYPE_CLOB,
      CURSOR: types.DB_TYPE_CURSOR,
      DATE: types.DB_TYPE_TIMESTAMP,
      NCLOB: types.DB_TYPE_NCLOB,
      NUMBER: types.DB_TYPE_NUMBER,
      STRING: types.DB_TYPE_VARCHAR,
      // outFormat aliases
      ARRAY: constants.OUT_FORMAT_ARRAY,
      OBJECT: constants.OUT_FORMAT_OBJECT,
      // Trace Interface
      traceHandler,
      // Instances
      future,
      // property getters
      get autoCommit() {
        return settings.autoCommit;
      },
      get connectionClass() {
        return settings.connectionClass;
      },
      get dbObjectAsPojo() {
        return settings.dbObjectAsPojo;
      },
      get edition() {
        return settings.edition;
      },
      get errorOnConcurrentExecute() {
        return settings.errorOnConcurrentExecute;
      },
      get events() {
        return settings.events;
      },
      get externalAuth() {
        return settings.externalAuth;
      },
      get fetchArraySize() {
        return settings.fetchArraySize;
      },
      get fetchAsBuffer() {
        return settings.fetchAsBuffer;
      },
      get fetchAsString() {
        return settings.fetchAsString;
      },
      get fetchTypeHandler() {
        return settings.fetchTypeHandler;
      },
      get dbObjectTypeHandler() {
        return settings.dbObjectTypeHandler;
      },
      get lobPrefetchSize() {
        return settings.lobPrefetchSize;
      },
      get maxRows() {
        return settings.maxRows;
      },
      get oracleClientVersion() {
        return settings.oracleClientVersion;
      },
      get oracleClientVersionString() {
        return settings.oracleClientVersionString;
      },
      get outFormat() {
        return settings.outFormat;
      },
      get poolIncrement() {
        return settings.poolIncrement;
      },
      get poolMax() {
        return settings.poolMax;
      },
      get poolMaxPerShard() {
        return settings.poolMaxPerShard;
      },
      get poolMin() {
        return settings.poolMin;
      },
      get poolPingInterval() {
        return settings.poolPingInterval;
      },
      get poolPingTimeout() {
        return settings.poolPingTimeout;
      },
      get poolTimeout() {
        return settings.poolTimeout;
      },
      get prefetchRows() {
        return settings.prefetchRows;
      },
      get stmtCacheSize() {
        return settings.stmtCacheSize;
      },
      get configProviderCacheTimeout() {
        return settings.configProviderCacheTimeout;
      },
      get thin() {
        return settings.thin;
      },
      get version() {
        return constants.VERSION_MAJOR * 1e4 + constants.VERSION_MINOR * 100 + constants.VERSION_PATCH;
      },
      get versionString() {
        return constants.VERSION_STRING;
      },
      get versionSuffix() {
        return constants.VERSION_SUFFIX;
      },
      // property setters
      set autoCommit(value) {
        errors.assertPropValue(typeof value === "boolean", "autoCommit");
        settings.autoCommit = value;
      },
      set connectionClass(value) {
        errors.assertPropValue(typeof value === "string", "connectionClass");
        settings.connectionClass = value;
      },
      set dbObjectAsPojo(value) {
        errors.assertPropValue(typeof value === "boolean", "dbObjectAsPojo");
        settings.dbObjectAsPojo = value;
      },
      set driverName(value) {
        errors.assertPropValue(typeof value === "string", "driverName");
        settings.driverName = value;
      },
      set edition(value) {
        errors.assertPropValue(typeof value === "string", "edition");
        settings.edition = value;
      },
      set errorOnConcurrentExecute(value) {
        errors.assertPropValue(
          typeof value === "boolean",
          "errorOnConcurrentExecute"
        );
        settings.errorOnConcurrentExecute = value;
      },
      set events(value) {
        errors.assertPropValue(typeof value === "boolean", "events");
        settings.events = value;
      },
      set externalAuth(value) {
        errors.assertPropValue(typeof value === "boolean", "externalAuth");
        settings.externalAuth = value;
      },
      set fetchArraySize(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value > 0,
          "fetchArraySize"
        );
        settings.fetchArraySize = value;
      },
      set fetchAsBuffer(value) {
        errors.assertPropValue(Array.isArray(value), "fetchAsBuffer");
        settings.createFetchTypeMap(settings.fetchAsString, value);
        settings.fetchAsBuffer = value;
      },
      set fetchAsString(value) {
        errors.assertPropValue(Array.isArray(value), "fetchAsString");
        settings.createFetchTypeMap(value, settings.fetchAsBuffer);
        settings.fetchAsString = value;
      },
      set fetchTypeHandler(value) {
        if (value !== void 0) {
          errors.assertPropValue(typeof value === "function", "fetchTypeHandler");
        }
        settings.fetchTypeHandler = value;
      },
      set dbObjectTypeHandler(value) {
        if (value !== void 0) {
          errors.assertPropValue(typeof value === "function", "dbObjectTypeHandler");
        }
        settings.dbObjectTypeHandler = value;
      },
      set lobPrefetchSize(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "lobPrefetchSize"
        );
        settings.lobPrefetchSize = value;
      },
      set machine(value) {
        errors.assertPropValue(typeof value === "string", "machine");
        const sanitizedValue = nodbUtil.sanitize(value);
        errors.assertPropValue(value == sanitizedValue, "machine");
        settings.machine = value;
      },
      set maxRows(value) {
        errors.assertPropValue(Number.isInteger(value) && value >= 0, "maxRows");
        settings.maxRows = value;
      },
      set osUser(value) {
        errors.assertPropValue(typeof value === "string", "osUser");
        const sanitizedValue = nodbUtil.sanitize(value);
        errors.assertPropValue(value == sanitizedValue, "osUser");
        settings.osUser = value;
      },
      set outFormat(value) {
        if (value !== constants.OUT_FORMAT_ARRAY && value !== constants.OUT_FORMAT_OBJECT) {
          errors.throwErr(errors.ERR_INVALID_PROPERTY_VALUE, "outFormat");
        }
        settings.outFormat = value;
      },
      set poolIncrement(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "poolIncrement"
        );
        settings.poolIncrement = value;
      },
      set poolMax(value) {
        errors.assertPropValue(Number.isInteger(value) && value >= 0, "poolMax");
        settings.poolMax = value;
      },
      set poolMaxPerShard(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "poolMaxPerShard"
        );
        settings.poolMaxPerShard = value;
      },
      set poolMin(value) {
        errors.assertPropValue(Number.isInteger(value) && value >= 0, "poolMin");
        settings.poolMin = value;
      },
      set poolPingInterval(value) {
        errors.assertPropValue(Number.isInteger(value) && value < 2 ** 31 && value >= (-2) ** 31, "poolPingInterval");
        settings.poolPingInterval = value;
      },
      set poolPingTimeout(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "poolPingTimeout"
        );
        settings.poolPingTimeout = value;
      },
      set poolTimeout(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "poolTimeout"
        );
        settings.poolTimeout = value;
      },
      set prefetchRows(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "prefetchRows"
        );
        settings.prefetchRows = value;
      },
      set program(value) {
        errors.assertPropValue(typeof value === "string", "program");
        const sanitizedValue = nodbUtil.sanitize(value);
        errors.assertPropValue(value == sanitizedValue, "program");
        settings.program = value;
      },
      set stmtCacheSize(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "stmtCacheSize"
        );
        settings.stmtCacheSize = value;
      },
      set terminal(value) {
        errors.assertPropValue(typeof value === "string", "terminal");
        settings.terminal = value;
      },
      set configProviderCacheTimeout(value) {
        errors.assertPropValue(
          Number.isInteger(value) && value >= 0,
          "configProviderCacheTimeout"
        );
        settings.configProviderCacheTimeout = value;
      }
    };
  }
});

// node_modules/oracledb/index.js
var require_oracledb2 = __commonJS({
  "node_modules/oracledb/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_oracledb();
  }
});

// src/commands/selfUpdate.ts
var selfUpdate_exports = {};
__export(selfUpdate_exports, {
  selfUpdate: () => selfUpdate
});
async function selfUpdate() {
  try {
    console.log("\u{1F50D} Checking latest version...");
    const res = await fetch(
      `https://api.github.com/repos/${REPO}/releases/latest`,
      {
        headers: {
          "User-Agent": "bss-cli",
          "Accept": "application/vnd.github+json"
        }
      }
    );
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text);
    }
    const release = JSON.parse(text);
    if (!release || !release.assets) {
      console.log("\u274C No GitHub releases found.");
      console.log("Create a release first using publish script.");
      return;
    }
    const asset = release.assets.find(
      (a) => a.name.endsWith(".tgz")
    );
    if (!asset) {
      console.log("\u274C No .tgz file found in release assets.");
      return;
    }
    console.log(`\u2B06\uFE0F Updating to ${release.tag_name}...`);
    (0, import_child_process2.execSync)(`npm i -g ${asset.browser_download_url}`, {
      stdio: "inherit"
    });
    console.log("\u2705 Update complete!");
  } catch (err) {
    console.error("Update failed:", err.message || err);
  }
}
var import_child_process2, REPO;
var init_selfUpdate = __esm({
  "src/commands/selfUpdate.ts"() {
    "use strict";
    import_child_process2 = require("child_process");
    REPO = "bestsoftsolutions/bss-cli";
  }
});

// src/index.ts
var import_commander = require("commander");
var path7 = __toESM(require("path"), 1);

// src/templateGenerator.ts
var fs = __toESM(require("fs"), 1);
var path = __toESM(require("path"), 1);
var import_eta = require("eta");
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var eta = new import_eta.Eta({
  useWith: true
});
function copyTemplateStructure(srcDir, destDir, placeholders) {
  if (!fs.existsSync(destDir)) {
    fs.mkdirSync(destDir, { recursive: true });
  }
  const entries = fs.readdirSync(srcDir, { withFileTypes: true });
  for (const entry of entries) {
    let outName = entry.name;
    for (const [ph, val] of Object.entries(placeholders)) {
      outName = outName.replace(new RegExp(ph, "g"), val);
    }
    const srcPath = path.join(srcDir, entry.name);
    let destPath = path.join(destDir, outName.replace(/\.eta$/, ""));
    if (entry.isDirectory()) {
      copyTemplateStructure(srcPath, destPath, placeholders);
    } else if (entry.isFile()) {
      if (entry.name.endsWith(".eta")) {
        const template = fs.readFileSync(srcPath, "utf-8");
        const rendered = eta.renderString(template, placeholders) ?? "";
        fs.writeFileSync(destPath, rendered, "utf-8");
      } else {
        fs.writeFileSync(destPath, "", "utf-8");
      }
    }
  }
}
function generatePageFromTemplate(templateDir, outputDir, pageName) {
  copyTemplateStructure(templateDir, outputDir, {
    __page__: pageName,
    __Page__: capitalize(pageName),
    __PAGE__: pageName.toUpperCase()
  });
}
function compileTemplate(templatePath, data) {
  eta.configure({ views: path.dirname(templatePath) });
  const templateString = eta.renderString(fs.readFileSync(templatePath, "utf-8"), data);
  return templateString ?? "";
}
async function writeCompiledTemplate(templatePath, outputPath, data, placeholders) {
  const dir = path.dirname(outputPath);
  const filename = path.basename(outputPath);
  let outName = path.basename(outputPath);
  for (const [ph, val] of Object.entries(placeholders)) {
    outName = outName.replace(new RegExp(ph, "g"), val);
  }
  let destPath = path.join(dir, outName.replace(/\.eta$/, ""));
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  if (fs.existsSync(destPath)) {
    console.warn(`\u26A0\uFE0F  Warning: Overwriting existing file at ${destPath}`);
  }
  if (filename.endsWith(".eta")) {
    destPath = destPath.replace(/\.eta$/, "");
  }
  const compiled = compileTemplate(templatePath, {
    ...placeholders,
    ...data
  });
  fs.writeFileSync(destPath, compiled, "utf-8");
}

// src/axpertPageGenerator.ts
var import_path = __toESM(require("path"), 1);

// src/logger.ts
var level = "silent";
function setLogLevel(input) {
  if (input?.debug) level = "debug";
  else if (input?.verbose) level = "verbose";
  else level = "silent";
}
function log(msg) {
  if (level !== "silent") console.log(msg);
}
function debug(msg) {
  if (level === "debug") console.log(`[debug] ${msg}`);
}

// src/database.ts
var import_oracledb = __toESM(require_oracledb2(), 1);

// src/configLoader.ts
var fs2 = __toESM(require("fs"), 1);
var path2 = __toESM(require("path"), 1);
var CONFIG_FILE = "bss.config.json";
function saveConfig(config) {
  const configPath = path2.join(process.cwd(), CONFIG_FILE);
  fs2.writeFileSync(configPath, JSON.stringify(config, null, 2));
}
function loadConfig() {
  const configPath = path2.join(process.cwd(), CONFIG_FILE);
  if (!fs2.existsSync(configPath)) {
    throw new Error("bss.config.json not found. Run `init` first.");
  }
  return JSON.parse(fs2.readFileSync(configPath, "utf-8"));
}

// src/database.ts
async function getOracleConnection() {
  try {
    const config = loadConfig();
    const ORACLE_CONFIG = {
      user: config.db?.user ?? "",
      password: config.db?.password ?? "",
      connectString: config.db?.connectString ?? ""
    };
    const connection = await import_oracledb.default.getConnection(ORACLE_CONFIG);
    return connection;
  } catch (error) {
    console.error("Error connecting to Oracle:", error);
    process.exit(1);
  }
}
async function getTableSchema(conn, tableName) {
  const query = `
        SELECT 
            COLUMN_NAME,
            DATA_TYPE,
            DATA_LENGTH,
            DATA_PRECISION,
            DATA_SCALE,
            NULLABLE
        FROM USER_TAB_COLUMNS
        WHERE TABLE_NAME = :tableName
        ORDER BY COLUMN_ID
    `;
  try {
    const result = await conn.execute(
      query,
      { tableName: tableName.toUpperCase() },
      { outFormat: import_oracledb.default.OUT_FORMAT_OBJECT }
    );
    if (!result.rows || result.rows.length === 0) {
      console.error(`Error: Table '${tableName}' not found in USER_TAB_COLUMNS`);
      process.exit(1);
    }
    const schema = result.rows.map((col) => ({
      name: col.COLUMN_NAME,
      type: col.DATA_TYPE,
      length: col.DATA_LENGTH,
      precision: col.DATA_PRECISION,
      scale: col.DATA_SCALE,
      nullable: col.NULLABLE === "Y"
    }));
    return schema;
  } catch (error) {
    console.error("Error querying table schema:", error);
    process.exit(1);
  }
}
async function getPrimaryKeys(conn, tableName) {
  const query = `
        SELECT COLS.COLUMN_NAME
        FROM USER_CONSTRAINTS CONS
        JOIN USER_CONS_COLUMNS COLS 
            ON CONS.CONSTRAINT_NAME = COLS.CONSTRAINT_NAME
        WHERE CONS.CONSTRAINT_TYPE = 'P'
            AND CONS.TABLE_NAME = :tableName
        ORDER BY COLS.POSITION
    `;
  try {
    const result = await conn.execute(
      query,
      { tableName: tableName.toUpperCase() }
    );
    return result.rows?.map((row) => row[0]) || [];
  } catch (error) {
    console.warn("Warning: Could not retrieve primary keys:", error);
    return [];
  }
}
var TSTRUCT_QUERY = `
    SELECT DISTINCT NAME, CAPTION PAGE_TITLE
    FROM tstructs
    WHERE name = :tstruct
`;
var DC_QUERY = `
    SELECT dname DC_NAME, tablename TABLE_NAME, asgrid AS_GRID
    FROM axpdc
    WHERE tstruct = :tstruct
`;
var FIELDS_QUERY = `
    SELECT fname FIELD_NAME, datatype DATA_TYPE, flddecimal FIELD_DECIMAL, modeofentry MODE_OF_ENTRY,
           fldsql FIELD_SQL, caption FIELD_CAPTION, expression EXPRESSION, valexpr VALUE_EXPRESSION,
           srctf SRC_TF, hidden IS_HIDDEN, readonly IS_READONLY, savevalue SAVE_VALUE, ordno ORDER_NO,
              dcname DC_NAME
    FROM axpflds
    wHERE tstruct = :tstruct
    ORDER BY ordno
`;
var getAxpertStructure = async (tstruct) => {
  try {
    const conn = await getOracleConnection();
    debug(`Fetching Axpert structure for tstruct=${tstruct}`);
    const structure = {
      name: "",
      dcs: [],
      tables: { master: null, details: [] },
      pageTitle: void 0
    };
    let result = await conn.execute(
      TSTRUCT_QUERY,
      { tstruct },
      { outFormat: import_oracledb.default.OUT_FORMAT_OBJECT }
    );
    if (!result.rows || result.rows.length === 0) {
      throw new Error(`Tstruct '${tstruct}' not found`);
    }
    const tstructRow = result.rows[0];
    structure.name = tstructRow.NAME;
    structure.pageTitle = tstructRow.PAGE_TITLE;
    debug(`Found tstruct: ${structure.name} with title: ${structure.pageTitle}`);
    result = await conn.execute(
      DC_QUERY,
      { tstruct },
      { outFormat: import_oracledb.default.OUT_FORMAT_OBJECT }
    );
    const dcs = result.rows || [];
    debug(`Found ${dcs.length} DCs for tstruct=${tstruct}`);
    const fieldsResult = await conn.execute(
      FIELDS_QUERY,
      { tstruct },
      {
        outFormat: import_oracledb.default.OUT_FORMAT_OBJECT,
        fetchInfo: {
          "FIELD_SQL": { type: import_oracledb.default.STRING },
          "EXPRESSION": { type: import_oracledb.default.STRING },
          "VALUE_EXPRESSION": { type: import_oracledb.default.STRING }
        }
      }
    );
    const fields = fieldsResult.rows || [];
    debug(`Found ${fields.length} fields for tstruct=${tstruct}`);
    structure.dcs = dcs.map((dc) => ({
      name: dc.DC_NAME,
      tablename: dc.TABLE_NAME,
      asgrid: dc.AS_GRID,
      fields: fields.filter((f) => f.DC_NAME === dc.DC_NAME).map((f) => ({
        fname: f.FIELD_NAME,
        datatype: f.DATA_TYPE,
        modeofentry: f.MODE_OF_ENTRY,
        fielddecimal: f.FIELD_DECIMAL,
        fldsql: f.FIELD_SQL,
        caption: f.FIELD_CAPTION,
        expression: f.EXPRESSION,
        valexpr: f.VALUE_EXPRESSION,
        srctf: f.SRC_TF,
        hidden: f.IS_HIDDEN,
        readonly: f.IS_READONLY,
        savevalue: f.SAVE_VALUE,
        ordno: f.ORDER_NO,
        tablename: dc.TABLE_NAME,
        asgrid: dc.AS_GRID,
        dcname: dc.DC_NAME
      }))
    }));
    debug(`Populated DC definitions`);
    const masterTableName = dcs.find((dc) => dc.AS_GRID !== "T")?.TABLE_NAME;
    if (masterTableName) {
      const masterColumns = await getTableSchema(conn, masterTableName);
      const masterPrimaryKeys = await getPrimaryKeys(conn, masterTableName);
      structure.tables.master = {
        tableName: masterTableName,
        columns: masterColumns,
        primaryKeys: masterPrimaryKeys
      };
      debug(`Populated master table schema for ${masterTableName}`);
    }
    for (const dc of dcs.filter((dc2) => dc2.AS_GRID === "T")) {
      const detailColumns = await getTableSchema(conn, dc.TABLE_NAME);
      const detailPrimaryKeys = await getPrimaryKeys(conn, dc.TABLE_NAME);
      debug(`Populating detail table schema for ${dc.TABLE_NAME}`);
      structure.tables.details.push({
        tableName: dc.TABLE_NAME,
        columns: detailColumns,
        primaryKeys: detailPrimaryKeys
      });
    }
    debug(`Populated detail table schemas`);
    await conn.close();
    return structure;
  } catch (error) {
    console.error("Error querying tstructs table:", error);
    return null;
  }
};

// src/config.ts
var path3 = __toESM(require("path"), 1);
var __dirname2 = path3.dirname(__filename);
var cliRoot = path3.resolve(__dirname2, "..");
function getTemplatePath(type) {
  return path3.resolve(cliRoot, "./templates", type);
}

// src/typeMapping.ts
function toClassName(tableName) {
  return tableName.replace(" ", "_").split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join("");
}

// src/fileUtils.ts
var fs3 = __toESM(require("fs"), 1);
var path4 = __toESM(require("path"), 1);
function dirExists(dirPath) {
  return fs3.existsSync(dirPath) && fs3.statSync(dirPath).isDirectory();
}
function createDir(dirPath, ...args) {
  const fullPath = path4.join(dirPath, ...args);
  if (!fs3.existsSync(fullPath)) {
    fs3.mkdirSync(fullPath, { recursive: true });
  }
}

// src/axpertPageGenerator.ts
async function buildCreatePageContext(tstruct, moduleName, dbConfig) {
  const axp_struct = await getAxpertStructure(tstruct);
  if (!axp_struct) {
    throw new Error(`Axpert structure not found for tstruct: ${tstruct}`);
  }
  return axp_struct;
}
function capitalize2(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function buildAxpertPlaceholders(ctx) {
  return {
    __module__: ctx.moduleName,
    __Module__: capitalize2(ctx.moduleName),
    __MODULE__: ctx.moduleName.toUpperCase(),
    __page__: ctx.page?.name ?? "",
    __Page__: capitalize2(ctx.page?.name ?? ""),
    __PAGE__: (ctx.page?.name ?? "").toUpperCase(),
    __TSTRUCT__: ctx.tstruct,
    __Tstruct__: capitalize2(ctx.tstruct),
    __tstruct__: ctx.tstruct.toLowerCase(),
    tstuct: ctx.tstruct,
    PAGE_NAME: ctx.page?.name ?? "",
    PAGE_TITLE: ctx.pageTitle ?? "",
    MASTER_TABLE: ctx.tables.master.tableName ?? ""
    // MASTER_PK: JSON.stringify(ctx.tables.master.primaryKeys ?? []),
    // MASTER_FIELDS: JSON.stringify(ctx.tables.master.columns ?? []),
    // DETAILS: JSON.stringify(ctx.tables.details ?? []),
    // DCS: JSON.stringify(ctx.dcs ?? []),
  };
}
async function createAxpertBackendModule(moduleName, backendRoot, templateRoot, placeholders, context, options) {
  log("Generating backend module...");
  const backendOutput = import_path.default.join(backendRoot, moduleName);
  const modelDir = import_path.default.join(backendOutput, "models");
  if (!dirExists(modelDir)) {
    createDir(modelDir);
  }
  const { master, details } = context.tables;
  debug(`Generating master model for table ${master.tableName}`);
  const masterModelFile = import_path.default.join(
    modelDir,
    `${context.pageTitle.replace(/\s+/g, "_").toLocaleLowerCase()}_model.py`
  );
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "backend", "MODEL.eta"),
    masterModelFile,
    {
      TABLE_NAME: master.tableName,
      CLASS_NAME: toClassName(context.pageTitle),
      COLUMNS: master.columns,
      PRIMARY_KEYS: master.primaryKeys,
      MASTER_TABLE: master.tableName,
      DETAILS: details,
      SCHEMA: context,
      toClassName
    },
    placeholders
  );
  debug(`Master model written to ${masterModelFile}`);
  for (const detailTable of details) {
    debug(`Generating detail model for table ${detailTable.tableName}`);
    const detailModelFile = import_path.default.join(
      modelDir,
      `${detailTable.tableName.toLocaleLowerCase()}_model.py`
    );
    writeCompiledTemplate(
      import_path.default.join(templateRoot, "backend", "MODEL.eta"),
      detailModelFile,
      {
        SCHEMA: context,
        TABLE_NAME: detailTable.tableName,
        CLASS_NAME: toClassName(detailTable.tableName),
        COLUMNS: detailTable.columns,
        PRIMARY_KEYS: detailTable.primaryKeys,
        MASTER_TABLE: master.tableName,
        DETAILS: details,
        toClassName
      },
      placeholders
    );
    debug(`Detail model written to ${detailModelFile}`);
  }
  debug(`Generating master model init file`);
  const masterModelInitFile = import_path.default.join(
    modelDir,
    `__init__.py`
  );
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "backend", "MODEL_INIT.eta"),
    masterModelInitFile,
    {
      TABLE_NAME: master.tableName,
      CLASS_NAME: toClassName(master.tableName),
      COLUMNS: master.columns,
      PRIMARY_KEYS: master.primaryKeys,
      toClassName,
      MASTER_TABLE: master.tableName,
      DETAILS: details,
      SCHEMA: context
    },
    placeholders
  );
  debug(`Master model init file written to ${masterModelInitFile}`);
  debug("Model generation completed");
  debug("Generating Service layer...");
  const serviceDir = import_path.default.join(backendOutput, "services");
  if (!dirExists(serviceDir)) {
    createDir(serviceDir);
  }
  debug(`service path=${serviceDir}`);
  const serviceFile = import_path.default.join(
    serviceDir,
    `${context.pageTitle.replace(/\s+/g, "_").toLocaleLowerCase()}_service.py`
  );
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "backend", "MODEL_SERVICE.eta"),
    serviceFile,
    {
      SCHEMA: context,
      MASTER_TABLE: master.tableName,
      SERVICE_NAME: `${toClassName(master.tableName)}Service`,
      CLASS_NAME: toClassName(context.pageTitle),
      DETAILS: details,
      toClassName
    },
    placeholders
  );
  debug("Generating Data Service layer...");
  const data_service_file = import_path.default.join(
    serviceDir,
    `${context.pageTitle.replace(/\s+/g, "_").toLocaleLowerCase()}_data_service.py`
  );
  console.log(JSON.stringify(context), null, 2);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "backend", "DATA_SERVICE.eta"),
    data_service_file,
    {
      SCHEMA: context,
      MASTER_TABLE: master.tableName,
      SERVICE_NAME: `DataService`,
      CLASS_NAME: "DataService",
      DETAILS: details,
      toClassName
    },
    placeholders
  );
  debug("Generating Data Service init layer...");
  const serviceInitFile = import_path.default.join(
    serviceDir,
    `__init__.py`
  );
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "backend", "SERVICE_INIT.eta"),
    serviceInitFile,
    {
      SCHEMA: context,
      MASTER_TABLE: master.tableName,
      SERVICE_NAME: `${toClassName(master.tableName)}Service`,
      CLASS_NAME: toClassName(master.tableName),
      DETAILS: details,
      toClassName
    },
    placeholders
  );
  debug("Generating Data Service layer completed");
  debug("Generating Schema file...");
  const schemaDir = import_path.default.join(backendOutput, "schemas");
  if (!dirExists(schemaDir)) {
    createDir(schemaDir);
  }
  const schemaTemplateInitPath = import_path.default.join(templateRoot, "backend", "SCHEMA_INIT.eta");
  const schemaTemplatePath = import_path.default.join(templateRoot, "backend", "SCHEMA.eta");
  writeCompiledTemplate(
    schemaTemplateInitPath,
    import_path.default.join(schemaDir, `__init__.py`),
    {
      SCHEMA: context,
      MASTER_TABLE: master.tableName,
      CLASS_NAME: toClassName(master.tableName),
      DETAILS: details,
      COLUMNS: master.columns,
      PRIMARY_KEYS: master.primaryKeys,
      toClassName
    },
    placeholders
  );
  writeCompiledTemplate(
    schemaTemplatePath,
    import_path.default.join(schemaDir, `${context.pageTitle?.replace(/\s+/g, "_").toLowerCase()}_schema.py`),
    {
      SCHEMA: context,
      MASTER_TABLE: master.tableName,
      CLASS_NAME: toClassName(context.pageTitle) + "Schema",
      DETAILS: details,
      COLUMNS: master.columns,
      PRIMARY_KEYS: master.primaryKeys,
      toClassName,
      is_master: true
    },
    placeholders
  );
  for (const detail of details) {
    console.log(`Generating schema for detail table ${detail.tableName}`);
    const schemaFile = import_path.default.join(schemaDir, `${detail.tableName}_schema.py`);
    writeCompiledTemplate(
      schemaTemplatePath,
      schemaFile,
      {
        SCHEMA: context,
        MASTER_TABLE: master.tableName,
        CLASS_NAME: toClassName(`${detail.tableName}`) + "Schema",
        DETAILS: details,
        COLUMNS: detail.columns,
        PRIMARY_KEYS: detail.primaryKeys,
        toClassName,
        is_master: false
      },
      placeholders
    );
  }
  const parameterSchemaPath = import_path.default.join(
    templateRoot,
    "backend",
    "PARAMETER_SCHEMA.eta"
  );
  writeCompiledTemplate(
    parameterSchemaPath,
    import_path.default.join(schemaDir, `parameter.py`),
    {
      SCHEMA: context,
      MASTER_TABLE: master.tableName,
      CLASS_NAME: toClassName(master.tableName),
      DETAILS: details,
      FIELDS: context.dcs.flatMap((dc) => dc.fields),
      toClassName
    },
    placeholders
  );
  debug("Schema file generation completed");
  debug("Generating Router file...");
  const routeFile = import_path.default.join(backendOutput, `router.py`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "backend", "ROUTER.eta"),
    routeFile,
    {
      SCHEMA: context,
      MODULE_NAME: moduleName,
      CLASS_NAME: toClassName(master.tableName),
      MODEL_SERVICE_NAME: `${toClassName(moduleName)}Service`,
      DATA_SERVICE_NAME: `DataService`,
      MASTER_TABLE: master.tableName,
      DETAILS: details,
      toClassName
    },
    placeholders
  );
  debug(`Router file written to ${routeFile}`);
  try {
    debug("Copying other backend files...");
    const otherBackendTemplate = import_path.default.join(templateRoot, "backend", "other");
    copyTemplateStructure(otherBackendTemplate, backendOutput, placeholders);
  } catch (error) {
    debug(`Error copying other backend files: ${error.message}`);
  }
  const initFile = import_path.default.join(backendOutput, `__init__.py`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "backend", "INIT.eta"),
    initFile,
    {
      SCHEMA: context,
      toClassName
    },
    placeholders
  );
  debug("Backend generation completed");
}
async function createAxpertFrontendModule(moduleName, frontendRoot, templateRoot, placeholders, context, options) {
  log("Generating frontend module...");
  log("Generating frontend...");
  const frontendOutput = import_path.default.join(frontendRoot, moduleName);
  const componentsOutput = import_path.default.join(frontendOutput, "components");
  const schemasPath = import_path.default.join(frontendOutput, "schemas");
  createDir(schemasPath);
  debug(`frontend path=${frontendOutput}`);
  createDir(componentsOutput);
  debug(`components path=${componentsOutput}`);
  for (const dc of context.dcs) {
    const schemaFile = import_path.default.join(schemasPath, `${dc.name}Schema.ts`);
    if (!options?.dryRun) {
      debug(`Writing schema for table ${dc.tablename} to ${schemaFile}`);
      writeCompiledTemplate(
        import_path.default.join(templateRoot, "frontend", "DC_SCHEMA.eta"),
        schemaFile,
        {
          DC_NAME: dc.name,
          FIELDS: dc.fields,
          // SCHEMA: JSON.stringify(dc),
          toClassName
        },
        placeholders
      );
      const componentFile = import_path.default.join(
        componentsOutput,
        `${dc.name}Component.tsx`
      );
      debug(`Writing component for table ${dc.tablename} to ${componentFile}`);
      writeCompiledTemplate(
        import_path.default.join(templateRoot, "frontend", "DC_COMPONENT.eta"),
        componentFile,
        {
          dc,
          DC_NAME: dc.name,
          COMPONENT_NAME: `${dc.name}Component`,
          SCHEMA: context,
          ...context,
          toClassName
        },
        placeholders
      );
    } else {
      debug(
        `Dry-run: skipping schema write for table ${dc.tablename} to ${schemaFile}`
      );
    }
  }
  const allSchemaFile = import_path.default.join(schemasPath, `allSchemas.ts`);
  debug("Generating all schemas index...");
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "ALL_SCHEMA.eta"),
    allSchemaFile,
    {
      DCS: context.dcs,
      capitalize: capitalize2,
      toClassName
    },
    placeholders
  );
  const schemaIndexFile = import_path.default.join(schemasPath, `index.ts`);
  debug(`Writing schema index to ${schemaIndexFile}`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "schemaIndex.eta"),
    schemaIndexFile,
    {
      DCS: context.dcs,
      capitalize: capitalize2,
      toClassName
    },
    placeholders
  );
  const componentIndexFile = import_path.default.join(componentsOutput, `index.ts`);
  debug(`Writing component index to ${componentIndexFile}`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "componentIndex.eta"),
    componentIndexFile,
    {
      DCS: context.dcs,
      capitalize: capitalize2,
      toClassName
    },
    placeholders
  );
  const pageFile = import_path.default.join(
    frontendOutput,
    `${placeholders["__Page__"]}Page.tsx`
  );
  debug(`Writing page to ${pageFile}`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "PAGE_FORM.eta"),
    pageFile,
    {
      ...context,
      ...placeholders,
      toClassName
    },
    placeholders
  );
  const pageFormFile = import_path.default.join(
    frontendOutput,
    `${placeholders["__Page__"]}Page.tsx`
  );
  debug(`Writing page form to ${pageFormFile}`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "PAGE_INDEX.eta"),
    pageFormFile,
    {
      ...context,
      ...placeholders
    },
    placeholders
  );
  const typesFile = import_path.default.join(frontendOutput, `types.ts`);
  debug(`Writing types to ${typesFile}`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "TYPES.eta"),
    typesFile,
    {
      ...context,
      ...placeholders
    },
    placeholders
  );
  const apiFile = import_path.default.join(frontendOutput, `api.ts`);
  debug(`Writing API to ${apiFile}`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "API.eta"),
    apiFile,
    {
      ...context,
      ...placeholders
    },
    placeholders
  );
  const otherFrontendTemplate = import_path.default.join(templateRoot, "frontend", "other");
  debug(`Copying other frontend files from ${otherFrontendTemplate}`);
  copyTemplateStructure(otherFrontendTemplate, frontendOutput, placeholders);
  debug(`Writing page styles`);
  const pageStylesFile = import_path.default.join(frontendOutput, `styles.css`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "PAGE_STYLES.eta"),
    pageStylesFile,
    {
      ...context,
      ...placeholders
    },
    placeholders
  );
  debug(`Writing page index`);
  const pageIndexFile = import_path.default.join(frontendOutput, `index.ts`);
  writeCompiledTemplate(
    import_path.default.join(templateRoot, "frontend", "PAGE_INDEX_FILE.eta"),
    pageIndexFile,
    {
      ...context,
      ...placeholders
    },
    placeholders
  );
  debug("Frontend generation completed");
}
async function createAxpertPage(tstruct, moduleName, backendRoot, frontendRoot, templateRoot, dbConfig, options) {
  log("Starting Axpert page generation");
  debug(`tstruct=${tstruct}`);
  debug(`module=${moduleName}`);
  debug(`templateRoot=${templateRoot}`);
  if (options?.skipBackend && options?.skipFrontend) {
    throw new Error(
      "Both backend and frontend are skipped. Nothing to generate."
    );
  }
  const context = await buildCreatePageContext(tstruct, moduleName, dbConfig);
  debug(`context keys: ${Object.keys(context).join(", ")}`);
  const placeholders = buildAxpertPlaceholders({
    moduleName,
    tstruct,
    ...context
  });
  const scopeCtx = {
    moduleName,
    tstruct,
    ...context,
    toClassName
  };
  debug(`placeholders: ${Object.keys(placeholders).join(", ")}`);
  if (!options?.skipBackend) {
    log("Generating backend...");
    createAxpertBackendModule(
      moduleName,
      backendRoot,
      templateRoot,
      placeholders,
      context,
      { dryRun: options?.dryRun }
    );
  } else {
    log("Backend generation skipped");
  }
  if (!options?.skipFrontend) {
    createAxpertFrontendModule(
      moduleName,
      frontendRoot,
      templateRoot,
      placeholders,
      context,
      { dryRun: options?.dryRun }
    );
  } else {
    log("Frontend generation skipped");
  }
  log("Axpert page generation completed");
}

// src/axpertPicker.ts
var import_inquirer = __toESM(require("inquirer"), 1);
var import_oracledb2 = __toESM(require_oracledb2(), 1);
async function pickTstructInteractive(dbConfig) {
  const conn = await import_oracledb2.default.getConnection({
    user: dbConfig.user,
    password: dbConfig.password,
    connectString: dbConfig.connectString
  });
  try {
    const result = await conn.execute(
      `
      SELECT DISTINCT name AS TSTRUCT
      FROM tstructs
      ORDER BY name
      `,
      [],
      { outFormat: import_oracledb2.default.OUT_FORMAT_OBJECT }
    );
    const rows = result.rows ?? [];
    if (!rows.length) {
      throw new Error("No tstructs found in database");
    }
    const choices = rows.map((r) => r.TSTRUCT);
    const answer = await import_inquirer.default.prompt([
      {
        type: "list",
        name: "tstruct",
        message: "Select tstruct:",
        choices
      }
    ]);
    return answer.tstruct;
  } finally {
    await conn.close();
  }
}

// src/commands/init.ts
var import_child_process = require("child_process");
var import_path2 = __toESM(require("path"), 1);
function ensurePackage(pkg, opts = {}) {
  const { version = "", silent = false } = opts;
  const name = version ? `${pkg}@${version}` : pkg;
  try {
    return require(pkg);
  } catch {
    console.log(`\u{1F4E6} ${pkg} not found. Installing automatically...`);
    const cliRoot2 = import_path2.default.resolve(__dirname, "..", "..");
    (0, import_child_process.execSync)(`npm install ${name} --no-save`, {
      cwd: cliRoot2,
      stdio: silent ? "ignore" : "inherit"
    });
    console.log(`\u2705 ${pkg} installed`);
    return require(pkg);
  }
}

// src/index.ts
var program = new import_commander.Command();
program.command("create-axpert-page [tstruct]").description("Create Axpert backend + frontend from DB structure").option("--interactive", "Pick tstruct interactively").option("-m, --module <name>", "Module name (default: tstruct)").option("-b, --backend <path>", "Override backend output path").option("-f, --frontend <path>", "Override frontend output path").option("--skip-backend", "Skip backend generation").option("--skip-frontend", "Skip frontend generation").option("--verbose", "Enable verbose output").option("--debug", "Enable debug output").option("--dry-run", "Preview actions without writing files").action(async (tstructArg, opts) => {
  try {
    setLogLevel({ verbose: opts.verbose, debug: opts.debug });
    const config = loadConfig();
    let tstruct = tstructArg;
    if (!tstruct || opts.interactive) {
      tstruct = await pickTstructInteractive(config.axpert.db);
    }
    const moduleName = opts.module ?? tstruct;
    const backendRoot = opts.backend ?? config.paths.backend;
    const frontendRoot = opts.frontend ?? config.paths.frontend;
    await createAxpertPage(
      tstruct,
      moduleName,
      backendRoot,
      frontendRoot,
      getTemplatePath("axpert"),
      config.axpert.db,
      {
        skipBackend: !!opts.skipBackend,
        skipFrontend: !!opts.skipFrontend,
        dryRun: !!opts.dryRun
      }
    );
    console.log("\n\u2705 Axpert page processed successfully\n");
  } catch (err) {
    console.error("Error:", err);
    process.exit(1);
  }
});
program.command("create-page").description("Create a new frontend/backend page from the template structure (no logic, no content)").argument("<module>", "Module name (used for placeholder replacement)").argument("<page>", "Page name (used for placeholder replacement)").option("-o, --output <path>", "Output directory for the new page", "./modules").action(async (module2, page, options) => {
  try {
    const templateRoot = getTemplatePath("page");
    const outputRoot = path7.resolve(process.cwd(), options.output, module2, page);
    generatePageFromTemplate(templateRoot, outputRoot, page);
    console.log(`
\u2705 Page created at: ${outputRoot}
`);
  } catch (err) {
    console.error("Error creating page:", err);
    process.exit(1);
  }
});
program.command("init").description("Initialize BSS CLI configuration").action(async () => {
  try {
    console.log("Checking Dependencies...");
    ensurePackage("inquirer", { silent: true });
    console.log("Inquirer is installed.");
    ensurePackage("fs-extra", { silent: true });
    console.log("fs-extra is installed.");
    ensurePackage("oracledb", { silent: true });
    console.log("oracledb is installed.");
    console.log("All dependencies are satisfied.\n");
    console.log("\n\u{1F4CB} BSS CLI Initialization\n");
    console.log("Please provide the following configuration details:\n");
    const inquirer2 = (await import("inquirer")).default;
    const answers = await inquirer2.prompt([
      {
        type: "input",
        name: "backendPath",
        message: "Backend modules path:",
        default: "./backend/apps/modules",
        validate: (v) => v.trim() !== "" || "Required"
      },
      {
        type: "input",
        name: "frontendPath",
        message: "Frontend modules path:",
        default: "./frontend/apps/modules",
        validate: (v) => v.trim() !== "" || "Required"
      },
      {
        type: "input",
        name: "dbUser",
        message: "Axpert DB user:",
        validate: (v) => v.trim() !== "" || "Required"
      },
      {
        type: "password",
        name: "dbPassword",
        message: "Axpert DB password:",
        mask: "*",
        validate: (v) => v.trim() !== "" || "Required"
      },
      {
        type: "input",
        name: "dbConnect",
        message: "Axpert DB connect string (host:port/service):",
        validate: (v) => v.trim() !== "" || "Required"
      }
    ]);
    const config = {
      paths: {
        backend: answers.backendPath,
        frontend: answers.frontendPath
      },
      axpert: {
        db: {
          user: answers.dbUser,
          password: answers.dbPassword,
          connectString: answers.dbConnect
        }
      }
    };
    saveConfig(config);
    console.log("\n\u2705 bss.config.json created successfully\n");
  } catch (err) {
    console.error("Init failed:", err);
    process.exit(1);
  }
});
program.command("self-update").description("Update bss-cli to latest version").action(async () => {
  const { selfUpdate: selfUpdate2 } = await Promise.resolve().then(() => (init_selfUpdate(), selfUpdate_exports));
  await selfUpdate2();
});
program.parse();
