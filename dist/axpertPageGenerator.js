import e from'path';import {log,debug}from'./logger.js';import {writeCompiledTemplate,copyTemplateStructure}from'./templateGenerator.js';import {getAxpertStructure}from'./database.js';import {toClassName}from'./typeMapping.js';import {dirExists,createDir}from'./fileUtils.js';async function O(o,l,s){const i=await getAxpertStructure(o);if(!i)throw new Error(`Axpert structure not found for tstruct: ${o}`);return i}function C(o){return o.charAt(0).toUpperCase()+o.slice(1)}function B(o){return {__module__:o.moduleName,__Module__:C(o.moduleName),__MODULE__:o.moduleName.toUpperCase(),__page__:o.page?.name??"",__Page__:C(o.page?.name??""),__PAGE__:(o.page?.name??"").toUpperCase(),__TSTRUCT__:o.tstruct,__Tstruct__:C(o.tstruct),__tstruct__:o.tstruct.toLowerCase(),tstuct:o.tstruct,PAGE_NAME:o.page?.name??"",PAGE_TITLE:o.pageTitle??"",MASTER_TABLE:o.tables.master.tableName??""}}async function h(o,l,s,i,t,N){log("Generating backend module...");const E=t.pageTitle?t.pageTitle.replace(/\s+/g,"_").toLowerCase():o;debug(`backend path=${l}`);const A=e.join(l,E),m=e.join(A,"models");dirExists(m)||createDir(m);const{master:a,details:S}=t.tables;debug(`Generating master model for table ${a.tableName}`);const T=e.join(m,`${t.pageTitle.replace(/\s+/g,"_").toLocaleLowerCase()}_model.py`);writeCompiledTemplate(e.join(s,"backend","MODEL.eta"),T,{TABLE_NAME:a.tableName,CLASS_NAME:toClassName(t.pageTitle),COLUMNS:a.columns,PRIMARY_KEYS:a.primaryKeys,MASTER_TABLE:a.tableName,DETAILS:S,SCHEMA:t,toClassName:toClassName},i),debug(`Master model written to ${T}`);for(const c of S){debug(`Generating detail model for table ${c.tableName}`);const D=e.join(m,`${c.tableName.toLocaleLowerCase()}_model.py`);writeCompiledTemplate(e.join(s,"backend","MODEL.eta"),D,{SCHEMA:t,TABLE_NAME:c.tableName,CLASS_NAME:toClassName(c.tableName),COLUMNS:c.columns,PRIMARY_KEYS:c.primaryKeys,MASTER_TABLE:a.tableName,DETAILS:S,toClassName:toClassName},i),debug(`Detail model written to ${D}`);}debug("Generating master model init file");const b=e.join(m,"__init__.py");writeCompiledTemplate(e.join(s,"backend","MODEL_INIT.eta"),b,{TABLE_NAME:a.tableName,CLASS_NAME:toClassName(a.tableName),COLUMNS:a.columns,PRIMARY_KEYS:a.primaryKeys,toClassName:toClassName,MASTER_TABLE:a.tableName,DETAILS:S,SCHEMA:t},i),debug(`Master model init file written to ${b}`),debug("Model generation completed"),debug("Generating Service layer...");const d=e.join(A,"services");dirExists(d)||createDir(d),debug(`service path=${d}`);const L=e.join(d,`${t.pageTitle.replace(/\s+/g,"_").toLocaleLowerCase()}_service.py`);writeCompiledTemplate(e.join(s,"backend","MODEL_SERVICE.eta"),L,{SCHEMA:t,MASTER_TABLE:a.tableName,SERVICE_NAME:`${toClassName(a.tableName)}Service`,CLASS_NAME:toClassName(t.pageTitle),DETAILS:S,toClassName:toClassName},i),debug("Generating Data Service layer...");const y=e.join(d,`${t.pageTitle.replace(/\s+/g,"_").toLocaleLowerCase()}_data_service.py`);console.log(JSON.stringify(t),null,2),writeCompiledTemplate(e.join(s,"backend","DATA_SERVICE.eta"),y,{SCHEMA:t,MASTER_TABLE:a.tableName,SERVICE_NAME:"DataService",CLASS_NAME:"DataService",DETAILS:S,toClassName:toClassName},i),debug("Generating Data Service init layer...");const I=e.join(d,"__init__.py");writeCompiledTemplate(e.join(s,"backend","SERVICE_INIT.eta"),I,{SCHEMA:t,MASTER_TABLE:a.tableName,SERVICE_NAME:`${toClassName(a.tableName)}Service`,CLASS_NAME:toClassName(a.tableName),DETAILS:S,toClassName:toClassName},i),debug("Generating Data Service layer completed"),debug("Generating Schema file...");const p=e.join(A,"schemas");dirExists(p)||createDir(p);const g=e.join(s,"backend","SCHEMA_INIT.eta"),f=e.join(s,"backend","SCHEMA.eta");writeCompiledTemplate(g,e.join(p,"__init__.py"),{SCHEMA:t,MASTER_TABLE:a.tableName,CLASS_NAME:toClassName(a.tableName),DETAILS:S,COLUMNS:a.columns,PRIMARY_KEYS:a.primaryKeys,toClassName:toClassName},i),writeCompiledTemplate(f,e.join(p,`${t.pageTitle?.replace(/\s+/g,"_").toLowerCase()}_schema.py`),{SCHEMA:t,MASTER_TABLE:a.tableName,CLASS_NAME:toClassName(t.pageTitle)+"Schema",DETAILS:S,COLUMNS:a.columns,PRIMARY_KEYS:a.primaryKeys,toClassName:toClassName,is_master:true},i);for(const c of S){console.log(`Generating schema for detail table ${c.tableName}`);const D=e.join(p,`${c.tableName}_schema.py`);writeCompiledTemplate(f,D,{SCHEMA:t,MASTER_TABLE:a.tableName,CLASS_NAME:toClassName(`${c.tableName}`)+"Schema",DETAILS:S,COLUMNS:c.columns,PRIMARY_KEYS:c.primaryKeys,toClassName:toClassName,is_master:false},i);}const j=e.join(s,"backend","PARAMETER_SCHEMA.eta");writeCompiledTemplate(j,e.join(p,"parameter.py"),{SCHEMA:t,MASTER_TABLE:a.tableName,CLASS_NAME:toClassName(a.tableName),DETAILS:S,FIELDS:t.dcs.flatMap(c=>c.fields),toClassName:toClassName},i),debug("Schema file generation completed"),debug("Generating Router file...");const k=e.join(A,"routes.py");writeCompiledTemplate(e.join(s,"backend","ROUTER.eta"),k,{SCHEMA:t,MODULE_NAME:o,CLASS_NAME:toClassName(a.tableName),MODEL_SERVICE_NAME:`${toClassName(o)}Service`,DATA_SERVICE_NAME:"DataService",MASTER_TABLE:a.tableName,DETAILS:S,toClassName:toClassName},i),debug(`Router file written to ${k}`);try{debug("Copying other backend files...");const c=e.join(s,"backend","other");copyTemplateStructure(c,A,i);}catch(c){debug(`Error copying other backend files: ${c.message}`);}const F=e.join(A,"__init__.py");writeCompiledTemplate(e.join(s,"backend","INIT.eta"),F,{SCHEMA:t,toClassName:toClassName},i),debug("Backend generation completed");}async function G(o,l,s,i,t,N){log("Generating frontend module..."),log("Generating frontend...");const E=e.join(l,o),A=e.join(E,"components"),m=e.join(E,"schemas");createDir(m),debug(`frontend path=${E}`),createDir(A),debug(`components path=${A}`);for(const g of t.dcs){const f=e.join(m,`${g.name}Schema.ts`);if(N?.dryRun)debug(`Dry-run: skipping schema write for table ${g.tablename} to ${f}`);else {debug(`Writing schema for table ${g.tablename} to ${f}`),writeCompiledTemplate(e.join(s,"frontend","DC_SCHEMA.eta"),f,{DC_NAME:g.name,FIELDS:g.fields,toClassName:toClassName},i);const j=e.join(A,`${g.name}Component.tsx`);debug(`Writing component for table ${g.tablename} to ${j}`),writeCompiledTemplate(e.join(s,"frontend","DC_COMPONENT.eta"),j,{dc:g,DC_NAME:g.name,COMPONENT_NAME:`${g.name}Component`,SCHEMA:t,...t,toClassName:toClassName},i);}}const a=e.join(m,"allSchemas.ts");debug("Generating all schemas index..."),writeCompiledTemplate(e.join(s,"frontend","ALL_SCHEMA.eta"),a,{DCS:t.dcs,capitalize:C,toClassName:toClassName},i);const S=e.join(m,"index.ts");debug(`Writing schema index to ${S}`),writeCompiledTemplate(e.join(s,"frontend","schemaIndex.eta"),S,{DCS:t.dcs,capitalize:C,toClassName:toClassName},i);const T=e.join(A,"index.ts");debug(`Writing component index to ${T}`),writeCompiledTemplate(e.join(s,"frontend","componentIndex.eta"),T,{DCS:t.dcs,capitalize:C,toClassName:toClassName},i);const b=e.join(E,`${i.__Page__}Page.tsx`);debug(`Writing page to ${b}`),writeCompiledTemplate(e.join(s,"frontend","PAGE_FORM.eta"),b,{...t,...i,toClassName:toClassName},i);const d=e.join(E,`${i.__Page__}Page.tsx`);debug(`Writing page form to ${d}`),writeCompiledTemplate(e.join(s,"frontend","PAGE_INDEX.eta"),d,{...t,...i},i);const L=e.join(E,"types.ts");debug(`Writing types to ${L}`),writeCompiledTemplate(e.join(s,"frontend","TYPES.eta"),L,{...t,...i},i);const y=e.join(E,"api.ts");debug(`Writing API to ${y}`),writeCompiledTemplate(e.join(s,"frontend","API.eta"),y,{...t,...i},i);try{debug("Copying other frontend files...");const g=e.join(s,"frontend","other");copyTemplateStructure(g,E,i);}catch(g){debug(`Error copying other frontend files: ${g}`);}debug("Writing page styles");const I=e.join(E,"styles.css");writeCompiledTemplate(e.join(s,"frontend","PAGE_STYLES.eta"),I,{...t,...i},i),debug("Writing page index");const p=e.join(E,"index.ts");writeCompiledTemplate(e.join(s,"frontend","PAGE_INDEX_FILE.eta"),p,{...t,...i},i),debug("Frontend generation completed");}async function ee(o,l,s,i,t,N,E){if(log("Starting Axpert page generation"),debug(`tstruct=${o}`),debug(`module=${l}`),debug(`templateRoot=${t}`),E?.skipBackend&&E?.skipFrontend)throw new Error("Both backend and frontend are skipped. Nothing to generate.");const A=await O(o);debug(`context keys: ${Object.keys(A).join(", ")}`);const m=B({moduleName:l,tstruct:o,...A});({...A});debug(`placeholders: ${Object.keys(m).join(", ")}`),E?.skipBackend?log("Backend generation skipped"):(log("Generating backend..."),h(l,s,t,m,A,{dryRun:E?.dryRun})),E?.skipFrontend?log("Frontend generation skipped"):G(l,i,t,m,A,{dryRun:E?.dryRun}),log("Axpert page generation completed");}export{B as buildAxpertPlaceholders,h as createAxpertBackendModule,G as createAxpertFrontendModule,ee as createAxpertPage};